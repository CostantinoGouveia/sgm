
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model alertaroubo
 * 
 */
export type alertaroubo = $Result.DefaultSelection<Prisma.$alertarouboPayload>
/**
 * Model automobilista
 * 
 */
export type automobilista = $Result.DefaultSelection<Prisma.$automobilistaPayload>
/**
 * Model bi
 * 
 */
export type bi = $Result.DefaultSelection<Prisma.$biPayload>
/**
 * Model cartaconducao
 * 
 */
export type cartaconducao = $Result.DefaultSelection<Prisma.$cartaconducaoPayload>
/**
 * Model categoriacarta
 * 
 */
export type categoriacarta = $Result.DefaultSelection<Prisma.$categoriacartaPayload>
/**
 * Model contacto
 * 
 */
export type contacto = $Result.DefaultSelection<Prisma.$contactoPayload>
/**
 * Model endereco
 * 
 */
export type endereco = $Result.DefaultSelection<Prisma.$enderecoPayload>
/**
 * Model ficheiro
 * 
 */
export type ficheiro = $Result.DefaultSelection<Prisma.$ficheiroPayload>
/**
 * Model funcionario
 * 
 */
export type funcionario = $Result.DefaultSelection<Prisma.$funcionarioPayload>
/**
 * Model infracao
 * 
 */
export type infracao = $Result.DefaultSelection<Prisma.$infracaoPayload>
/**
 * Model livrete
 * 
 */
export type livrete = $Result.DefaultSelection<Prisma.$livretePayload>
/**
 * Model marca
 * 
 */
export type marca = $Result.DefaultSelection<Prisma.$marcaPayload>
/**
 * Model multa
 * 
 */
export type multa = $Result.DefaultSelection<Prisma.$multaPayload>
/**
 * Model municipio
 * 
 */
export type municipio = $Result.DefaultSelection<Prisma.$municipioPayload>
/**
 * Model pagamentomulta
 * 
 */
export type pagamentomulta = $Result.DefaultSelection<Prisma.$pagamentomultaPayload>
/**
 * Model pais
 * 
 */
export type pais = $Result.DefaultSelection<Prisma.$paisPayload>
/**
 * Model pessoa
 * 
 */
export type pessoa = $Result.DefaultSelection<Prisma.$pessoaPayload>
/**
 * Model provincia
 * 
 */
export type provincia = $Result.DefaultSelection<Prisma.$provinciaPayload>
/**
 * Model serivicoviatura
 * 
 */
export type serivicoviatura = $Result.DefaultSelection<Prisma.$serivicoviaturaPayload>
/**
 * Model tipoinfracao
 * 
 */
export type tipoinfracao = $Result.DefaultSelection<Prisma.$tipoinfracaoPayload>
/**
 * Model tiporoubo
 * 
 */
export type tiporoubo = $Result.DefaultSelection<Prisma.$tiporouboPayload>
/**
 * Model titulopropriedade
 * 
 */
export type titulopropriedade = $Result.DefaultSelection<Prisma.$titulopropriedadePayload>
/**
 * Model viatura
 * 
 */
export type viatura = $Result.DefaultSelection<Prisma.$viaturaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ficheiro_estadoValidacao: {
  Pendente: 'Pendente',
  Validado: 'Validado',
  Invalidado: 'Invalidado'
};

export type ficheiro_estadoValidacao = (typeof ficheiro_estadoValidacao)[keyof typeof ficheiro_estadoValidacao]


export const multa_estadoMulta: {
  PAGO: 'PAGO',
  N_O_PAGO: 'N_O_PAGO',
  PENDENTE: 'PENDENTE'
};

export type multa_estadoMulta = (typeof multa_estadoMulta)[keyof typeof multa_estadoMulta]


export const pessoa_genero: {
  Masculino: 'Masculino',
  Feminino: 'Feminino'
};

export type pessoa_genero = (typeof pessoa_genero)[keyof typeof pessoa_genero]


export const pessoa_estadoCivil: {
  Solteiro: 'Solteiro',
  Casado: 'Casado',
  Solteira: 'Solteira',
  Casada: 'Casada'
};

export type pessoa_estadoCivil = (typeof pessoa_estadoCivil)[keyof typeof pessoa_estadoCivil]

}

export type ficheiro_estadoValidacao = $Enums.ficheiro_estadoValidacao

export const ficheiro_estadoValidacao: typeof $Enums.ficheiro_estadoValidacao

export type multa_estadoMulta = $Enums.multa_estadoMulta

export const multa_estadoMulta: typeof $Enums.multa_estadoMulta

export type pessoa_genero = $Enums.pessoa_genero

export const pessoa_genero: typeof $Enums.pessoa_genero

export type pessoa_estadoCivil = $Enums.pessoa_estadoCivil

export const pessoa_estadoCivil: typeof $Enums.pessoa_estadoCivil

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Alertaroubos
 * const alertaroubos = await prisma.alertaroubo.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Alertaroubos
   * const alertaroubos = await prisma.alertaroubo.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.alertaroubo`: Exposes CRUD operations for the **alertaroubo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alertaroubos
    * const alertaroubos = await prisma.alertaroubo.findMany()
    * ```
    */
  get alertaroubo(): Prisma.alertarouboDelegate<ExtArgs>;

  /**
   * `prisma.automobilista`: Exposes CRUD operations for the **automobilista** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Automobilistas
    * const automobilistas = await prisma.automobilista.findMany()
    * ```
    */
  get automobilista(): Prisma.automobilistaDelegate<ExtArgs>;

  /**
   * `prisma.bi`: Exposes CRUD operations for the **bi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bis
    * const bis = await prisma.bi.findMany()
    * ```
    */
  get bi(): Prisma.biDelegate<ExtArgs>;

  /**
   * `prisma.cartaconducao`: Exposes CRUD operations for the **cartaconducao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cartaconducaos
    * const cartaconducaos = await prisma.cartaconducao.findMany()
    * ```
    */
  get cartaconducao(): Prisma.cartaconducaoDelegate<ExtArgs>;

  /**
   * `prisma.categoriacarta`: Exposes CRUD operations for the **categoriacarta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categoriacartas
    * const categoriacartas = await prisma.categoriacarta.findMany()
    * ```
    */
  get categoriacarta(): Prisma.categoriacartaDelegate<ExtArgs>;

  /**
   * `prisma.contacto`: Exposes CRUD operations for the **contacto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contactos
    * const contactos = await prisma.contacto.findMany()
    * ```
    */
  get contacto(): Prisma.contactoDelegate<ExtArgs>;

  /**
   * `prisma.endereco`: Exposes CRUD operations for the **endereco** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enderecos
    * const enderecos = await prisma.endereco.findMany()
    * ```
    */
  get endereco(): Prisma.enderecoDelegate<ExtArgs>;

  /**
   * `prisma.ficheiro`: Exposes CRUD operations for the **ficheiro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ficheiros
    * const ficheiros = await prisma.ficheiro.findMany()
    * ```
    */
  get ficheiro(): Prisma.ficheiroDelegate<ExtArgs>;

  /**
   * `prisma.funcionario`: Exposes CRUD operations for the **funcionario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Funcionarios
    * const funcionarios = await prisma.funcionario.findMany()
    * ```
    */
  get funcionario(): Prisma.funcionarioDelegate<ExtArgs>;

  /**
   * `prisma.infracao`: Exposes CRUD operations for the **infracao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Infracaos
    * const infracaos = await prisma.infracao.findMany()
    * ```
    */
  get infracao(): Prisma.infracaoDelegate<ExtArgs>;

  /**
   * `prisma.livrete`: Exposes CRUD operations for the **livrete** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Livretes
    * const livretes = await prisma.livrete.findMany()
    * ```
    */
  get livrete(): Prisma.livreteDelegate<ExtArgs>;

  /**
   * `prisma.marca`: Exposes CRUD operations for the **marca** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Marcas
    * const marcas = await prisma.marca.findMany()
    * ```
    */
  get marca(): Prisma.marcaDelegate<ExtArgs>;

  /**
   * `prisma.multa`: Exposes CRUD operations for the **multa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Multas
    * const multas = await prisma.multa.findMany()
    * ```
    */
  get multa(): Prisma.multaDelegate<ExtArgs>;

  /**
   * `prisma.municipio`: Exposes CRUD operations for the **municipio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Municipios
    * const municipios = await prisma.municipio.findMany()
    * ```
    */
  get municipio(): Prisma.municipioDelegate<ExtArgs>;

  /**
   * `prisma.pagamentomulta`: Exposes CRUD operations for the **pagamentomulta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagamentomultas
    * const pagamentomultas = await prisma.pagamentomulta.findMany()
    * ```
    */
  get pagamentomulta(): Prisma.pagamentomultaDelegate<ExtArgs>;

  /**
   * `prisma.pais`: Exposes CRUD operations for the **pais** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pais
    * const pais = await prisma.pais.findMany()
    * ```
    */
  get pais(): Prisma.paisDelegate<ExtArgs>;

  /**
   * `prisma.pessoa`: Exposes CRUD operations for the **pessoa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pessoas
    * const pessoas = await prisma.pessoa.findMany()
    * ```
    */
  get pessoa(): Prisma.pessoaDelegate<ExtArgs>;

  /**
   * `prisma.provincia`: Exposes CRUD operations for the **provincia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provincias
    * const provincias = await prisma.provincia.findMany()
    * ```
    */
  get provincia(): Prisma.provinciaDelegate<ExtArgs>;

  /**
   * `prisma.serivicoviatura`: Exposes CRUD operations for the **serivicoviatura** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Serivicoviaturas
    * const serivicoviaturas = await prisma.serivicoviatura.findMany()
    * ```
    */
  get serivicoviatura(): Prisma.serivicoviaturaDelegate<ExtArgs>;

  /**
   * `prisma.tipoinfracao`: Exposes CRUD operations for the **tipoinfracao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tipoinfracaos
    * const tipoinfracaos = await prisma.tipoinfracao.findMany()
    * ```
    */
  get tipoinfracao(): Prisma.tipoinfracaoDelegate<ExtArgs>;

  /**
   * `prisma.tiporoubo`: Exposes CRUD operations for the **tiporoubo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tiporoubos
    * const tiporoubos = await prisma.tiporoubo.findMany()
    * ```
    */
  get tiporoubo(): Prisma.tiporouboDelegate<ExtArgs>;

  /**
   * `prisma.titulopropriedade`: Exposes CRUD operations for the **titulopropriedade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Titulopropriedades
    * const titulopropriedades = await prisma.titulopropriedade.findMany()
    * ```
    */
  get titulopropriedade(): Prisma.titulopropriedadeDelegate<ExtArgs>;

  /**
   * `prisma.viatura`: Exposes CRUD operations for the **viatura** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Viaturas
    * const viaturas = await prisma.viatura.findMany()
    * ```
    */
  get viatura(): Prisma.viaturaDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.16.2
   * Query Engine version: 34ace0eb2704183d2c05b60b52fba5c43c13f303
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    alertaroubo: 'alertaroubo',
    automobilista: 'automobilista',
    bi: 'bi',
    cartaconducao: 'cartaconducao',
    categoriacarta: 'categoriacarta',
    contacto: 'contacto',
    endereco: 'endereco',
    ficheiro: 'ficheiro',
    funcionario: 'funcionario',
    infracao: 'infracao',
    livrete: 'livrete',
    marca: 'marca',
    multa: 'multa',
    municipio: 'municipio',
    pagamentomulta: 'pagamentomulta',
    pais: 'pais',
    pessoa: 'pessoa',
    provincia: 'provincia',
    serivicoviatura: 'serivicoviatura',
    tipoinfracao: 'tipoinfracao',
    tiporoubo: 'tiporoubo',
    titulopropriedade: 'titulopropriedade',
    viatura: 'viatura'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "alertaroubo" | "automobilista" | "bi" | "cartaconducao" | "categoriacarta" | "contacto" | "endereco" | "ficheiro" | "funcionario" | "infracao" | "livrete" | "marca" | "multa" | "municipio" | "pagamentomulta" | "pais" | "pessoa" | "provincia" | "serivicoviatura" | "tipoinfracao" | "tiporoubo" | "titulopropriedade" | "viatura"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      alertaroubo: {
        payload: Prisma.$alertarouboPayload<ExtArgs>
        fields: Prisma.alertarouboFieldRefs
        operations: {
          findUnique: {
            args: Prisma.alertarouboFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertarouboPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.alertarouboFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertarouboPayload>
          }
          findFirst: {
            args: Prisma.alertarouboFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertarouboPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.alertarouboFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertarouboPayload>
          }
          findMany: {
            args: Prisma.alertarouboFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertarouboPayload>[]
          }
          create: {
            args: Prisma.alertarouboCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertarouboPayload>
          }
          createMany: {
            args: Prisma.alertarouboCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.alertarouboDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertarouboPayload>
          }
          update: {
            args: Prisma.alertarouboUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertarouboPayload>
          }
          deleteMany: {
            args: Prisma.alertarouboDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.alertarouboUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.alertarouboUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertarouboPayload>
          }
          aggregate: {
            args: Prisma.AlertarouboAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlertaroubo>
          }
          groupBy: {
            args: Prisma.alertarouboGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertarouboGroupByOutputType>[]
          }
          count: {
            args: Prisma.alertarouboCountArgs<ExtArgs>
            result: $Utils.Optional<AlertarouboCountAggregateOutputType> | number
          }
        }
      }
      automobilista: {
        payload: Prisma.$automobilistaPayload<ExtArgs>
        fields: Prisma.automobilistaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.automobilistaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$automobilistaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.automobilistaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$automobilistaPayload>
          }
          findFirst: {
            args: Prisma.automobilistaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$automobilistaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.automobilistaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$automobilistaPayload>
          }
          findMany: {
            args: Prisma.automobilistaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$automobilistaPayload>[]
          }
          create: {
            args: Prisma.automobilistaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$automobilistaPayload>
          }
          createMany: {
            args: Prisma.automobilistaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.automobilistaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$automobilistaPayload>
          }
          update: {
            args: Prisma.automobilistaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$automobilistaPayload>
          }
          deleteMany: {
            args: Prisma.automobilistaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.automobilistaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.automobilistaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$automobilistaPayload>
          }
          aggregate: {
            args: Prisma.AutomobilistaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomobilista>
          }
          groupBy: {
            args: Prisma.automobilistaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomobilistaGroupByOutputType>[]
          }
          count: {
            args: Prisma.automobilistaCountArgs<ExtArgs>
            result: $Utils.Optional<AutomobilistaCountAggregateOutputType> | number
          }
        }
      }
      bi: {
        payload: Prisma.$biPayload<ExtArgs>
        fields: Prisma.biFieldRefs
        operations: {
          findUnique: {
            args: Prisma.biFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$biPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.biFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$biPayload>
          }
          findFirst: {
            args: Prisma.biFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$biPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.biFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$biPayload>
          }
          findMany: {
            args: Prisma.biFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$biPayload>[]
          }
          create: {
            args: Prisma.biCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$biPayload>
          }
          createMany: {
            args: Prisma.biCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.biDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$biPayload>
          }
          update: {
            args: Prisma.biUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$biPayload>
          }
          deleteMany: {
            args: Prisma.biDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.biUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.biUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$biPayload>
          }
          aggregate: {
            args: Prisma.BiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBi>
          }
          groupBy: {
            args: Prisma.biGroupByArgs<ExtArgs>
            result: $Utils.Optional<BiGroupByOutputType>[]
          }
          count: {
            args: Prisma.biCountArgs<ExtArgs>
            result: $Utils.Optional<BiCountAggregateOutputType> | number
          }
        }
      }
      cartaconducao: {
        payload: Prisma.$cartaconducaoPayload<ExtArgs>
        fields: Prisma.cartaconducaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cartaconducaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartaconducaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cartaconducaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartaconducaoPayload>
          }
          findFirst: {
            args: Prisma.cartaconducaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartaconducaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cartaconducaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartaconducaoPayload>
          }
          findMany: {
            args: Prisma.cartaconducaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartaconducaoPayload>[]
          }
          create: {
            args: Prisma.cartaconducaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartaconducaoPayload>
          }
          createMany: {
            args: Prisma.cartaconducaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cartaconducaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartaconducaoPayload>
          }
          update: {
            args: Prisma.cartaconducaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartaconducaoPayload>
          }
          deleteMany: {
            args: Prisma.cartaconducaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cartaconducaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cartaconducaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cartaconducaoPayload>
          }
          aggregate: {
            args: Prisma.CartaconducaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCartaconducao>
          }
          groupBy: {
            args: Prisma.cartaconducaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartaconducaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.cartaconducaoCountArgs<ExtArgs>
            result: $Utils.Optional<CartaconducaoCountAggregateOutputType> | number
          }
        }
      }
      categoriacarta: {
        payload: Prisma.$categoriacartaPayload<ExtArgs>
        fields: Prisma.categoriacartaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriacartaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriacartaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriacartaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriacartaPayload>
          }
          findFirst: {
            args: Prisma.categoriacartaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriacartaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriacartaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriacartaPayload>
          }
          findMany: {
            args: Prisma.categoriacartaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriacartaPayload>[]
          }
          create: {
            args: Prisma.categoriacartaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriacartaPayload>
          }
          createMany: {
            args: Prisma.categoriacartaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.categoriacartaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriacartaPayload>
          }
          update: {
            args: Prisma.categoriacartaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriacartaPayload>
          }
          deleteMany: {
            args: Prisma.categoriacartaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoriacartaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.categoriacartaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriacartaPayload>
          }
          aggregate: {
            args: Prisma.CategoriacartaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoriacarta>
          }
          groupBy: {
            args: Prisma.categoriacartaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriacartaGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoriacartaCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriacartaCountAggregateOutputType> | number
          }
        }
      }
      contacto: {
        payload: Prisma.$contactoPayload<ExtArgs>
        fields: Prisma.contactoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contactoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contactoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactoPayload>
          }
          findFirst: {
            args: Prisma.contactoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contactoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactoPayload>
          }
          findMany: {
            args: Prisma.contactoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactoPayload>[]
          }
          create: {
            args: Prisma.contactoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactoPayload>
          }
          createMany: {
            args: Prisma.contactoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.contactoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactoPayload>
          }
          update: {
            args: Prisma.contactoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactoPayload>
          }
          deleteMany: {
            args: Prisma.contactoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.contactoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.contactoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactoPayload>
          }
          aggregate: {
            args: Prisma.ContactoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContacto>
          }
          groupBy: {
            args: Prisma.contactoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactoGroupByOutputType>[]
          }
          count: {
            args: Prisma.contactoCountArgs<ExtArgs>
            result: $Utils.Optional<ContactoCountAggregateOutputType> | number
          }
        }
      }
      endereco: {
        payload: Prisma.$enderecoPayload<ExtArgs>
        fields: Prisma.enderecoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.enderecoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.enderecoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload>
          }
          findFirst: {
            args: Prisma.enderecoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.enderecoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload>
          }
          findMany: {
            args: Prisma.enderecoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload>[]
          }
          create: {
            args: Prisma.enderecoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload>
          }
          createMany: {
            args: Prisma.enderecoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.enderecoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload>
          }
          update: {
            args: Prisma.enderecoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload>
          }
          deleteMany: {
            args: Prisma.enderecoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.enderecoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.enderecoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload>
          }
          aggregate: {
            args: Prisma.EnderecoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEndereco>
          }
          groupBy: {
            args: Prisma.enderecoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnderecoGroupByOutputType>[]
          }
          count: {
            args: Prisma.enderecoCountArgs<ExtArgs>
            result: $Utils.Optional<EnderecoCountAggregateOutputType> | number
          }
        }
      }
      ficheiro: {
        payload: Prisma.$ficheiroPayload<ExtArgs>
        fields: Prisma.ficheiroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ficheiroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ficheiroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ficheiroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ficheiroPayload>
          }
          findFirst: {
            args: Prisma.ficheiroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ficheiroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ficheiroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ficheiroPayload>
          }
          findMany: {
            args: Prisma.ficheiroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ficheiroPayload>[]
          }
          create: {
            args: Prisma.ficheiroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ficheiroPayload>
          }
          createMany: {
            args: Prisma.ficheiroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ficheiroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ficheiroPayload>
          }
          update: {
            args: Prisma.ficheiroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ficheiroPayload>
          }
          deleteMany: {
            args: Prisma.ficheiroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ficheiroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ficheiroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ficheiroPayload>
          }
          aggregate: {
            args: Prisma.FicheiroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFicheiro>
          }
          groupBy: {
            args: Prisma.ficheiroGroupByArgs<ExtArgs>
            result: $Utils.Optional<FicheiroGroupByOutputType>[]
          }
          count: {
            args: Prisma.ficheiroCountArgs<ExtArgs>
            result: $Utils.Optional<FicheiroCountAggregateOutputType> | number
          }
        }
      }
      funcionario: {
        payload: Prisma.$funcionarioPayload<ExtArgs>
        fields: Prisma.funcionarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.funcionarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funcionarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.funcionarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funcionarioPayload>
          }
          findFirst: {
            args: Prisma.funcionarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funcionarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.funcionarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funcionarioPayload>
          }
          findMany: {
            args: Prisma.funcionarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funcionarioPayload>[]
          }
          create: {
            args: Prisma.funcionarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funcionarioPayload>
          }
          createMany: {
            args: Prisma.funcionarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.funcionarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funcionarioPayload>
          }
          update: {
            args: Prisma.funcionarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funcionarioPayload>
          }
          deleteMany: {
            args: Prisma.funcionarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.funcionarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.funcionarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$funcionarioPayload>
          }
          aggregate: {
            args: Prisma.FuncionarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFuncionario>
          }
          groupBy: {
            args: Prisma.funcionarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<FuncionarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.funcionarioCountArgs<ExtArgs>
            result: $Utils.Optional<FuncionarioCountAggregateOutputType> | number
          }
        }
      }
      infracao: {
        payload: Prisma.$infracaoPayload<ExtArgs>
        fields: Prisma.infracaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.infracaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$infracaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.infracaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$infracaoPayload>
          }
          findFirst: {
            args: Prisma.infracaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$infracaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.infracaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$infracaoPayload>
          }
          findMany: {
            args: Prisma.infracaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$infracaoPayload>[]
          }
          create: {
            args: Prisma.infracaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$infracaoPayload>
          }
          createMany: {
            args: Prisma.infracaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.infracaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$infracaoPayload>
          }
          update: {
            args: Prisma.infracaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$infracaoPayload>
          }
          deleteMany: {
            args: Prisma.infracaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.infracaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.infracaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$infracaoPayload>
          }
          aggregate: {
            args: Prisma.InfracaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInfracao>
          }
          groupBy: {
            args: Prisma.infracaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<InfracaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.infracaoCountArgs<ExtArgs>
            result: $Utils.Optional<InfracaoCountAggregateOutputType> | number
          }
        }
      }
      livrete: {
        payload: Prisma.$livretePayload<ExtArgs>
        fields: Prisma.livreteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.livreteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$livretePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.livreteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$livretePayload>
          }
          findFirst: {
            args: Prisma.livreteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$livretePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.livreteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$livretePayload>
          }
          findMany: {
            args: Prisma.livreteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$livretePayload>[]
          }
          create: {
            args: Prisma.livreteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$livretePayload>
          }
          createMany: {
            args: Prisma.livreteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.livreteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$livretePayload>
          }
          update: {
            args: Prisma.livreteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$livretePayload>
          }
          deleteMany: {
            args: Prisma.livreteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.livreteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.livreteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$livretePayload>
          }
          aggregate: {
            args: Prisma.LivreteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLivrete>
          }
          groupBy: {
            args: Prisma.livreteGroupByArgs<ExtArgs>
            result: $Utils.Optional<LivreteGroupByOutputType>[]
          }
          count: {
            args: Prisma.livreteCountArgs<ExtArgs>
            result: $Utils.Optional<LivreteCountAggregateOutputType> | number
          }
        }
      }
      marca: {
        payload: Prisma.$marcaPayload<ExtArgs>
        fields: Prisma.marcaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.marcaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marcaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.marcaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marcaPayload>
          }
          findFirst: {
            args: Prisma.marcaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marcaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.marcaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marcaPayload>
          }
          findMany: {
            args: Prisma.marcaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marcaPayload>[]
          }
          create: {
            args: Prisma.marcaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marcaPayload>
          }
          createMany: {
            args: Prisma.marcaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.marcaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marcaPayload>
          }
          update: {
            args: Prisma.marcaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marcaPayload>
          }
          deleteMany: {
            args: Prisma.marcaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.marcaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.marcaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marcaPayload>
          }
          aggregate: {
            args: Prisma.MarcaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarca>
          }
          groupBy: {
            args: Prisma.marcaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarcaGroupByOutputType>[]
          }
          count: {
            args: Prisma.marcaCountArgs<ExtArgs>
            result: $Utils.Optional<MarcaCountAggregateOutputType> | number
          }
        }
      }
      multa: {
        payload: Prisma.$multaPayload<ExtArgs>
        fields: Prisma.multaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.multaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.multaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multaPayload>
          }
          findFirst: {
            args: Prisma.multaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.multaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multaPayload>
          }
          findMany: {
            args: Prisma.multaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multaPayload>[]
          }
          create: {
            args: Prisma.multaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multaPayload>
          }
          createMany: {
            args: Prisma.multaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.multaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multaPayload>
          }
          update: {
            args: Prisma.multaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multaPayload>
          }
          deleteMany: {
            args: Prisma.multaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.multaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.multaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$multaPayload>
          }
          aggregate: {
            args: Prisma.MultaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMulta>
          }
          groupBy: {
            args: Prisma.multaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MultaGroupByOutputType>[]
          }
          count: {
            args: Prisma.multaCountArgs<ExtArgs>
            result: $Utils.Optional<MultaCountAggregateOutputType> | number
          }
        }
      }
      municipio: {
        payload: Prisma.$municipioPayload<ExtArgs>
        fields: Prisma.municipioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.municipioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.municipioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipioPayload>
          }
          findFirst: {
            args: Prisma.municipioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.municipioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipioPayload>
          }
          findMany: {
            args: Prisma.municipioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipioPayload>[]
          }
          create: {
            args: Prisma.municipioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipioPayload>
          }
          createMany: {
            args: Prisma.municipioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.municipioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipioPayload>
          }
          update: {
            args: Prisma.municipioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipioPayload>
          }
          deleteMany: {
            args: Prisma.municipioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.municipioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.municipioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$municipioPayload>
          }
          aggregate: {
            args: Prisma.MunicipioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMunicipio>
          }
          groupBy: {
            args: Prisma.municipioGroupByArgs<ExtArgs>
            result: $Utils.Optional<MunicipioGroupByOutputType>[]
          }
          count: {
            args: Prisma.municipioCountArgs<ExtArgs>
            result: $Utils.Optional<MunicipioCountAggregateOutputType> | number
          }
        }
      }
      pagamentomulta: {
        payload: Prisma.$pagamentomultaPayload<ExtArgs>
        fields: Prisma.pagamentomultaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pagamentomultaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentomultaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pagamentomultaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentomultaPayload>
          }
          findFirst: {
            args: Prisma.pagamentomultaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentomultaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pagamentomultaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentomultaPayload>
          }
          findMany: {
            args: Prisma.pagamentomultaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentomultaPayload>[]
          }
          create: {
            args: Prisma.pagamentomultaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentomultaPayload>
          }
          createMany: {
            args: Prisma.pagamentomultaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pagamentomultaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentomultaPayload>
          }
          update: {
            args: Prisma.pagamentomultaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentomultaPayload>
          }
          deleteMany: {
            args: Prisma.pagamentomultaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pagamentomultaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pagamentomultaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pagamentomultaPayload>
          }
          aggregate: {
            args: Prisma.PagamentomultaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePagamentomulta>
          }
          groupBy: {
            args: Prisma.pagamentomultaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagamentomultaGroupByOutputType>[]
          }
          count: {
            args: Prisma.pagamentomultaCountArgs<ExtArgs>
            result: $Utils.Optional<PagamentomultaCountAggregateOutputType> | number
          }
        }
      }
      pais: {
        payload: Prisma.$paisPayload<ExtArgs>
        fields: Prisma.paisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          findFirst: {
            args: Prisma.paisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          findMany: {
            args: Prisma.paisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>[]
          }
          create: {
            args: Prisma.paisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          createMany: {
            args: Prisma.paisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.paisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          update: {
            args: Prisma.paisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          deleteMany: {
            args: Prisma.paisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.paisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          aggregate: {
            args: Prisma.PaisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePais>
          }
          groupBy: {
            args: Prisma.paisGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaisGroupByOutputType>[]
          }
          count: {
            args: Prisma.paisCountArgs<ExtArgs>
            result: $Utils.Optional<PaisCountAggregateOutputType> | number
          }
        }
      }
      pessoa: {
        payload: Prisma.$pessoaPayload<ExtArgs>
        fields: Prisma.pessoaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pessoaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pessoaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          findFirst: {
            args: Prisma.pessoaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pessoaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          findMany: {
            args: Prisma.pessoaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>[]
          }
          create: {
            args: Prisma.pessoaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          createMany: {
            args: Prisma.pessoaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pessoaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          update: {
            args: Prisma.pessoaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          deleteMany: {
            args: Prisma.pessoaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pessoaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pessoaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          aggregate: {
            args: Prisma.PessoaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePessoa>
          }
          groupBy: {
            args: Prisma.pessoaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PessoaGroupByOutputType>[]
          }
          count: {
            args: Prisma.pessoaCountArgs<ExtArgs>
            result: $Utils.Optional<PessoaCountAggregateOutputType> | number
          }
        }
      }
      provincia: {
        payload: Prisma.$provinciaPayload<ExtArgs>
        fields: Prisma.provinciaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.provinciaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provinciaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.provinciaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provinciaPayload>
          }
          findFirst: {
            args: Prisma.provinciaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provinciaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.provinciaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provinciaPayload>
          }
          findMany: {
            args: Prisma.provinciaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provinciaPayload>[]
          }
          create: {
            args: Prisma.provinciaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provinciaPayload>
          }
          createMany: {
            args: Prisma.provinciaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.provinciaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provinciaPayload>
          }
          update: {
            args: Prisma.provinciaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provinciaPayload>
          }
          deleteMany: {
            args: Prisma.provinciaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.provinciaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.provinciaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provinciaPayload>
          }
          aggregate: {
            args: Prisma.ProvinciaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvincia>
          }
          groupBy: {
            args: Prisma.provinciaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProvinciaGroupByOutputType>[]
          }
          count: {
            args: Prisma.provinciaCountArgs<ExtArgs>
            result: $Utils.Optional<ProvinciaCountAggregateOutputType> | number
          }
        }
      }
      serivicoviatura: {
        payload: Prisma.$serivicoviaturaPayload<ExtArgs>
        fields: Prisma.serivicoviaturaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.serivicoviaturaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serivicoviaturaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serivicoviaturaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serivicoviaturaPayload>
          }
          findFirst: {
            args: Prisma.serivicoviaturaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serivicoviaturaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serivicoviaturaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serivicoviaturaPayload>
          }
          findMany: {
            args: Prisma.serivicoviaturaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serivicoviaturaPayload>[]
          }
          create: {
            args: Prisma.serivicoviaturaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serivicoviaturaPayload>
          }
          createMany: {
            args: Prisma.serivicoviaturaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.serivicoviaturaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serivicoviaturaPayload>
          }
          update: {
            args: Prisma.serivicoviaturaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serivicoviaturaPayload>
          }
          deleteMany: {
            args: Prisma.serivicoviaturaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.serivicoviaturaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.serivicoviaturaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serivicoviaturaPayload>
          }
          aggregate: {
            args: Prisma.SerivicoviaturaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSerivicoviatura>
          }
          groupBy: {
            args: Prisma.serivicoviaturaGroupByArgs<ExtArgs>
            result: $Utils.Optional<SerivicoviaturaGroupByOutputType>[]
          }
          count: {
            args: Prisma.serivicoviaturaCountArgs<ExtArgs>
            result: $Utils.Optional<SerivicoviaturaCountAggregateOutputType> | number
          }
        }
      }
      tipoinfracao: {
        payload: Prisma.$tipoinfracaoPayload<ExtArgs>
        fields: Prisma.tipoinfracaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tipoinfracaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoinfracaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tipoinfracaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoinfracaoPayload>
          }
          findFirst: {
            args: Prisma.tipoinfracaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoinfracaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tipoinfracaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoinfracaoPayload>
          }
          findMany: {
            args: Prisma.tipoinfracaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoinfracaoPayload>[]
          }
          create: {
            args: Prisma.tipoinfracaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoinfracaoPayload>
          }
          createMany: {
            args: Prisma.tipoinfracaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tipoinfracaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoinfracaoPayload>
          }
          update: {
            args: Prisma.tipoinfracaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoinfracaoPayload>
          }
          deleteMany: {
            args: Prisma.tipoinfracaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tipoinfracaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tipoinfracaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoinfracaoPayload>
          }
          aggregate: {
            args: Prisma.TipoinfracaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoinfracao>
          }
          groupBy: {
            args: Prisma.tipoinfracaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoinfracaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.tipoinfracaoCountArgs<ExtArgs>
            result: $Utils.Optional<TipoinfracaoCountAggregateOutputType> | number
          }
        }
      }
      tiporoubo: {
        payload: Prisma.$tiporouboPayload<ExtArgs>
        fields: Prisma.tiporouboFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tiporouboFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiporouboPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tiporouboFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiporouboPayload>
          }
          findFirst: {
            args: Prisma.tiporouboFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiporouboPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tiporouboFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiporouboPayload>
          }
          findMany: {
            args: Prisma.tiporouboFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiporouboPayload>[]
          }
          create: {
            args: Prisma.tiporouboCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiporouboPayload>
          }
          createMany: {
            args: Prisma.tiporouboCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tiporouboDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiporouboPayload>
          }
          update: {
            args: Prisma.tiporouboUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiporouboPayload>
          }
          deleteMany: {
            args: Prisma.tiporouboDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tiporouboUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tiporouboUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tiporouboPayload>
          }
          aggregate: {
            args: Prisma.TiporouboAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTiporoubo>
          }
          groupBy: {
            args: Prisma.tiporouboGroupByArgs<ExtArgs>
            result: $Utils.Optional<TiporouboGroupByOutputType>[]
          }
          count: {
            args: Prisma.tiporouboCountArgs<ExtArgs>
            result: $Utils.Optional<TiporouboCountAggregateOutputType> | number
          }
        }
      }
      titulopropriedade: {
        payload: Prisma.$titulopropriedadePayload<ExtArgs>
        fields: Prisma.titulopropriedadeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.titulopropriedadeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$titulopropriedadePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.titulopropriedadeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$titulopropriedadePayload>
          }
          findFirst: {
            args: Prisma.titulopropriedadeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$titulopropriedadePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.titulopropriedadeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$titulopropriedadePayload>
          }
          findMany: {
            args: Prisma.titulopropriedadeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$titulopropriedadePayload>[]
          }
          create: {
            args: Prisma.titulopropriedadeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$titulopropriedadePayload>
          }
          createMany: {
            args: Prisma.titulopropriedadeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.titulopropriedadeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$titulopropriedadePayload>
          }
          update: {
            args: Prisma.titulopropriedadeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$titulopropriedadePayload>
          }
          deleteMany: {
            args: Prisma.titulopropriedadeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.titulopropriedadeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.titulopropriedadeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$titulopropriedadePayload>
          }
          aggregate: {
            args: Prisma.TitulopropriedadeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTitulopropriedade>
          }
          groupBy: {
            args: Prisma.titulopropriedadeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TitulopropriedadeGroupByOutputType>[]
          }
          count: {
            args: Prisma.titulopropriedadeCountArgs<ExtArgs>
            result: $Utils.Optional<TitulopropriedadeCountAggregateOutputType> | number
          }
        }
      }
      viatura: {
        payload: Prisma.$viaturaPayload<ExtArgs>
        fields: Prisma.viaturaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.viaturaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viaturaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.viaturaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viaturaPayload>
          }
          findFirst: {
            args: Prisma.viaturaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viaturaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.viaturaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viaturaPayload>
          }
          findMany: {
            args: Prisma.viaturaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viaturaPayload>[]
          }
          create: {
            args: Prisma.viaturaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viaturaPayload>
          }
          createMany: {
            args: Prisma.viaturaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.viaturaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viaturaPayload>
          }
          update: {
            args: Prisma.viaturaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viaturaPayload>
          }
          deleteMany: {
            args: Prisma.viaturaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.viaturaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.viaturaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$viaturaPayload>
          }
          aggregate: {
            args: Prisma.ViaturaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViatura>
          }
          groupBy: {
            args: Prisma.viaturaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViaturaGroupByOutputType>[]
          }
          count: {
            args: Prisma.viaturaCountArgs<ExtArgs>
            result: $Utils.Optional<ViaturaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AutomobilistaCountOutputType
   */

  export type AutomobilistaCountOutputType = {
    alertaroubo: number
    multa: number
  }

  export type AutomobilistaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alertaroubo?: boolean | AutomobilistaCountOutputTypeCountAlertarouboArgs
    multa?: boolean | AutomobilistaCountOutputTypeCountMultaArgs
  }

  // Custom InputTypes
  /**
   * AutomobilistaCountOutputType without action
   */
  export type AutomobilistaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomobilistaCountOutputType
     */
    select?: AutomobilistaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AutomobilistaCountOutputType without action
   */
  export type AutomobilistaCountOutputTypeCountAlertarouboArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alertarouboWhereInput
  }

  /**
   * AutomobilistaCountOutputType without action
   */
  export type AutomobilistaCountOutputTypeCountMultaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: multaWhereInput
  }


  /**
   * Count Type BiCountOutputType
   */

  export type BiCountOutputType = {
    pessoa: number
  }

  export type BiCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | BiCountOutputTypeCountPessoaArgs
  }

  // Custom InputTypes
  /**
   * BiCountOutputType without action
   */
  export type BiCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiCountOutputType
     */
    select?: BiCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BiCountOutputType without action
   */
  export type BiCountOutputTypeCountPessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaWhereInput
  }


  /**
   * Count Type CartaconducaoCountOutputType
   */

  export type CartaconducaoCountOutputType = {
    automobilista: number
  }

  export type CartaconducaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automobilista?: boolean | CartaconducaoCountOutputTypeCountAutomobilistaArgs
  }

  // Custom InputTypes
  /**
   * CartaconducaoCountOutputType without action
   */
  export type CartaconducaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartaconducaoCountOutputType
     */
    select?: CartaconducaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CartaconducaoCountOutputType without action
   */
  export type CartaconducaoCountOutputTypeCountAutomobilistaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: automobilistaWhereInput
  }


  /**
   * Count Type CategoriacartaCountOutputType
   */

  export type CategoriacartaCountOutputType = {
    cartaconducao: number
  }

  export type CategoriacartaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cartaconducao?: boolean | CategoriacartaCountOutputTypeCountCartaconducaoArgs
  }

  // Custom InputTypes
  /**
   * CategoriacartaCountOutputType without action
   */
  export type CategoriacartaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriacartaCountOutputType
     */
    select?: CategoriacartaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriacartaCountOutputType without action
   */
  export type CategoriacartaCountOutputTypeCountCartaconducaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cartaconducaoWhereInput
  }


  /**
   * Count Type ContactoCountOutputType
   */

  export type ContactoCountOutputType = {
    pessoa: number
  }

  export type ContactoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | ContactoCountOutputTypeCountPessoaArgs
  }

  // Custom InputTypes
  /**
   * ContactoCountOutputType without action
   */
  export type ContactoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactoCountOutputType
     */
    select?: ContactoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactoCountOutputType without action
   */
  export type ContactoCountOutputTypeCountPessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaWhereInput
  }


  /**
   * Count Type EnderecoCountOutputType
   */

  export type EnderecoCountOutputType = {
    pessoa: number
  }

  export type EnderecoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | EnderecoCountOutputTypeCountPessoaArgs
  }

  // Custom InputTypes
  /**
   * EnderecoCountOutputType without action
   */
  export type EnderecoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoCountOutputType
     */
    select?: EnderecoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EnderecoCountOutputType without action
   */
  export type EnderecoCountOutputTypeCountPessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaWhereInput
  }


  /**
   * Count Type FicheiroCountOutputType
   */

  export type FicheiroCountOutputType = {
    bi: number
    cartaconducao: number
    funcionario: number
    pagamentomulta: number
    titulopropriedade: number
  }

  export type FicheiroCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bi?: boolean | FicheiroCountOutputTypeCountBiArgs
    cartaconducao?: boolean | FicheiroCountOutputTypeCountCartaconducaoArgs
    funcionario?: boolean | FicheiroCountOutputTypeCountFuncionarioArgs
    pagamentomulta?: boolean | FicheiroCountOutputTypeCountPagamentomultaArgs
    titulopropriedade?: boolean | FicheiroCountOutputTypeCountTitulopropriedadeArgs
  }

  // Custom InputTypes
  /**
   * FicheiroCountOutputType without action
   */
  export type FicheiroCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FicheiroCountOutputType
     */
    select?: FicheiroCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FicheiroCountOutputType without action
   */
  export type FicheiroCountOutputTypeCountBiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: biWhereInput
  }

  /**
   * FicheiroCountOutputType without action
   */
  export type FicheiroCountOutputTypeCountCartaconducaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cartaconducaoWhereInput
  }

  /**
   * FicheiroCountOutputType without action
   */
  export type FicheiroCountOutputTypeCountFuncionarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: funcionarioWhereInput
  }

  /**
   * FicheiroCountOutputType without action
   */
  export type FicheiroCountOutputTypeCountPagamentomultaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pagamentomultaWhereInput
  }

  /**
   * FicheiroCountOutputType without action
   */
  export type FicheiroCountOutputTypeCountTitulopropriedadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: titulopropriedadeWhereInput
  }


  /**
   * Count Type InfracaoCountOutputType
   */

  export type InfracaoCountOutputType = {
    multa_multa_codInfracaoToinfracao: number
  }

  export type InfracaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    multa_multa_codInfracaoToinfracao?: boolean | InfracaoCountOutputTypeCountMulta_multa_codInfracaoToinfracaoArgs
  }

  // Custom InputTypes
  /**
   * InfracaoCountOutputType without action
   */
  export type InfracaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfracaoCountOutputType
     */
    select?: InfracaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InfracaoCountOutputType without action
   */
  export type InfracaoCountOutputTypeCountMulta_multa_codInfracaoToinfracaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: multaWhereInput
  }


  /**
   * Count Type MarcaCountOutputType
   */

  export type MarcaCountOutputType = {
    livrete: number
  }

  export type MarcaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livrete?: boolean | MarcaCountOutputTypeCountLivreteArgs
  }

  // Custom InputTypes
  /**
   * MarcaCountOutputType without action
   */
  export type MarcaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarcaCountOutputType
     */
    select?: MarcaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MarcaCountOutputType without action
   */
  export type MarcaCountOutputTypeCountLivreteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: livreteWhereInput
  }


  /**
   * Count Type MultaCountOutputType
   */

  export type MultaCountOutputType = {
    infracao_infracao_codMultaTomulta: number
    pagamentomulta: number
  }

  export type MultaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    infracao_infracao_codMultaTomulta?: boolean | MultaCountOutputTypeCountInfracao_infracao_codMultaTomultaArgs
    pagamentomulta?: boolean | MultaCountOutputTypeCountPagamentomultaArgs
  }

  // Custom InputTypes
  /**
   * MultaCountOutputType without action
   */
  export type MultaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultaCountOutputType
     */
    select?: MultaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MultaCountOutputType without action
   */
  export type MultaCountOutputTypeCountInfracao_infracao_codMultaTomultaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: infracaoWhereInput
  }

  /**
   * MultaCountOutputType without action
   */
  export type MultaCountOutputTypeCountPagamentomultaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pagamentomultaWhereInput
  }


  /**
   * Count Type MunicipioCountOutputType
   */

  export type MunicipioCountOutputType = {
    endereco: number
  }

  export type MunicipioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | MunicipioCountOutputTypeCountEnderecoArgs
  }

  // Custom InputTypes
  /**
   * MunicipioCountOutputType without action
   */
  export type MunicipioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MunicipioCountOutputType
     */
    select?: MunicipioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MunicipioCountOutputType without action
   */
  export type MunicipioCountOutputTypeCountEnderecoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enderecoWhereInput
  }


  /**
   * Count Type PaisCountOutputType
   */

  export type PaisCountOutputType = {
    pessoa: number
  }

  export type PaisCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | PaisCountOutputTypeCountPessoaArgs
  }

  // Custom InputTypes
  /**
   * PaisCountOutputType without action
   */
  export type PaisCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaisCountOutputType
     */
    select?: PaisCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaisCountOutputType without action
   */
  export type PaisCountOutputTypeCountPessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaWhereInput
  }


  /**
   * Count Type PessoaCountOutputType
   */

  export type PessoaCountOutputType = {
    automobilista: number
    funcionario: number
    titulopropriedade: number
  }

  export type PessoaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automobilista?: boolean | PessoaCountOutputTypeCountAutomobilistaArgs
    funcionario?: boolean | PessoaCountOutputTypeCountFuncionarioArgs
    titulopropriedade?: boolean | PessoaCountOutputTypeCountTitulopropriedadeArgs
  }

  // Custom InputTypes
  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PessoaCountOutputType
     */
    select?: PessoaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountAutomobilistaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: automobilistaWhereInput
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountFuncionarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: funcionarioWhereInput
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountTitulopropriedadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: titulopropriedadeWhereInput
  }


  /**
   * Count Type ProvinciaCountOutputType
   */

  export type ProvinciaCountOutputType = {
    municipio: number
  }

  export type ProvinciaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipio?: boolean | ProvinciaCountOutputTypeCountMunicipioArgs
  }

  // Custom InputTypes
  /**
   * ProvinciaCountOutputType without action
   */
  export type ProvinciaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvinciaCountOutputType
     */
    select?: ProvinciaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProvinciaCountOutputType without action
   */
  export type ProvinciaCountOutputTypeCountMunicipioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: municipioWhereInput
  }


  /**
   * Count Type SerivicoviaturaCountOutputType
   */

  export type SerivicoviaturaCountOutputType = {
    livrete: number
  }

  export type SerivicoviaturaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livrete?: boolean | SerivicoviaturaCountOutputTypeCountLivreteArgs
  }

  // Custom InputTypes
  /**
   * SerivicoviaturaCountOutputType without action
   */
  export type SerivicoviaturaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SerivicoviaturaCountOutputType
     */
    select?: SerivicoviaturaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SerivicoviaturaCountOutputType without action
   */
  export type SerivicoviaturaCountOutputTypeCountLivreteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: livreteWhereInput
  }


  /**
   * Count Type TipoinfracaoCountOutputType
   */

  export type TipoinfracaoCountOutputType = {
    infracao: number
  }

  export type TipoinfracaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    infracao?: boolean | TipoinfracaoCountOutputTypeCountInfracaoArgs
  }

  // Custom InputTypes
  /**
   * TipoinfracaoCountOutputType without action
   */
  export type TipoinfracaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoinfracaoCountOutputType
     */
    select?: TipoinfracaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoinfracaoCountOutputType without action
   */
  export type TipoinfracaoCountOutputTypeCountInfracaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: infracaoWhereInput
  }


  /**
   * Count Type TiporouboCountOutputType
   */

  export type TiporouboCountOutputType = {
    alertaroubo: number
  }

  export type TiporouboCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alertaroubo?: boolean | TiporouboCountOutputTypeCountAlertarouboArgs
  }

  // Custom InputTypes
  /**
   * TiporouboCountOutputType without action
   */
  export type TiporouboCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiporouboCountOutputType
     */
    select?: TiporouboCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TiporouboCountOutputType without action
   */
  export type TiporouboCountOutputTypeCountAlertarouboArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alertarouboWhereInput
  }


  /**
   * Count Type ViaturaCountOutputType
   */

  export type ViaturaCountOutputType = {
    alertaroubo: number
    livrete: number
    multa: number
    titulopropriedade: number
  }

  export type ViaturaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alertaroubo?: boolean | ViaturaCountOutputTypeCountAlertarouboArgs
    livrete?: boolean | ViaturaCountOutputTypeCountLivreteArgs
    multa?: boolean | ViaturaCountOutputTypeCountMultaArgs
    titulopropriedade?: boolean | ViaturaCountOutputTypeCountTitulopropriedadeArgs
  }

  // Custom InputTypes
  /**
   * ViaturaCountOutputType without action
   */
  export type ViaturaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViaturaCountOutputType
     */
    select?: ViaturaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ViaturaCountOutputType without action
   */
  export type ViaturaCountOutputTypeCountAlertarouboArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alertarouboWhereInput
  }

  /**
   * ViaturaCountOutputType without action
   */
  export type ViaturaCountOutputTypeCountLivreteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: livreteWhereInput
  }

  /**
   * ViaturaCountOutputType without action
   */
  export type ViaturaCountOutputTypeCountMultaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: multaWhereInput
  }

  /**
   * ViaturaCountOutputType without action
   */
  export type ViaturaCountOutputTypeCountTitulopropriedadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: titulopropriedadeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model alertaroubo
   */

  export type AggregateAlertaroubo = {
    _count: AlertarouboCountAggregateOutputType | null
    _avg: AlertarouboAvgAggregateOutputType | null
    _sum: AlertarouboSumAggregateOutputType | null
    _min: AlertarouboMinAggregateOutputType | null
    _max: AlertarouboMaxAggregateOutputType | null
  }

  export type AlertarouboAvgAggregateOutputType = {
    codAlertaRoubo: number | null
    codAutomobilista: number | null
    codViatura: number | null
    codTipoRoubo: number | null
  }

  export type AlertarouboSumAggregateOutputType = {
    codAlertaRoubo: number | null
    codAutomobilista: number | null
    codViatura: number | null
    codTipoRoubo: number | null
  }

  export type AlertarouboMinAggregateOutputType = {
    codAlertaRoubo: number | null
    codAutomobilista: number | null
    codViatura: number | null
    dataRoubo: Date | null
    enderecoRoubo: string | null
    codTipoRoubo: number | null
    descRoubo: string | null
  }

  export type AlertarouboMaxAggregateOutputType = {
    codAlertaRoubo: number | null
    codAutomobilista: number | null
    codViatura: number | null
    dataRoubo: Date | null
    enderecoRoubo: string | null
    codTipoRoubo: number | null
    descRoubo: string | null
  }

  export type AlertarouboCountAggregateOutputType = {
    codAlertaRoubo: number
    codAutomobilista: number
    codViatura: number
    dataRoubo: number
    enderecoRoubo: number
    codTipoRoubo: number
    descRoubo: number
    _all: number
  }


  export type AlertarouboAvgAggregateInputType = {
    codAlertaRoubo?: true
    codAutomobilista?: true
    codViatura?: true
    codTipoRoubo?: true
  }

  export type AlertarouboSumAggregateInputType = {
    codAlertaRoubo?: true
    codAutomobilista?: true
    codViatura?: true
    codTipoRoubo?: true
  }

  export type AlertarouboMinAggregateInputType = {
    codAlertaRoubo?: true
    codAutomobilista?: true
    codViatura?: true
    dataRoubo?: true
    enderecoRoubo?: true
    codTipoRoubo?: true
    descRoubo?: true
  }

  export type AlertarouboMaxAggregateInputType = {
    codAlertaRoubo?: true
    codAutomobilista?: true
    codViatura?: true
    dataRoubo?: true
    enderecoRoubo?: true
    codTipoRoubo?: true
    descRoubo?: true
  }

  export type AlertarouboCountAggregateInputType = {
    codAlertaRoubo?: true
    codAutomobilista?: true
    codViatura?: true
    dataRoubo?: true
    enderecoRoubo?: true
    codTipoRoubo?: true
    descRoubo?: true
    _all?: true
  }

  export type AlertarouboAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alertaroubo to aggregate.
     */
    where?: alertarouboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alertaroubos to fetch.
     */
    orderBy?: alertarouboOrderByWithRelationInput | alertarouboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: alertarouboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alertaroubos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alertaroubos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned alertaroubos
    **/
    _count?: true | AlertarouboCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlertarouboAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlertarouboSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertarouboMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertarouboMaxAggregateInputType
  }

  export type GetAlertarouboAggregateType<T extends AlertarouboAggregateArgs> = {
        [P in keyof T & keyof AggregateAlertaroubo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlertaroubo[P]>
      : GetScalarType<T[P], AggregateAlertaroubo[P]>
  }




  export type alertarouboGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alertarouboWhereInput
    orderBy?: alertarouboOrderByWithAggregationInput | alertarouboOrderByWithAggregationInput[]
    by: AlertarouboScalarFieldEnum[] | AlertarouboScalarFieldEnum
    having?: alertarouboScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertarouboCountAggregateInputType | true
    _avg?: AlertarouboAvgAggregateInputType
    _sum?: AlertarouboSumAggregateInputType
    _min?: AlertarouboMinAggregateInputType
    _max?: AlertarouboMaxAggregateInputType
  }

  export type AlertarouboGroupByOutputType = {
    codAlertaRoubo: number
    codAutomobilista: number
    codViatura: number
    dataRoubo: Date
    enderecoRoubo: string
    codTipoRoubo: number
    descRoubo: string
    _count: AlertarouboCountAggregateOutputType | null
    _avg: AlertarouboAvgAggregateOutputType | null
    _sum: AlertarouboSumAggregateOutputType | null
    _min: AlertarouboMinAggregateOutputType | null
    _max: AlertarouboMaxAggregateOutputType | null
  }

  type GetAlertarouboGroupByPayload<T extends alertarouboGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertarouboGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertarouboGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertarouboGroupByOutputType[P]>
            : GetScalarType<T[P], AlertarouboGroupByOutputType[P]>
        }
      >
    >


  export type alertarouboSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codAlertaRoubo?: boolean
    codAutomobilista?: boolean
    codViatura?: boolean
    dataRoubo?: boolean
    enderecoRoubo?: boolean
    codTipoRoubo?: boolean
    descRoubo?: boolean
    automobilista?: boolean | automobilistaDefaultArgs<ExtArgs>
    tiporoubo?: boolean | tiporouboDefaultArgs<ExtArgs>
    viatura?: boolean | viaturaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alertaroubo"]>


  export type alertarouboSelectScalar = {
    codAlertaRoubo?: boolean
    codAutomobilista?: boolean
    codViatura?: boolean
    dataRoubo?: boolean
    enderecoRoubo?: boolean
    codTipoRoubo?: boolean
    descRoubo?: boolean
  }

  export type alertarouboInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automobilista?: boolean | automobilistaDefaultArgs<ExtArgs>
    tiporoubo?: boolean | tiporouboDefaultArgs<ExtArgs>
    viatura?: boolean | viaturaDefaultArgs<ExtArgs>
  }

  export type $alertarouboPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "alertaroubo"
    objects: {
      automobilista: Prisma.$automobilistaPayload<ExtArgs>
      tiporoubo: Prisma.$tiporouboPayload<ExtArgs>
      viatura: Prisma.$viaturaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      codAlertaRoubo: number
      codAutomobilista: number
      codViatura: number
      dataRoubo: Date
      enderecoRoubo: string
      codTipoRoubo: number
      descRoubo: string
    }, ExtArgs["result"]["alertaroubo"]>
    composites: {}
  }

  type alertarouboGetPayload<S extends boolean | null | undefined | alertarouboDefaultArgs> = $Result.GetResult<Prisma.$alertarouboPayload, S>

  type alertarouboCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<alertarouboFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertarouboCountAggregateInputType | true
    }

  export interface alertarouboDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['alertaroubo'], meta: { name: 'alertaroubo' } }
    /**
     * Find zero or one Alertaroubo that matches the filter.
     * @param {alertarouboFindUniqueArgs} args - Arguments to find a Alertaroubo
     * @example
     * // Get one Alertaroubo
     * const alertaroubo = await prisma.alertaroubo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends alertarouboFindUniqueArgs>(args: SelectSubset<T, alertarouboFindUniqueArgs<ExtArgs>>): Prisma__alertarouboClient<$Result.GetResult<Prisma.$alertarouboPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alertaroubo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {alertarouboFindUniqueOrThrowArgs} args - Arguments to find a Alertaroubo
     * @example
     * // Get one Alertaroubo
     * const alertaroubo = await prisma.alertaroubo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends alertarouboFindUniqueOrThrowArgs>(args: SelectSubset<T, alertarouboFindUniqueOrThrowArgs<ExtArgs>>): Prisma__alertarouboClient<$Result.GetResult<Prisma.$alertarouboPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alertaroubo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertarouboFindFirstArgs} args - Arguments to find a Alertaroubo
     * @example
     * // Get one Alertaroubo
     * const alertaroubo = await prisma.alertaroubo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends alertarouboFindFirstArgs>(args?: SelectSubset<T, alertarouboFindFirstArgs<ExtArgs>>): Prisma__alertarouboClient<$Result.GetResult<Prisma.$alertarouboPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alertaroubo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertarouboFindFirstOrThrowArgs} args - Arguments to find a Alertaroubo
     * @example
     * // Get one Alertaroubo
     * const alertaroubo = await prisma.alertaroubo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends alertarouboFindFirstOrThrowArgs>(args?: SelectSubset<T, alertarouboFindFirstOrThrowArgs<ExtArgs>>): Prisma__alertarouboClient<$Result.GetResult<Prisma.$alertarouboPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alertaroubos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertarouboFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alertaroubos
     * const alertaroubos = await prisma.alertaroubo.findMany()
     * 
     * // Get first 10 Alertaroubos
     * const alertaroubos = await prisma.alertaroubo.findMany({ take: 10 })
     * 
     * // Only select the `codAlertaRoubo`
     * const alertarouboWithCodAlertaRouboOnly = await prisma.alertaroubo.findMany({ select: { codAlertaRoubo: true } })
     * 
     */
    findMany<T extends alertarouboFindManyArgs>(args?: SelectSubset<T, alertarouboFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alertarouboPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alertaroubo.
     * @param {alertarouboCreateArgs} args - Arguments to create a Alertaroubo.
     * @example
     * // Create one Alertaroubo
     * const Alertaroubo = await prisma.alertaroubo.create({
     *   data: {
     *     // ... data to create a Alertaroubo
     *   }
     * })
     * 
     */
    create<T extends alertarouboCreateArgs>(args: SelectSubset<T, alertarouboCreateArgs<ExtArgs>>): Prisma__alertarouboClient<$Result.GetResult<Prisma.$alertarouboPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alertaroubos.
     * @param {alertarouboCreateManyArgs} args - Arguments to create many Alertaroubos.
     * @example
     * // Create many Alertaroubos
     * const alertaroubo = await prisma.alertaroubo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends alertarouboCreateManyArgs>(args?: SelectSubset<T, alertarouboCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alertaroubo.
     * @param {alertarouboDeleteArgs} args - Arguments to delete one Alertaroubo.
     * @example
     * // Delete one Alertaroubo
     * const Alertaroubo = await prisma.alertaroubo.delete({
     *   where: {
     *     // ... filter to delete one Alertaroubo
     *   }
     * })
     * 
     */
    delete<T extends alertarouboDeleteArgs>(args: SelectSubset<T, alertarouboDeleteArgs<ExtArgs>>): Prisma__alertarouboClient<$Result.GetResult<Prisma.$alertarouboPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alertaroubo.
     * @param {alertarouboUpdateArgs} args - Arguments to update one Alertaroubo.
     * @example
     * // Update one Alertaroubo
     * const alertaroubo = await prisma.alertaroubo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends alertarouboUpdateArgs>(args: SelectSubset<T, alertarouboUpdateArgs<ExtArgs>>): Prisma__alertarouboClient<$Result.GetResult<Prisma.$alertarouboPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alertaroubos.
     * @param {alertarouboDeleteManyArgs} args - Arguments to filter Alertaroubos to delete.
     * @example
     * // Delete a few Alertaroubos
     * const { count } = await prisma.alertaroubo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends alertarouboDeleteManyArgs>(args?: SelectSubset<T, alertarouboDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alertaroubos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertarouboUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alertaroubos
     * const alertaroubo = await prisma.alertaroubo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends alertarouboUpdateManyArgs>(args: SelectSubset<T, alertarouboUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alertaroubo.
     * @param {alertarouboUpsertArgs} args - Arguments to update or create a Alertaroubo.
     * @example
     * // Update or create a Alertaroubo
     * const alertaroubo = await prisma.alertaroubo.upsert({
     *   create: {
     *     // ... data to create a Alertaroubo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alertaroubo we want to update
     *   }
     * })
     */
    upsert<T extends alertarouboUpsertArgs>(args: SelectSubset<T, alertarouboUpsertArgs<ExtArgs>>): Prisma__alertarouboClient<$Result.GetResult<Prisma.$alertarouboPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alertaroubos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertarouboCountArgs} args - Arguments to filter Alertaroubos to count.
     * @example
     * // Count the number of Alertaroubos
     * const count = await prisma.alertaroubo.count({
     *   where: {
     *     // ... the filter for the Alertaroubos we want to count
     *   }
     * })
    **/
    count<T extends alertarouboCountArgs>(
      args?: Subset<T, alertarouboCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertarouboCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alertaroubo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertarouboAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertarouboAggregateArgs>(args: Subset<T, AlertarouboAggregateArgs>): Prisma.PrismaPromise<GetAlertarouboAggregateType<T>>

    /**
     * Group by Alertaroubo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertarouboGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends alertarouboGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: alertarouboGroupByArgs['orderBy'] }
        : { orderBy?: alertarouboGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, alertarouboGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertarouboGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the alertaroubo model
   */
  readonly fields: alertarouboFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for alertaroubo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__alertarouboClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    automobilista<T extends automobilistaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, automobilistaDefaultArgs<ExtArgs>>): Prisma__automobilistaClient<$Result.GetResult<Prisma.$automobilistaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tiporoubo<T extends tiporouboDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tiporouboDefaultArgs<ExtArgs>>): Prisma__tiporouboClient<$Result.GetResult<Prisma.$tiporouboPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    viatura<T extends viaturaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, viaturaDefaultArgs<ExtArgs>>): Prisma__viaturaClient<$Result.GetResult<Prisma.$viaturaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the alertaroubo model
   */ 
  interface alertarouboFieldRefs {
    readonly codAlertaRoubo: FieldRef<"alertaroubo", 'Int'>
    readonly codAutomobilista: FieldRef<"alertaroubo", 'Int'>
    readonly codViatura: FieldRef<"alertaroubo", 'Int'>
    readonly dataRoubo: FieldRef<"alertaroubo", 'DateTime'>
    readonly enderecoRoubo: FieldRef<"alertaroubo", 'String'>
    readonly codTipoRoubo: FieldRef<"alertaroubo", 'Int'>
    readonly descRoubo: FieldRef<"alertaroubo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * alertaroubo findUnique
   */
  export type alertarouboFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertaroubo
     */
    select?: alertarouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertarouboInclude<ExtArgs> | null
    /**
     * Filter, which alertaroubo to fetch.
     */
    where: alertarouboWhereUniqueInput
  }

  /**
   * alertaroubo findUniqueOrThrow
   */
  export type alertarouboFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertaroubo
     */
    select?: alertarouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertarouboInclude<ExtArgs> | null
    /**
     * Filter, which alertaroubo to fetch.
     */
    where: alertarouboWhereUniqueInput
  }

  /**
   * alertaroubo findFirst
   */
  export type alertarouboFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertaroubo
     */
    select?: alertarouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertarouboInclude<ExtArgs> | null
    /**
     * Filter, which alertaroubo to fetch.
     */
    where?: alertarouboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alertaroubos to fetch.
     */
    orderBy?: alertarouboOrderByWithRelationInput | alertarouboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alertaroubos.
     */
    cursor?: alertarouboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alertaroubos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alertaroubos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alertaroubos.
     */
    distinct?: AlertarouboScalarFieldEnum | AlertarouboScalarFieldEnum[]
  }

  /**
   * alertaroubo findFirstOrThrow
   */
  export type alertarouboFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertaroubo
     */
    select?: alertarouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertarouboInclude<ExtArgs> | null
    /**
     * Filter, which alertaroubo to fetch.
     */
    where?: alertarouboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alertaroubos to fetch.
     */
    orderBy?: alertarouboOrderByWithRelationInput | alertarouboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alertaroubos.
     */
    cursor?: alertarouboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alertaroubos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alertaroubos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alertaroubos.
     */
    distinct?: AlertarouboScalarFieldEnum | AlertarouboScalarFieldEnum[]
  }

  /**
   * alertaroubo findMany
   */
  export type alertarouboFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertaroubo
     */
    select?: alertarouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertarouboInclude<ExtArgs> | null
    /**
     * Filter, which alertaroubos to fetch.
     */
    where?: alertarouboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alertaroubos to fetch.
     */
    orderBy?: alertarouboOrderByWithRelationInput | alertarouboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing alertaroubos.
     */
    cursor?: alertarouboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alertaroubos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alertaroubos.
     */
    skip?: number
    distinct?: AlertarouboScalarFieldEnum | AlertarouboScalarFieldEnum[]
  }

  /**
   * alertaroubo create
   */
  export type alertarouboCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertaroubo
     */
    select?: alertarouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertarouboInclude<ExtArgs> | null
    /**
     * The data needed to create a alertaroubo.
     */
    data: XOR<alertarouboCreateInput, alertarouboUncheckedCreateInput>
  }

  /**
   * alertaroubo createMany
   */
  export type alertarouboCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many alertaroubos.
     */
    data: alertarouboCreateManyInput | alertarouboCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * alertaroubo update
   */
  export type alertarouboUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertaroubo
     */
    select?: alertarouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertarouboInclude<ExtArgs> | null
    /**
     * The data needed to update a alertaroubo.
     */
    data: XOR<alertarouboUpdateInput, alertarouboUncheckedUpdateInput>
    /**
     * Choose, which alertaroubo to update.
     */
    where: alertarouboWhereUniqueInput
  }

  /**
   * alertaroubo updateMany
   */
  export type alertarouboUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update alertaroubos.
     */
    data: XOR<alertarouboUpdateManyMutationInput, alertarouboUncheckedUpdateManyInput>
    /**
     * Filter which alertaroubos to update
     */
    where?: alertarouboWhereInput
  }

  /**
   * alertaroubo upsert
   */
  export type alertarouboUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertaroubo
     */
    select?: alertarouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertarouboInclude<ExtArgs> | null
    /**
     * The filter to search for the alertaroubo to update in case it exists.
     */
    where: alertarouboWhereUniqueInput
    /**
     * In case the alertaroubo found by the `where` argument doesn't exist, create a new alertaroubo with this data.
     */
    create: XOR<alertarouboCreateInput, alertarouboUncheckedCreateInput>
    /**
     * In case the alertaroubo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<alertarouboUpdateInput, alertarouboUncheckedUpdateInput>
  }

  /**
   * alertaroubo delete
   */
  export type alertarouboDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertaroubo
     */
    select?: alertarouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertarouboInclude<ExtArgs> | null
    /**
     * Filter which alertaroubo to delete.
     */
    where: alertarouboWhereUniqueInput
  }

  /**
   * alertaroubo deleteMany
   */
  export type alertarouboDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alertaroubos to delete
     */
    where?: alertarouboWhereInput
  }

  /**
   * alertaroubo without action
   */
  export type alertarouboDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertaroubo
     */
    select?: alertarouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertarouboInclude<ExtArgs> | null
  }


  /**
   * Model automobilista
   */

  export type AggregateAutomobilista = {
    _count: AutomobilistaCountAggregateOutputType | null
    _avg: AutomobilistaAvgAggregateOutputType | null
    _sum: AutomobilistaSumAggregateOutputType | null
    _min: AutomobilistaMinAggregateOutputType | null
    _max: AutomobilistaMaxAggregateOutputType | null
  }

  export type AutomobilistaAvgAggregateOutputType = {
    codAutomobilista: number | null
    codCartaConducao: number | null
    codPessoa: number | null
  }

  export type AutomobilistaSumAggregateOutputType = {
    codAutomobilista: number | null
    codCartaConducao: number | null
    codPessoa: number | null
  }

  export type AutomobilistaMinAggregateOutputType = {
    codAutomobilista: number | null
    codCartaConducao: number | null
    codPessoa: number | null
  }

  export type AutomobilistaMaxAggregateOutputType = {
    codAutomobilista: number | null
    codCartaConducao: number | null
    codPessoa: number | null
  }

  export type AutomobilistaCountAggregateOutputType = {
    codAutomobilista: number
    codCartaConducao: number
    codPessoa: number
    _all: number
  }


  export type AutomobilistaAvgAggregateInputType = {
    codAutomobilista?: true
    codCartaConducao?: true
    codPessoa?: true
  }

  export type AutomobilistaSumAggregateInputType = {
    codAutomobilista?: true
    codCartaConducao?: true
    codPessoa?: true
  }

  export type AutomobilistaMinAggregateInputType = {
    codAutomobilista?: true
    codCartaConducao?: true
    codPessoa?: true
  }

  export type AutomobilistaMaxAggregateInputType = {
    codAutomobilista?: true
    codCartaConducao?: true
    codPessoa?: true
  }

  export type AutomobilistaCountAggregateInputType = {
    codAutomobilista?: true
    codCartaConducao?: true
    codPessoa?: true
    _all?: true
  }

  export type AutomobilistaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which automobilista to aggregate.
     */
    where?: automobilistaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of automobilistas to fetch.
     */
    orderBy?: automobilistaOrderByWithRelationInput | automobilistaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: automobilistaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` automobilistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` automobilistas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned automobilistas
    **/
    _count?: true | AutomobilistaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutomobilistaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutomobilistaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomobilistaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomobilistaMaxAggregateInputType
  }

  export type GetAutomobilistaAggregateType<T extends AutomobilistaAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomobilista]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomobilista[P]>
      : GetScalarType<T[P], AggregateAutomobilista[P]>
  }




  export type automobilistaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: automobilistaWhereInput
    orderBy?: automobilistaOrderByWithAggregationInput | automobilistaOrderByWithAggregationInput[]
    by: AutomobilistaScalarFieldEnum[] | AutomobilistaScalarFieldEnum
    having?: automobilistaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomobilistaCountAggregateInputType | true
    _avg?: AutomobilistaAvgAggregateInputType
    _sum?: AutomobilistaSumAggregateInputType
    _min?: AutomobilistaMinAggregateInputType
    _max?: AutomobilistaMaxAggregateInputType
  }

  export type AutomobilistaGroupByOutputType = {
    codAutomobilista: number
    codCartaConducao: number
    codPessoa: number
    _count: AutomobilistaCountAggregateOutputType | null
    _avg: AutomobilistaAvgAggregateOutputType | null
    _sum: AutomobilistaSumAggregateOutputType | null
    _min: AutomobilistaMinAggregateOutputType | null
    _max: AutomobilistaMaxAggregateOutputType | null
  }

  type GetAutomobilistaGroupByPayload<T extends automobilistaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomobilistaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomobilistaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomobilistaGroupByOutputType[P]>
            : GetScalarType<T[P], AutomobilistaGroupByOutputType[P]>
        }
      >
    >


  export type automobilistaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codAutomobilista?: boolean
    codCartaConducao?: boolean
    codPessoa?: boolean
    alertaroubo?: boolean | automobilista$alertarouboArgs<ExtArgs>
    cartaconducao?: boolean | cartaconducaoDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    multa?: boolean | automobilista$multaArgs<ExtArgs>
    _count?: boolean | AutomobilistaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automobilista"]>


  export type automobilistaSelectScalar = {
    codAutomobilista?: boolean
    codCartaConducao?: boolean
    codPessoa?: boolean
  }

  export type automobilistaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alertaroubo?: boolean | automobilista$alertarouboArgs<ExtArgs>
    cartaconducao?: boolean | cartaconducaoDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    multa?: boolean | automobilista$multaArgs<ExtArgs>
    _count?: boolean | AutomobilistaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $automobilistaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "automobilista"
    objects: {
      alertaroubo: Prisma.$alertarouboPayload<ExtArgs>[]
      cartaconducao: Prisma.$cartaconducaoPayload<ExtArgs>
      pessoa: Prisma.$pessoaPayload<ExtArgs>
      multa: Prisma.$multaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      codAutomobilista: number
      codCartaConducao: number
      codPessoa: number
    }, ExtArgs["result"]["automobilista"]>
    composites: {}
  }

  type automobilistaGetPayload<S extends boolean | null | undefined | automobilistaDefaultArgs> = $Result.GetResult<Prisma.$automobilistaPayload, S>

  type automobilistaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<automobilistaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AutomobilistaCountAggregateInputType | true
    }

  export interface automobilistaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['automobilista'], meta: { name: 'automobilista' } }
    /**
     * Find zero or one Automobilista that matches the filter.
     * @param {automobilistaFindUniqueArgs} args - Arguments to find a Automobilista
     * @example
     * // Get one Automobilista
     * const automobilista = await prisma.automobilista.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends automobilistaFindUniqueArgs>(args: SelectSubset<T, automobilistaFindUniqueArgs<ExtArgs>>): Prisma__automobilistaClient<$Result.GetResult<Prisma.$automobilistaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Automobilista that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {automobilistaFindUniqueOrThrowArgs} args - Arguments to find a Automobilista
     * @example
     * // Get one Automobilista
     * const automobilista = await prisma.automobilista.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends automobilistaFindUniqueOrThrowArgs>(args: SelectSubset<T, automobilistaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__automobilistaClient<$Result.GetResult<Prisma.$automobilistaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Automobilista that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {automobilistaFindFirstArgs} args - Arguments to find a Automobilista
     * @example
     * // Get one Automobilista
     * const automobilista = await prisma.automobilista.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends automobilistaFindFirstArgs>(args?: SelectSubset<T, automobilistaFindFirstArgs<ExtArgs>>): Prisma__automobilistaClient<$Result.GetResult<Prisma.$automobilistaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Automobilista that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {automobilistaFindFirstOrThrowArgs} args - Arguments to find a Automobilista
     * @example
     * // Get one Automobilista
     * const automobilista = await prisma.automobilista.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends automobilistaFindFirstOrThrowArgs>(args?: SelectSubset<T, automobilistaFindFirstOrThrowArgs<ExtArgs>>): Prisma__automobilistaClient<$Result.GetResult<Prisma.$automobilistaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Automobilistas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {automobilistaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Automobilistas
     * const automobilistas = await prisma.automobilista.findMany()
     * 
     * // Get first 10 Automobilistas
     * const automobilistas = await prisma.automobilista.findMany({ take: 10 })
     * 
     * // Only select the `codAutomobilista`
     * const automobilistaWithCodAutomobilistaOnly = await prisma.automobilista.findMany({ select: { codAutomobilista: true } })
     * 
     */
    findMany<T extends automobilistaFindManyArgs>(args?: SelectSubset<T, automobilistaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$automobilistaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Automobilista.
     * @param {automobilistaCreateArgs} args - Arguments to create a Automobilista.
     * @example
     * // Create one Automobilista
     * const Automobilista = await prisma.automobilista.create({
     *   data: {
     *     // ... data to create a Automobilista
     *   }
     * })
     * 
     */
    create<T extends automobilistaCreateArgs>(args: SelectSubset<T, automobilistaCreateArgs<ExtArgs>>): Prisma__automobilistaClient<$Result.GetResult<Prisma.$automobilistaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Automobilistas.
     * @param {automobilistaCreateManyArgs} args - Arguments to create many Automobilistas.
     * @example
     * // Create many Automobilistas
     * const automobilista = await prisma.automobilista.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends automobilistaCreateManyArgs>(args?: SelectSubset<T, automobilistaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Automobilista.
     * @param {automobilistaDeleteArgs} args - Arguments to delete one Automobilista.
     * @example
     * // Delete one Automobilista
     * const Automobilista = await prisma.automobilista.delete({
     *   where: {
     *     // ... filter to delete one Automobilista
     *   }
     * })
     * 
     */
    delete<T extends automobilistaDeleteArgs>(args: SelectSubset<T, automobilistaDeleteArgs<ExtArgs>>): Prisma__automobilistaClient<$Result.GetResult<Prisma.$automobilistaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Automobilista.
     * @param {automobilistaUpdateArgs} args - Arguments to update one Automobilista.
     * @example
     * // Update one Automobilista
     * const automobilista = await prisma.automobilista.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends automobilistaUpdateArgs>(args: SelectSubset<T, automobilistaUpdateArgs<ExtArgs>>): Prisma__automobilistaClient<$Result.GetResult<Prisma.$automobilistaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Automobilistas.
     * @param {automobilistaDeleteManyArgs} args - Arguments to filter Automobilistas to delete.
     * @example
     * // Delete a few Automobilistas
     * const { count } = await prisma.automobilista.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends automobilistaDeleteManyArgs>(args?: SelectSubset<T, automobilistaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Automobilistas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {automobilistaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Automobilistas
     * const automobilista = await prisma.automobilista.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends automobilistaUpdateManyArgs>(args: SelectSubset<T, automobilistaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Automobilista.
     * @param {automobilistaUpsertArgs} args - Arguments to update or create a Automobilista.
     * @example
     * // Update or create a Automobilista
     * const automobilista = await prisma.automobilista.upsert({
     *   create: {
     *     // ... data to create a Automobilista
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Automobilista we want to update
     *   }
     * })
     */
    upsert<T extends automobilistaUpsertArgs>(args: SelectSubset<T, automobilistaUpsertArgs<ExtArgs>>): Prisma__automobilistaClient<$Result.GetResult<Prisma.$automobilistaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Automobilistas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {automobilistaCountArgs} args - Arguments to filter Automobilistas to count.
     * @example
     * // Count the number of Automobilistas
     * const count = await prisma.automobilista.count({
     *   where: {
     *     // ... the filter for the Automobilistas we want to count
     *   }
     * })
    **/
    count<T extends automobilistaCountArgs>(
      args?: Subset<T, automobilistaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomobilistaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Automobilista.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomobilistaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomobilistaAggregateArgs>(args: Subset<T, AutomobilistaAggregateArgs>): Prisma.PrismaPromise<GetAutomobilistaAggregateType<T>>

    /**
     * Group by Automobilista.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {automobilistaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends automobilistaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: automobilistaGroupByArgs['orderBy'] }
        : { orderBy?: automobilistaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, automobilistaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomobilistaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the automobilista model
   */
  readonly fields: automobilistaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for automobilista.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__automobilistaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alertaroubo<T extends automobilista$alertarouboArgs<ExtArgs> = {}>(args?: Subset<T, automobilista$alertarouboArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alertarouboPayload<ExtArgs>, T, "findMany"> | Null>
    cartaconducao<T extends cartaconducaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cartaconducaoDefaultArgs<ExtArgs>>): Prisma__cartaconducaoClient<$Result.GetResult<Prisma.$cartaconducaoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pessoa<T extends pessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pessoaDefaultArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    multa<T extends automobilista$multaArgs<ExtArgs> = {}>(args?: Subset<T, automobilista$multaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$multaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the automobilista model
   */ 
  interface automobilistaFieldRefs {
    readonly codAutomobilista: FieldRef<"automobilista", 'Int'>
    readonly codCartaConducao: FieldRef<"automobilista", 'Int'>
    readonly codPessoa: FieldRef<"automobilista", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * automobilista findUnique
   */
  export type automobilistaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the automobilista
     */
    select?: automobilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: automobilistaInclude<ExtArgs> | null
    /**
     * Filter, which automobilista to fetch.
     */
    where: automobilistaWhereUniqueInput
  }

  /**
   * automobilista findUniqueOrThrow
   */
  export type automobilistaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the automobilista
     */
    select?: automobilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: automobilistaInclude<ExtArgs> | null
    /**
     * Filter, which automobilista to fetch.
     */
    where: automobilistaWhereUniqueInput
  }

  /**
   * automobilista findFirst
   */
  export type automobilistaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the automobilista
     */
    select?: automobilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: automobilistaInclude<ExtArgs> | null
    /**
     * Filter, which automobilista to fetch.
     */
    where?: automobilistaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of automobilistas to fetch.
     */
    orderBy?: automobilistaOrderByWithRelationInput | automobilistaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for automobilistas.
     */
    cursor?: automobilistaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` automobilistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` automobilistas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of automobilistas.
     */
    distinct?: AutomobilistaScalarFieldEnum | AutomobilistaScalarFieldEnum[]
  }

  /**
   * automobilista findFirstOrThrow
   */
  export type automobilistaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the automobilista
     */
    select?: automobilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: automobilistaInclude<ExtArgs> | null
    /**
     * Filter, which automobilista to fetch.
     */
    where?: automobilistaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of automobilistas to fetch.
     */
    orderBy?: automobilistaOrderByWithRelationInput | automobilistaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for automobilistas.
     */
    cursor?: automobilistaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` automobilistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` automobilistas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of automobilistas.
     */
    distinct?: AutomobilistaScalarFieldEnum | AutomobilistaScalarFieldEnum[]
  }

  /**
   * automobilista findMany
   */
  export type automobilistaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the automobilista
     */
    select?: automobilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: automobilistaInclude<ExtArgs> | null
    /**
     * Filter, which automobilistas to fetch.
     */
    where?: automobilistaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of automobilistas to fetch.
     */
    orderBy?: automobilistaOrderByWithRelationInput | automobilistaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing automobilistas.
     */
    cursor?: automobilistaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` automobilistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` automobilistas.
     */
    skip?: number
    distinct?: AutomobilistaScalarFieldEnum | AutomobilistaScalarFieldEnum[]
  }

  /**
   * automobilista create
   */
  export type automobilistaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the automobilista
     */
    select?: automobilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: automobilistaInclude<ExtArgs> | null
    /**
     * The data needed to create a automobilista.
     */
    data: XOR<automobilistaCreateInput, automobilistaUncheckedCreateInput>
  }

  /**
   * automobilista createMany
   */
  export type automobilistaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many automobilistas.
     */
    data: automobilistaCreateManyInput | automobilistaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * automobilista update
   */
  export type automobilistaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the automobilista
     */
    select?: automobilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: automobilistaInclude<ExtArgs> | null
    /**
     * The data needed to update a automobilista.
     */
    data: XOR<automobilistaUpdateInput, automobilistaUncheckedUpdateInput>
    /**
     * Choose, which automobilista to update.
     */
    where: automobilistaWhereUniqueInput
  }

  /**
   * automobilista updateMany
   */
  export type automobilistaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update automobilistas.
     */
    data: XOR<automobilistaUpdateManyMutationInput, automobilistaUncheckedUpdateManyInput>
    /**
     * Filter which automobilistas to update
     */
    where?: automobilistaWhereInput
  }

  /**
   * automobilista upsert
   */
  export type automobilistaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the automobilista
     */
    select?: automobilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: automobilistaInclude<ExtArgs> | null
    /**
     * The filter to search for the automobilista to update in case it exists.
     */
    where: automobilistaWhereUniqueInput
    /**
     * In case the automobilista found by the `where` argument doesn't exist, create a new automobilista with this data.
     */
    create: XOR<automobilistaCreateInput, automobilistaUncheckedCreateInput>
    /**
     * In case the automobilista was found with the provided `where` argument, update it with this data.
     */
    update: XOR<automobilistaUpdateInput, automobilistaUncheckedUpdateInput>
  }

  /**
   * automobilista delete
   */
  export type automobilistaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the automobilista
     */
    select?: automobilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: automobilistaInclude<ExtArgs> | null
    /**
     * Filter which automobilista to delete.
     */
    where: automobilistaWhereUniqueInput
  }

  /**
   * automobilista deleteMany
   */
  export type automobilistaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which automobilistas to delete
     */
    where?: automobilistaWhereInput
  }

  /**
   * automobilista.alertaroubo
   */
  export type automobilista$alertarouboArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertaroubo
     */
    select?: alertarouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertarouboInclude<ExtArgs> | null
    where?: alertarouboWhereInput
    orderBy?: alertarouboOrderByWithRelationInput | alertarouboOrderByWithRelationInput[]
    cursor?: alertarouboWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertarouboScalarFieldEnum | AlertarouboScalarFieldEnum[]
  }

  /**
   * automobilista.multa
   */
  export type automobilista$multaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multa
     */
    select?: multaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: multaInclude<ExtArgs> | null
    where?: multaWhereInput
    orderBy?: multaOrderByWithRelationInput | multaOrderByWithRelationInput[]
    cursor?: multaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MultaScalarFieldEnum | MultaScalarFieldEnum[]
  }

  /**
   * automobilista without action
   */
  export type automobilistaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the automobilista
     */
    select?: automobilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: automobilistaInclude<ExtArgs> | null
  }


  /**
   * Model bi
   */

  export type AggregateBi = {
    _count: BiCountAggregateOutputType | null
    _avg: BiAvgAggregateOutputType | null
    _sum: BiSumAggregateOutputType | null
    _min: BiMinAggregateOutputType | null
    _max: BiMaxAggregateOutputType | null
  }

  export type BiAvgAggregateOutputType = {
    idBi: number | null
    codFicheiroBi: number | null
  }

  export type BiSumAggregateOutputType = {
    idBi: number | null
    codFicheiroBi: number | null
  }

  export type BiMinAggregateOutputType = {
    idBi: number | null
    dataEmicaoBi: Date | null
    dataValidacaoBi: Date | null
    numeroBI: string | null
    codFicheiroBi: number | null
  }

  export type BiMaxAggregateOutputType = {
    idBi: number | null
    dataEmicaoBi: Date | null
    dataValidacaoBi: Date | null
    numeroBI: string | null
    codFicheiroBi: number | null
  }

  export type BiCountAggregateOutputType = {
    idBi: number
    dataEmicaoBi: number
    dataValidacaoBi: number
    numeroBI: number
    codFicheiroBi: number
    _all: number
  }


  export type BiAvgAggregateInputType = {
    idBi?: true
    codFicheiroBi?: true
  }

  export type BiSumAggregateInputType = {
    idBi?: true
    codFicheiroBi?: true
  }

  export type BiMinAggregateInputType = {
    idBi?: true
    dataEmicaoBi?: true
    dataValidacaoBi?: true
    numeroBI?: true
    codFicheiroBi?: true
  }

  export type BiMaxAggregateInputType = {
    idBi?: true
    dataEmicaoBi?: true
    dataValidacaoBi?: true
    numeroBI?: true
    codFicheiroBi?: true
  }

  export type BiCountAggregateInputType = {
    idBi?: true
    dataEmicaoBi?: true
    dataValidacaoBi?: true
    numeroBI?: true
    codFicheiroBi?: true
    _all?: true
  }

  export type BiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bi to aggregate.
     */
    where?: biWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bis to fetch.
     */
    orderBy?: biOrderByWithRelationInput | biOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: biWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bis
    **/
    _count?: true | BiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BiMaxAggregateInputType
  }

  export type GetBiAggregateType<T extends BiAggregateArgs> = {
        [P in keyof T & keyof AggregateBi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBi[P]>
      : GetScalarType<T[P], AggregateBi[P]>
  }




  export type biGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: biWhereInput
    orderBy?: biOrderByWithAggregationInput | biOrderByWithAggregationInput[]
    by: BiScalarFieldEnum[] | BiScalarFieldEnum
    having?: biScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BiCountAggregateInputType | true
    _avg?: BiAvgAggregateInputType
    _sum?: BiSumAggregateInputType
    _min?: BiMinAggregateInputType
    _max?: BiMaxAggregateInputType
  }

  export type BiGroupByOutputType = {
    idBi: number
    dataEmicaoBi: Date
    dataValidacaoBi: Date
    numeroBI: string
    codFicheiroBi: number
    _count: BiCountAggregateOutputType | null
    _avg: BiAvgAggregateOutputType | null
    _sum: BiSumAggregateOutputType | null
    _min: BiMinAggregateOutputType | null
    _max: BiMaxAggregateOutputType | null
  }

  type GetBiGroupByPayload<T extends biGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BiGroupByOutputType[P]>
            : GetScalarType<T[P], BiGroupByOutputType[P]>
        }
      >
    >


  export type biSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBi?: boolean
    dataEmicaoBi?: boolean
    dataValidacaoBi?: boolean
    numeroBI?: boolean
    codFicheiroBi?: boolean
    ficheiro?: boolean | ficheiroDefaultArgs<ExtArgs>
    pessoa?: boolean | bi$pessoaArgs<ExtArgs>
    _count?: boolean | BiCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bi"]>


  export type biSelectScalar = {
    idBi?: boolean
    dataEmicaoBi?: boolean
    dataValidacaoBi?: boolean
    numeroBI?: boolean
    codFicheiroBi?: boolean
  }

  export type biInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ficheiro?: boolean | ficheiroDefaultArgs<ExtArgs>
    pessoa?: boolean | bi$pessoaArgs<ExtArgs>
    _count?: boolean | BiCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $biPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bi"
    objects: {
      ficheiro: Prisma.$ficheiroPayload<ExtArgs>
      pessoa: Prisma.$pessoaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idBi: number
      dataEmicaoBi: Date
      dataValidacaoBi: Date
      numeroBI: string
      codFicheiroBi: number
    }, ExtArgs["result"]["bi"]>
    composites: {}
  }

  type biGetPayload<S extends boolean | null | undefined | biDefaultArgs> = $Result.GetResult<Prisma.$biPayload, S>

  type biCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<biFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BiCountAggregateInputType | true
    }

  export interface biDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bi'], meta: { name: 'bi' } }
    /**
     * Find zero or one Bi that matches the filter.
     * @param {biFindUniqueArgs} args - Arguments to find a Bi
     * @example
     * // Get one Bi
     * const bi = await prisma.bi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends biFindUniqueArgs>(args: SelectSubset<T, biFindUniqueArgs<ExtArgs>>): Prisma__biClient<$Result.GetResult<Prisma.$biPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bi that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {biFindUniqueOrThrowArgs} args - Arguments to find a Bi
     * @example
     * // Get one Bi
     * const bi = await prisma.bi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends biFindUniqueOrThrowArgs>(args: SelectSubset<T, biFindUniqueOrThrowArgs<ExtArgs>>): Prisma__biClient<$Result.GetResult<Prisma.$biPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {biFindFirstArgs} args - Arguments to find a Bi
     * @example
     * // Get one Bi
     * const bi = await prisma.bi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends biFindFirstArgs>(args?: SelectSubset<T, biFindFirstArgs<ExtArgs>>): Prisma__biClient<$Result.GetResult<Prisma.$biPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {biFindFirstOrThrowArgs} args - Arguments to find a Bi
     * @example
     * // Get one Bi
     * const bi = await prisma.bi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends biFindFirstOrThrowArgs>(args?: SelectSubset<T, biFindFirstOrThrowArgs<ExtArgs>>): Prisma__biClient<$Result.GetResult<Prisma.$biPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {biFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bis
     * const bis = await prisma.bi.findMany()
     * 
     * // Get first 10 Bis
     * const bis = await prisma.bi.findMany({ take: 10 })
     * 
     * // Only select the `idBi`
     * const biWithIdBiOnly = await prisma.bi.findMany({ select: { idBi: true } })
     * 
     */
    findMany<T extends biFindManyArgs>(args?: SelectSubset<T, biFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$biPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bi.
     * @param {biCreateArgs} args - Arguments to create a Bi.
     * @example
     * // Create one Bi
     * const Bi = await prisma.bi.create({
     *   data: {
     *     // ... data to create a Bi
     *   }
     * })
     * 
     */
    create<T extends biCreateArgs>(args: SelectSubset<T, biCreateArgs<ExtArgs>>): Prisma__biClient<$Result.GetResult<Prisma.$biPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bis.
     * @param {biCreateManyArgs} args - Arguments to create many Bis.
     * @example
     * // Create many Bis
     * const bi = await prisma.bi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends biCreateManyArgs>(args?: SelectSubset<T, biCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bi.
     * @param {biDeleteArgs} args - Arguments to delete one Bi.
     * @example
     * // Delete one Bi
     * const Bi = await prisma.bi.delete({
     *   where: {
     *     // ... filter to delete one Bi
     *   }
     * })
     * 
     */
    delete<T extends biDeleteArgs>(args: SelectSubset<T, biDeleteArgs<ExtArgs>>): Prisma__biClient<$Result.GetResult<Prisma.$biPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bi.
     * @param {biUpdateArgs} args - Arguments to update one Bi.
     * @example
     * // Update one Bi
     * const bi = await prisma.bi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends biUpdateArgs>(args: SelectSubset<T, biUpdateArgs<ExtArgs>>): Prisma__biClient<$Result.GetResult<Prisma.$biPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bis.
     * @param {biDeleteManyArgs} args - Arguments to filter Bis to delete.
     * @example
     * // Delete a few Bis
     * const { count } = await prisma.bi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends biDeleteManyArgs>(args?: SelectSubset<T, biDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {biUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bis
     * const bi = await prisma.bi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends biUpdateManyArgs>(args: SelectSubset<T, biUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bi.
     * @param {biUpsertArgs} args - Arguments to update or create a Bi.
     * @example
     * // Update or create a Bi
     * const bi = await prisma.bi.upsert({
     *   create: {
     *     // ... data to create a Bi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bi we want to update
     *   }
     * })
     */
    upsert<T extends biUpsertArgs>(args: SelectSubset<T, biUpsertArgs<ExtArgs>>): Prisma__biClient<$Result.GetResult<Prisma.$biPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {biCountArgs} args - Arguments to filter Bis to count.
     * @example
     * // Count the number of Bis
     * const count = await prisma.bi.count({
     *   where: {
     *     // ... the filter for the Bis we want to count
     *   }
     * })
    **/
    count<T extends biCountArgs>(
      args?: Subset<T, biCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BiAggregateArgs>(args: Subset<T, BiAggregateArgs>): Prisma.PrismaPromise<GetBiAggregateType<T>>

    /**
     * Group by Bi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {biGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends biGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: biGroupByArgs['orderBy'] }
        : { orderBy?: biGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, biGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bi model
   */
  readonly fields: biFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__biClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ficheiro<T extends ficheiroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ficheiroDefaultArgs<ExtArgs>>): Prisma__ficheiroClient<$Result.GetResult<Prisma.$ficheiroPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pessoa<T extends bi$pessoaArgs<ExtArgs> = {}>(args?: Subset<T, bi$pessoaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bi model
   */ 
  interface biFieldRefs {
    readonly idBi: FieldRef<"bi", 'Int'>
    readonly dataEmicaoBi: FieldRef<"bi", 'DateTime'>
    readonly dataValidacaoBi: FieldRef<"bi", 'DateTime'>
    readonly numeroBI: FieldRef<"bi", 'String'>
    readonly codFicheiroBi: FieldRef<"bi", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * bi findUnique
   */
  export type biFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bi
     */
    select?: biSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: biInclude<ExtArgs> | null
    /**
     * Filter, which bi to fetch.
     */
    where: biWhereUniqueInput
  }

  /**
   * bi findUniqueOrThrow
   */
  export type biFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bi
     */
    select?: biSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: biInclude<ExtArgs> | null
    /**
     * Filter, which bi to fetch.
     */
    where: biWhereUniqueInput
  }

  /**
   * bi findFirst
   */
  export type biFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bi
     */
    select?: biSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: biInclude<ExtArgs> | null
    /**
     * Filter, which bi to fetch.
     */
    where?: biWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bis to fetch.
     */
    orderBy?: biOrderByWithRelationInput | biOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bis.
     */
    cursor?: biWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bis.
     */
    distinct?: BiScalarFieldEnum | BiScalarFieldEnum[]
  }

  /**
   * bi findFirstOrThrow
   */
  export type biFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bi
     */
    select?: biSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: biInclude<ExtArgs> | null
    /**
     * Filter, which bi to fetch.
     */
    where?: biWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bis to fetch.
     */
    orderBy?: biOrderByWithRelationInput | biOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bis.
     */
    cursor?: biWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bis.
     */
    distinct?: BiScalarFieldEnum | BiScalarFieldEnum[]
  }

  /**
   * bi findMany
   */
  export type biFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bi
     */
    select?: biSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: biInclude<ExtArgs> | null
    /**
     * Filter, which bis to fetch.
     */
    where?: biWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bis to fetch.
     */
    orderBy?: biOrderByWithRelationInput | biOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bis.
     */
    cursor?: biWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bis.
     */
    skip?: number
    distinct?: BiScalarFieldEnum | BiScalarFieldEnum[]
  }

  /**
   * bi create
   */
  export type biCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bi
     */
    select?: biSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: biInclude<ExtArgs> | null
    /**
     * The data needed to create a bi.
     */
    data: XOR<biCreateInput, biUncheckedCreateInput>
  }

  /**
   * bi createMany
   */
  export type biCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bis.
     */
    data: biCreateManyInput | biCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bi update
   */
  export type biUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bi
     */
    select?: biSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: biInclude<ExtArgs> | null
    /**
     * The data needed to update a bi.
     */
    data: XOR<biUpdateInput, biUncheckedUpdateInput>
    /**
     * Choose, which bi to update.
     */
    where: biWhereUniqueInput
  }

  /**
   * bi updateMany
   */
  export type biUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bis.
     */
    data: XOR<biUpdateManyMutationInput, biUncheckedUpdateManyInput>
    /**
     * Filter which bis to update
     */
    where?: biWhereInput
  }

  /**
   * bi upsert
   */
  export type biUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bi
     */
    select?: biSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: biInclude<ExtArgs> | null
    /**
     * The filter to search for the bi to update in case it exists.
     */
    where: biWhereUniqueInput
    /**
     * In case the bi found by the `where` argument doesn't exist, create a new bi with this data.
     */
    create: XOR<biCreateInput, biUncheckedCreateInput>
    /**
     * In case the bi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<biUpdateInput, biUncheckedUpdateInput>
  }

  /**
   * bi delete
   */
  export type biDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bi
     */
    select?: biSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: biInclude<ExtArgs> | null
    /**
     * Filter which bi to delete.
     */
    where: biWhereUniqueInput
  }

  /**
   * bi deleteMany
   */
  export type biDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bis to delete
     */
    where?: biWhereInput
  }

  /**
   * bi.pessoa
   */
  export type bi$pessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    where?: pessoaWhereInput
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    cursor?: pessoaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * bi without action
   */
  export type biDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bi
     */
    select?: biSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: biInclude<ExtArgs> | null
  }


  /**
   * Model cartaconducao
   */

  export type AggregateCartaconducao = {
    _count: CartaconducaoCountAggregateOutputType | null
    _avg: CartaconducaoAvgAggregateOutputType | null
    _sum: CartaconducaoSumAggregateOutputType | null
    _min: CartaconducaoMinAggregateOutputType | null
    _max: CartaconducaoMaxAggregateOutputType | null
  }

  export type CartaconducaoAvgAggregateOutputType = {
    codCartaConducao: number | null
    codCategoriaCarta: number | null
    numeroCarta: number | null
    localEmissao: number | null
    codFicheiroCartaConducao: number | null
  }

  export type CartaconducaoSumAggregateOutputType = {
    codCartaConducao: number | null
    codCategoriaCarta: number | null
    numeroCarta: number | null
    localEmissao: number | null
    codFicheiroCartaConducao: number | null
  }

  export type CartaconducaoMinAggregateOutputType = {
    codCartaConducao: number | null
    dataEmissao: Date | null
    dataValidade: Date | null
    numeroVia: string | null
    codCategoriaCarta: number | null
    numeroCarta: number | null
    dataPrimeiraEmissao: Date | null
    localEmissao: number | null
    codFicheiroCartaConducao: number | null
  }

  export type CartaconducaoMaxAggregateOutputType = {
    codCartaConducao: number | null
    dataEmissao: Date | null
    dataValidade: Date | null
    numeroVia: string | null
    codCategoriaCarta: number | null
    numeroCarta: number | null
    dataPrimeiraEmissao: Date | null
    localEmissao: number | null
    codFicheiroCartaConducao: number | null
  }

  export type CartaconducaoCountAggregateOutputType = {
    codCartaConducao: number
    dataEmissao: number
    dataValidade: number
    numeroVia: number
    codCategoriaCarta: number
    numeroCarta: number
    dataPrimeiraEmissao: number
    localEmissao: number
    codFicheiroCartaConducao: number
    _all: number
  }


  export type CartaconducaoAvgAggregateInputType = {
    codCartaConducao?: true
    codCategoriaCarta?: true
    numeroCarta?: true
    localEmissao?: true
    codFicheiroCartaConducao?: true
  }

  export type CartaconducaoSumAggregateInputType = {
    codCartaConducao?: true
    codCategoriaCarta?: true
    numeroCarta?: true
    localEmissao?: true
    codFicheiroCartaConducao?: true
  }

  export type CartaconducaoMinAggregateInputType = {
    codCartaConducao?: true
    dataEmissao?: true
    dataValidade?: true
    numeroVia?: true
    codCategoriaCarta?: true
    numeroCarta?: true
    dataPrimeiraEmissao?: true
    localEmissao?: true
    codFicheiroCartaConducao?: true
  }

  export type CartaconducaoMaxAggregateInputType = {
    codCartaConducao?: true
    dataEmissao?: true
    dataValidade?: true
    numeroVia?: true
    codCategoriaCarta?: true
    numeroCarta?: true
    dataPrimeiraEmissao?: true
    localEmissao?: true
    codFicheiroCartaConducao?: true
  }

  export type CartaconducaoCountAggregateInputType = {
    codCartaConducao?: true
    dataEmissao?: true
    dataValidade?: true
    numeroVia?: true
    codCategoriaCarta?: true
    numeroCarta?: true
    dataPrimeiraEmissao?: true
    localEmissao?: true
    codFicheiroCartaConducao?: true
    _all?: true
  }

  export type CartaconducaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cartaconducao to aggregate.
     */
    where?: cartaconducaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cartaconducaos to fetch.
     */
    orderBy?: cartaconducaoOrderByWithRelationInput | cartaconducaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cartaconducaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cartaconducaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cartaconducaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cartaconducaos
    **/
    _count?: true | CartaconducaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartaconducaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartaconducaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartaconducaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartaconducaoMaxAggregateInputType
  }

  export type GetCartaconducaoAggregateType<T extends CartaconducaoAggregateArgs> = {
        [P in keyof T & keyof AggregateCartaconducao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartaconducao[P]>
      : GetScalarType<T[P], AggregateCartaconducao[P]>
  }




  export type cartaconducaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cartaconducaoWhereInput
    orderBy?: cartaconducaoOrderByWithAggregationInput | cartaconducaoOrderByWithAggregationInput[]
    by: CartaconducaoScalarFieldEnum[] | CartaconducaoScalarFieldEnum
    having?: cartaconducaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartaconducaoCountAggregateInputType | true
    _avg?: CartaconducaoAvgAggregateInputType
    _sum?: CartaconducaoSumAggregateInputType
    _min?: CartaconducaoMinAggregateInputType
    _max?: CartaconducaoMaxAggregateInputType
  }

  export type CartaconducaoGroupByOutputType = {
    codCartaConducao: number
    dataEmissao: Date
    dataValidade: Date
    numeroVia: string
    codCategoriaCarta: number
    numeroCarta: number
    dataPrimeiraEmissao: Date
    localEmissao: number
    codFicheiroCartaConducao: number
    _count: CartaconducaoCountAggregateOutputType | null
    _avg: CartaconducaoAvgAggregateOutputType | null
    _sum: CartaconducaoSumAggregateOutputType | null
    _min: CartaconducaoMinAggregateOutputType | null
    _max: CartaconducaoMaxAggregateOutputType | null
  }

  type GetCartaconducaoGroupByPayload<T extends cartaconducaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartaconducaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartaconducaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartaconducaoGroupByOutputType[P]>
            : GetScalarType<T[P], CartaconducaoGroupByOutputType[P]>
        }
      >
    >


  export type cartaconducaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codCartaConducao?: boolean
    dataEmissao?: boolean
    dataValidade?: boolean
    numeroVia?: boolean
    codCategoriaCarta?: boolean
    numeroCarta?: boolean
    dataPrimeiraEmissao?: boolean
    localEmissao?: boolean
    codFicheiroCartaConducao?: boolean
    automobilista?: boolean | cartaconducao$automobilistaArgs<ExtArgs>
    categoriacarta?: boolean | categoriacartaDefaultArgs<ExtArgs>
    ficheiro?: boolean | ficheiroDefaultArgs<ExtArgs>
    _count?: boolean | CartaconducaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartaconducao"]>


  export type cartaconducaoSelectScalar = {
    codCartaConducao?: boolean
    dataEmissao?: boolean
    dataValidade?: boolean
    numeroVia?: boolean
    codCategoriaCarta?: boolean
    numeroCarta?: boolean
    dataPrimeiraEmissao?: boolean
    localEmissao?: boolean
    codFicheiroCartaConducao?: boolean
  }

  export type cartaconducaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automobilista?: boolean | cartaconducao$automobilistaArgs<ExtArgs>
    categoriacarta?: boolean | categoriacartaDefaultArgs<ExtArgs>
    ficheiro?: boolean | ficheiroDefaultArgs<ExtArgs>
    _count?: boolean | CartaconducaoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $cartaconducaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cartaconducao"
    objects: {
      automobilista: Prisma.$automobilistaPayload<ExtArgs>[]
      categoriacarta: Prisma.$categoriacartaPayload<ExtArgs>
      ficheiro: Prisma.$ficheiroPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      codCartaConducao: number
      dataEmissao: Date
      dataValidade: Date
      numeroVia: string
      codCategoriaCarta: number
      numeroCarta: number
      dataPrimeiraEmissao: Date
      localEmissao: number
      codFicheiroCartaConducao: number
    }, ExtArgs["result"]["cartaconducao"]>
    composites: {}
  }

  type cartaconducaoGetPayload<S extends boolean | null | undefined | cartaconducaoDefaultArgs> = $Result.GetResult<Prisma.$cartaconducaoPayload, S>

  type cartaconducaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cartaconducaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CartaconducaoCountAggregateInputType | true
    }

  export interface cartaconducaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cartaconducao'], meta: { name: 'cartaconducao' } }
    /**
     * Find zero or one Cartaconducao that matches the filter.
     * @param {cartaconducaoFindUniqueArgs} args - Arguments to find a Cartaconducao
     * @example
     * // Get one Cartaconducao
     * const cartaconducao = await prisma.cartaconducao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cartaconducaoFindUniqueArgs>(args: SelectSubset<T, cartaconducaoFindUniqueArgs<ExtArgs>>): Prisma__cartaconducaoClient<$Result.GetResult<Prisma.$cartaconducaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cartaconducao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {cartaconducaoFindUniqueOrThrowArgs} args - Arguments to find a Cartaconducao
     * @example
     * // Get one Cartaconducao
     * const cartaconducao = await prisma.cartaconducao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cartaconducaoFindUniqueOrThrowArgs>(args: SelectSubset<T, cartaconducaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cartaconducaoClient<$Result.GetResult<Prisma.$cartaconducaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cartaconducao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartaconducaoFindFirstArgs} args - Arguments to find a Cartaconducao
     * @example
     * // Get one Cartaconducao
     * const cartaconducao = await prisma.cartaconducao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cartaconducaoFindFirstArgs>(args?: SelectSubset<T, cartaconducaoFindFirstArgs<ExtArgs>>): Prisma__cartaconducaoClient<$Result.GetResult<Prisma.$cartaconducaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cartaconducao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartaconducaoFindFirstOrThrowArgs} args - Arguments to find a Cartaconducao
     * @example
     * // Get one Cartaconducao
     * const cartaconducao = await prisma.cartaconducao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cartaconducaoFindFirstOrThrowArgs>(args?: SelectSubset<T, cartaconducaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__cartaconducaoClient<$Result.GetResult<Prisma.$cartaconducaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cartaconducaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartaconducaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cartaconducaos
     * const cartaconducaos = await prisma.cartaconducao.findMany()
     * 
     * // Get first 10 Cartaconducaos
     * const cartaconducaos = await prisma.cartaconducao.findMany({ take: 10 })
     * 
     * // Only select the `codCartaConducao`
     * const cartaconducaoWithCodCartaConducaoOnly = await prisma.cartaconducao.findMany({ select: { codCartaConducao: true } })
     * 
     */
    findMany<T extends cartaconducaoFindManyArgs>(args?: SelectSubset<T, cartaconducaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cartaconducaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cartaconducao.
     * @param {cartaconducaoCreateArgs} args - Arguments to create a Cartaconducao.
     * @example
     * // Create one Cartaconducao
     * const Cartaconducao = await prisma.cartaconducao.create({
     *   data: {
     *     // ... data to create a Cartaconducao
     *   }
     * })
     * 
     */
    create<T extends cartaconducaoCreateArgs>(args: SelectSubset<T, cartaconducaoCreateArgs<ExtArgs>>): Prisma__cartaconducaoClient<$Result.GetResult<Prisma.$cartaconducaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cartaconducaos.
     * @param {cartaconducaoCreateManyArgs} args - Arguments to create many Cartaconducaos.
     * @example
     * // Create many Cartaconducaos
     * const cartaconducao = await prisma.cartaconducao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cartaconducaoCreateManyArgs>(args?: SelectSubset<T, cartaconducaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cartaconducao.
     * @param {cartaconducaoDeleteArgs} args - Arguments to delete one Cartaconducao.
     * @example
     * // Delete one Cartaconducao
     * const Cartaconducao = await prisma.cartaconducao.delete({
     *   where: {
     *     // ... filter to delete one Cartaconducao
     *   }
     * })
     * 
     */
    delete<T extends cartaconducaoDeleteArgs>(args: SelectSubset<T, cartaconducaoDeleteArgs<ExtArgs>>): Prisma__cartaconducaoClient<$Result.GetResult<Prisma.$cartaconducaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cartaconducao.
     * @param {cartaconducaoUpdateArgs} args - Arguments to update one Cartaconducao.
     * @example
     * // Update one Cartaconducao
     * const cartaconducao = await prisma.cartaconducao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cartaconducaoUpdateArgs>(args: SelectSubset<T, cartaconducaoUpdateArgs<ExtArgs>>): Prisma__cartaconducaoClient<$Result.GetResult<Prisma.$cartaconducaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cartaconducaos.
     * @param {cartaconducaoDeleteManyArgs} args - Arguments to filter Cartaconducaos to delete.
     * @example
     * // Delete a few Cartaconducaos
     * const { count } = await prisma.cartaconducao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cartaconducaoDeleteManyArgs>(args?: SelectSubset<T, cartaconducaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cartaconducaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartaconducaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cartaconducaos
     * const cartaconducao = await prisma.cartaconducao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cartaconducaoUpdateManyArgs>(args: SelectSubset<T, cartaconducaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cartaconducao.
     * @param {cartaconducaoUpsertArgs} args - Arguments to update or create a Cartaconducao.
     * @example
     * // Update or create a Cartaconducao
     * const cartaconducao = await prisma.cartaconducao.upsert({
     *   create: {
     *     // ... data to create a Cartaconducao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cartaconducao we want to update
     *   }
     * })
     */
    upsert<T extends cartaconducaoUpsertArgs>(args: SelectSubset<T, cartaconducaoUpsertArgs<ExtArgs>>): Prisma__cartaconducaoClient<$Result.GetResult<Prisma.$cartaconducaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cartaconducaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartaconducaoCountArgs} args - Arguments to filter Cartaconducaos to count.
     * @example
     * // Count the number of Cartaconducaos
     * const count = await prisma.cartaconducao.count({
     *   where: {
     *     // ... the filter for the Cartaconducaos we want to count
     *   }
     * })
    **/
    count<T extends cartaconducaoCountArgs>(
      args?: Subset<T, cartaconducaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartaconducaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cartaconducao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartaconducaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartaconducaoAggregateArgs>(args: Subset<T, CartaconducaoAggregateArgs>): Prisma.PrismaPromise<GetCartaconducaoAggregateType<T>>

    /**
     * Group by Cartaconducao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartaconducaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cartaconducaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cartaconducaoGroupByArgs['orderBy'] }
        : { orderBy?: cartaconducaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cartaconducaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartaconducaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cartaconducao model
   */
  readonly fields: cartaconducaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cartaconducao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cartaconducaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    automobilista<T extends cartaconducao$automobilistaArgs<ExtArgs> = {}>(args?: Subset<T, cartaconducao$automobilistaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$automobilistaPayload<ExtArgs>, T, "findMany"> | Null>
    categoriacarta<T extends categoriacartaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoriacartaDefaultArgs<ExtArgs>>): Prisma__categoriacartaClient<$Result.GetResult<Prisma.$categoriacartaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ficheiro<T extends ficheiroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ficheiroDefaultArgs<ExtArgs>>): Prisma__ficheiroClient<$Result.GetResult<Prisma.$ficheiroPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cartaconducao model
   */ 
  interface cartaconducaoFieldRefs {
    readonly codCartaConducao: FieldRef<"cartaconducao", 'Int'>
    readonly dataEmissao: FieldRef<"cartaconducao", 'DateTime'>
    readonly dataValidade: FieldRef<"cartaconducao", 'DateTime'>
    readonly numeroVia: FieldRef<"cartaconducao", 'String'>
    readonly codCategoriaCarta: FieldRef<"cartaconducao", 'Int'>
    readonly numeroCarta: FieldRef<"cartaconducao", 'Int'>
    readonly dataPrimeiraEmissao: FieldRef<"cartaconducao", 'DateTime'>
    readonly localEmissao: FieldRef<"cartaconducao", 'Int'>
    readonly codFicheiroCartaConducao: FieldRef<"cartaconducao", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * cartaconducao findUnique
   */
  export type cartaconducaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartaconducao
     */
    select?: cartaconducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartaconducaoInclude<ExtArgs> | null
    /**
     * Filter, which cartaconducao to fetch.
     */
    where: cartaconducaoWhereUniqueInput
  }

  /**
   * cartaconducao findUniqueOrThrow
   */
  export type cartaconducaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartaconducao
     */
    select?: cartaconducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartaconducaoInclude<ExtArgs> | null
    /**
     * Filter, which cartaconducao to fetch.
     */
    where: cartaconducaoWhereUniqueInput
  }

  /**
   * cartaconducao findFirst
   */
  export type cartaconducaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartaconducao
     */
    select?: cartaconducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartaconducaoInclude<ExtArgs> | null
    /**
     * Filter, which cartaconducao to fetch.
     */
    where?: cartaconducaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cartaconducaos to fetch.
     */
    orderBy?: cartaconducaoOrderByWithRelationInput | cartaconducaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cartaconducaos.
     */
    cursor?: cartaconducaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cartaconducaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cartaconducaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cartaconducaos.
     */
    distinct?: CartaconducaoScalarFieldEnum | CartaconducaoScalarFieldEnum[]
  }

  /**
   * cartaconducao findFirstOrThrow
   */
  export type cartaconducaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartaconducao
     */
    select?: cartaconducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartaconducaoInclude<ExtArgs> | null
    /**
     * Filter, which cartaconducao to fetch.
     */
    where?: cartaconducaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cartaconducaos to fetch.
     */
    orderBy?: cartaconducaoOrderByWithRelationInput | cartaconducaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cartaconducaos.
     */
    cursor?: cartaconducaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cartaconducaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cartaconducaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cartaconducaos.
     */
    distinct?: CartaconducaoScalarFieldEnum | CartaconducaoScalarFieldEnum[]
  }

  /**
   * cartaconducao findMany
   */
  export type cartaconducaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartaconducao
     */
    select?: cartaconducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartaconducaoInclude<ExtArgs> | null
    /**
     * Filter, which cartaconducaos to fetch.
     */
    where?: cartaconducaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cartaconducaos to fetch.
     */
    orderBy?: cartaconducaoOrderByWithRelationInput | cartaconducaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cartaconducaos.
     */
    cursor?: cartaconducaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cartaconducaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cartaconducaos.
     */
    skip?: number
    distinct?: CartaconducaoScalarFieldEnum | CartaconducaoScalarFieldEnum[]
  }

  /**
   * cartaconducao create
   */
  export type cartaconducaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartaconducao
     */
    select?: cartaconducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartaconducaoInclude<ExtArgs> | null
    /**
     * The data needed to create a cartaconducao.
     */
    data: XOR<cartaconducaoCreateInput, cartaconducaoUncheckedCreateInput>
  }

  /**
   * cartaconducao createMany
   */
  export type cartaconducaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cartaconducaos.
     */
    data: cartaconducaoCreateManyInput | cartaconducaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cartaconducao update
   */
  export type cartaconducaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartaconducao
     */
    select?: cartaconducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartaconducaoInclude<ExtArgs> | null
    /**
     * The data needed to update a cartaconducao.
     */
    data: XOR<cartaconducaoUpdateInput, cartaconducaoUncheckedUpdateInput>
    /**
     * Choose, which cartaconducao to update.
     */
    where: cartaconducaoWhereUniqueInput
  }

  /**
   * cartaconducao updateMany
   */
  export type cartaconducaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cartaconducaos.
     */
    data: XOR<cartaconducaoUpdateManyMutationInput, cartaconducaoUncheckedUpdateManyInput>
    /**
     * Filter which cartaconducaos to update
     */
    where?: cartaconducaoWhereInput
  }

  /**
   * cartaconducao upsert
   */
  export type cartaconducaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartaconducao
     */
    select?: cartaconducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartaconducaoInclude<ExtArgs> | null
    /**
     * The filter to search for the cartaconducao to update in case it exists.
     */
    where: cartaconducaoWhereUniqueInput
    /**
     * In case the cartaconducao found by the `where` argument doesn't exist, create a new cartaconducao with this data.
     */
    create: XOR<cartaconducaoCreateInput, cartaconducaoUncheckedCreateInput>
    /**
     * In case the cartaconducao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cartaconducaoUpdateInput, cartaconducaoUncheckedUpdateInput>
  }

  /**
   * cartaconducao delete
   */
  export type cartaconducaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartaconducao
     */
    select?: cartaconducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartaconducaoInclude<ExtArgs> | null
    /**
     * Filter which cartaconducao to delete.
     */
    where: cartaconducaoWhereUniqueInput
  }

  /**
   * cartaconducao deleteMany
   */
  export type cartaconducaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cartaconducaos to delete
     */
    where?: cartaconducaoWhereInput
  }

  /**
   * cartaconducao.automobilista
   */
  export type cartaconducao$automobilistaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the automobilista
     */
    select?: automobilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: automobilistaInclude<ExtArgs> | null
    where?: automobilistaWhereInput
    orderBy?: automobilistaOrderByWithRelationInput | automobilistaOrderByWithRelationInput[]
    cursor?: automobilistaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomobilistaScalarFieldEnum | AutomobilistaScalarFieldEnum[]
  }

  /**
   * cartaconducao without action
   */
  export type cartaconducaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartaconducao
     */
    select?: cartaconducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartaconducaoInclude<ExtArgs> | null
  }


  /**
   * Model categoriacarta
   */

  export type AggregateCategoriacarta = {
    _count: CategoriacartaCountAggregateOutputType | null
    _avg: CategoriacartaAvgAggregateOutputType | null
    _sum: CategoriacartaSumAggregateOutputType | null
    _min: CategoriacartaMinAggregateOutputType | null
    _max: CategoriacartaMaxAggregateOutputType | null
  }

  export type CategoriacartaAvgAggregateOutputType = {
    codCategoriaCarta: number | null
  }

  export type CategoriacartaSumAggregateOutputType = {
    codCategoriaCarta: number | null
  }

  export type CategoriacartaMinAggregateOutputType = {
    codCategoriaCarta: number | null
    descCategoriaCarta: string | null
    sigla: string | null
  }

  export type CategoriacartaMaxAggregateOutputType = {
    codCategoriaCarta: number | null
    descCategoriaCarta: string | null
    sigla: string | null
  }

  export type CategoriacartaCountAggregateOutputType = {
    codCategoriaCarta: number
    descCategoriaCarta: number
    sigla: number
    _all: number
  }


  export type CategoriacartaAvgAggregateInputType = {
    codCategoriaCarta?: true
  }

  export type CategoriacartaSumAggregateInputType = {
    codCategoriaCarta?: true
  }

  export type CategoriacartaMinAggregateInputType = {
    codCategoriaCarta?: true
    descCategoriaCarta?: true
    sigla?: true
  }

  export type CategoriacartaMaxAggregateInputType = {
    codCategoriaCarta?: true
    descCategoriaCarta?: true
    sigla?: true
  }

  export type CategoriacartaCountAggregateInputType = {
    codCategoriaCarta?: true
    descCategoriaCarta?: true
    sigla?: true
    _all?: true
  }

  export type CategoriacartaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categoriacarta to aggregate.
     */
    where?: categoriacartaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoriacartas to fetch.
     */
    orderBy?: categoriacartaOrderByWithRelationInput | categoriacartaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriacartaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoriacartas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoriacartas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categoriacartas
    **/
    _count?: true | CategoriacartaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriacartaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriacartaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriacartaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriacartaMaxAggregateInputType
  }

  export type GetCategoriacartaAggregateType<T extends CategoriacartaAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoriacarta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoriacarta[P]>
      : GetScalarType<T[P], AggregateCategoriacarta[P]>
  }




  export type categoriacartaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriacartaWhereInput
    orderBy?: categoriacartaOrderByWithAggregationInput | categoriacartaOrderByWithAggregationInput[]
    by: CategoriacartaScalarFieldEnum[] | CategoriacartaScalarFieldEnum
    having?: categoriacartaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriacartaCountAggregateInputType | true
    _avg?: CategoriacartaAvgAggregateInputType
    _sum?: CategoriacartaSumAggregateInputType
    _min?: CategoriacartaMinAggregateInputType
    _max?: CategoriacartaMaxAggregateInputType
  }

  export type CategoriacartaGroupByOutputType = {
    codCategoriaCarta: number
    descCategoriaCarta: string
    sigla: string
    _count: CategoriacartaCountAggregateOutputType | null
    _avg: CategoriacartaAvgAggregateOutputType | null
    _sum: CategoriacartaSumAggregateOutputType | null
    _min: CategoriacartaMinAggregateOutputType | null
    _max: CategoriacartaMaxAggregateOutputType | null
  }

  type GetCategoriacartaGroupByPayload<T extends categoriacartaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriacartaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriacartaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriacartaGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriacartaGroupByOutputType[P]>
        }
      >
    >


  export type categoriacartaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codCategoriaCarta?: boolean
    descCategoriaCarta?: boolean
    sigla?: boolean
    cartaconducao?: boolean | categoriacarta$cartaconducaoArgs<ExtArgs>
    _count?: boolean | CategoriacartaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoriacarta"]>


  export type categoriacartaSelectScalar = {
    codCategoriaCarta?: boolean
    descCategoriaCarta?: boolean
    sigla?: boolean
  }

  export type categoriacartaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cartaconducao?: boolean | categoriacarta$cartaconducaoArgs<ExtArgs>
    _count?: boolean | CategoriacartaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $categoriacartaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categoriacarta"
    objects: {
      cartaconducao: Prisma.$cartaconducaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      codCategoriaCarta: number
      descCategoriaCarta: string
      sigla: string
    }, ExtArgs["result"]["categoriacarta"]>
    composites: {}
  }

  type categoriacartaGetPayload<S extends boolean | null | undefined | categoriacartaDefaultArgs> = $Result.GetResult<Prisma.$categoriacartaPayload, S>

  type categoriacartaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<categoriacartaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoriacartaCountAggregateInputType | true
    }

  export interface categoriacartaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categoriacarta'], meta: { name: 'categoriacarta' } }
    /**
     * Find zero or one Categoriacarta that matches the filter.
     * @param {categoriacartaFindUniqueArgs} args - Arguments to find a Categoriacarta
     * @example
     * // Get one Categoriacarta
     * const categoriacarta = await prisma.categoriacarta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoriacartaFindUniqueArgs>(args: SelectSubset<T, categoriacartaFindUniqueArgs<ExtArgs>>): Prisma__categoriacartaClient<$Result.GetResult<Prisma.$categoriacartaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Categoriacarta that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {categoriacartaFindUniqueOrThrowArgs} args - Arguments to find a Categoriacarta
     * @example
     * // Get one Categoriacarta
     * const categoriacarta = await prisma.categoriacarta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoriacartaFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriacartaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriacartaClient<$Result.GetResult<Prisma.$categoriacartaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Categoriacarta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriacartaFindFirstArgs} args - Arguments to find a Categoriacarta
     * @example
     * // Get one Categoriacarta
     * const categoriacarta = await prisma.categoriacarta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoriacartaFindFirstArgs>(args?: SelectSubset<T, categoriacartaFindFirstArgs<ExtArgs>>): Prisma__categoriacartaClient<$Result.GetResult<Prisma.$categoriacartaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Categoriacarta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriacartaFindFirstOrThrowArgs} args - Arguments to find a Categoriacarta
     * @example
     * // Get one Categoriacarta
     * const categoriacarta = await prisma.categoriacarta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoriacartaFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriacartaFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriacartaClient<$Result.GetResult<Prisma.$categoriacartaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categoriacartas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriacartaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categoriacartas
     * const categoriacartas = await prisma.categoriacarta.findMany()
     * 
     * // Get first 10 Categoriacartas
     * const categoriacartas = await prisma.categoriacarta.findMany({ take: 10 })
     * 
     * // Only select the `codCategoriaCarta`
     * const categoriacartaWithCodCategoriaCartaOnly = await prisma.categoriacarta.findMany({ select: { codCategoriaCarta: true } })
     * 
     */
    findMany<T extends categoriacartaFindManyArgs>(args?: SelectSubset<T, categoriacartaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriacartaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Categoriacarta.
     * @param {categoriacartaCreateArgs} args - Arguments to create a Categoriacarta.
     * @example
     * // Create one Categoriacarta
     * const Categoriacarta = await prisma.categoriacarta.create({
     *   data: {
     *     // ... data to create a Categoriacarta
     *   }
     * })
     * 
     */
    create<T extends categoriacartaCreateArgs>(args: SelectSubset<T, categoriacartaCreateArgs<ExtArgs>>): Prisma__categoriacartaClient<$Result.GetResult<Prisma.$categoriacartaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categoriacartas.
     * @param {categoriacartaCreateManyArgs} args - Arguments to create many Categoriacartas.
     * @example
     * // Create many Categoriacartas
     * const categoriacarta = await prisma.categoriacarta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoriacartaCreateManyArgs>(args?: SelectSubset<T, categoriacartaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Categoriacarta.
     * @param {categoriacartaDeleteArgs} args - Arguments to delete one Categoriacarta.
     * @example
     * // Delete one Categoriacarta
     * const Categoriacarta = await prisma.categoriacarta.delete({
     *   where: {
     *     // ... filter to delete one Categoriacarta
     *   }
     * })
     * 
     */
    delete<T extends categoriacartaDeleteArgs>(args: SelectSubset<T, categoriacartaDeleteArgs<ExtArgs>>): Prisma__categoriacartaClient<$Result.GetResult<Prisma.$categoriacartaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Categoriacarta.
     * @param {categoriacartaUpdateArgs} args - Arguments to update one Categoriacarta.
     * @example
     * // Update one Categoriacarta
     * const categoriacarta = await prisma.categoriacarta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoriacartaUpdateArgs>(args: SelectSubset<T, categoriacartaUpdateArgs<ExtArgs>>): Prisma__categoriacartaClient<$Result.GetResult<Prisma.$categoriacartaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categoriacartas.
     * @param {categoriacartaDeleteManyArgs} args - Arguments to filter Categoriacartas to delete.
     * @example
     * // Delete a few Categoriacartas
     * const { count } = await prisma.categoriacarta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoriacartaDeleteManyArgs>(args?: SelectSubset<T, categoriacartaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categoriacartas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriacartaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categoriacartas
     * const categoriacarta = await prisma.categoriacarta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoriacartaUpdateManyArgs>(args: SelectSubset<T, categoriacartaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categoriacarta.
     * @param {categoriacartaUpsertArgs} args - Arguments to update or create a Categoriacarta.
     * @example
     * // Update or create a Categoriacarta
     * const categoriacarta = await prisma.categoriacarta.upsert({
     *   create: {
     *     // ... data to create a Categoriacarta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoriacarta we want to update
     *   }
     * })
     */
    upsert<T extends categoriacartaUpsertArgs>(args: SelectSubset<T, categoriacartaUpsertArgs<ExtArgs>>): Prisma__categoriacartaClient<$Result.GetResult<Prisma.$categoriacartaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categoriacartas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriacartaCountArgs} args - Arguments to filter Categoriacartas to count.
     * @example
     * // Count the number of Categoriacartas
     * const count = await prisma.categoriacarta.count({
     *   where: {
     *     // ... the filter for the Categoriacartas we want to count
     *   }
     * })
    **/
    count<T extends categoriacartaCountArgs>(
      args?: Subset<T, categoriacartaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriacartaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoriacarta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriacartaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriacartaAggregateArgs>(args: Subset<T, CategoriacartaAggregateArgs>): Prisma.PrismaPromise<GetCategoriacartaAggregateType<T>>

    /**
     * Group by Categoriacarta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriacartaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriacartaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriacartaGroupByArgs['orderBy'] }
        : { orderBy?: categoriacartaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriacartaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriacartaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categoriacarta model
   */
  readonly fields: categoriacartaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categoriacarta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriacartaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cartaconducao<T extends categoriacarta$cartaconducaoArgs<ExtArgs> = {}>(args?: Subset<T, categoriacarta$cartaconducaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cartaconducaoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the categoriacarta model
   */ 
  interface categoriacartaFieldRefs {
    readonly codCategoriaCarta: FieldRef<"categoriacarta", 'Int'>
    readonly descCategoriaCarta: FieldRef<"categoriacarta", 'String'>
    readonly sigla: FieldRef<"categoriacarta", 'String'>
  }
    

  // Custom InputTypes
  /**
   * categoriacarta findUnique
   */
  export type categoriacartaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriacarta
     */
    select?: categoriacartaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriacartaInclude<ExtArgs> | null
    /**
     * Filter, which categoriacarta to fetch.
     */
    where: categoriacartaWhereUniqueInput
  }

  /**
   * categoriacarta findUniqueOrThrow
   */
  export type categoriacartaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriacarta
     */
    select?: categoriacartaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriacartaInclude<ExtArgs> | null
    /**
     * Filter, which categoriacarta to fetch.
     */
    where: categoriacartaWhereUniqueInput
  }

  /**
   * categoriacarta findFirst
   */
  export type categoriacartaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriacarta
     */
    select?: categoriacartaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriacartaInclude<ExtArgs> | null
    /**
     * Filter, which categoriacarta to fetch.
     */
    where?: categoriacartaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoriacartas to fetch.
     */
    orderBy?: categoriacartaOrderByWithRelationInput | categoriacartaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categoriacartas.
     */
    cursor?: categoriacartaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoriacartas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoriacartas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categoriacartas.
     */
    distinct?: CategoriacartaScalarFieldEnum | CategoriacartaScalarFieldEnum[]
  }

  /**
   * categoriacarta findFirstOrThrow
   */
  export type categoriacartaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriacarta
     */
    select?: categoriacartaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriacartaInclude<ExtArgs> | null
    /**
     * Filter, which categoriacarta to fetch.
     */
    where?: categoriacartaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoriacartas to fetch.
     */
    orderBy?: categoriacartaOrderByWithRelationInput | categoriacartaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categoriacartas.
     */
    cursor?: categoriacartaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoriacartas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoriacartas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categoriacartas.
     */
    distinct?: CategoriacartaScalarFieldEnum | CategoriacartaScalarFieldEnum[]
  }

  /**
   * categoriacarta findMany
   */
  export type categoriacartaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriacarta
     */
    select?: categoriacartaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriacartaInclude<ExtArgs> | null
    /**
     * Filter, which categoriacartas to fetch.
     */
    where?: categoriacartaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categoriacartas to fetch.
     */
    orderBy?: categoriacartaOrderByWithRelationInput | categoriacartaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categoriacartas.
     */
    cursor?: categoriacartaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categoriacartas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categoriacartas.
     */
    skip?: number
    distinct?: CategoriacartaScalarFieldEnum | CategoriacartaScalarFieldEnum[]
  }

  /**
   * categoriacarta create
   */
  export type categoriacartaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriacarta
     */
    select?: categoriacartaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriacartaInclude<ExtArgs> | null
    /**
     * The data needed to create a categoriacarta.
     */
    data: XOR<categoriacartaCreateInput, categoriacartaUncheckedCreateInput>
  }

  /**
   * categoriacarta createMany
   */
  export type categoriacartaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categoriacartas.
     */
    data: categoriacartaCreateManyInput | categoriacartaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categoriacarta update
   */
  export type categoriacartaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriacarta
     */
    select?: categoriacartaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriacartaInclude<ExtArgs> | null
    /**
     * The data needed to update a categoriacarta.
     */
    data: XOR<categoriacartaUpdateInput, categoriacartaUncheckedUpdateInput>
    /**
     * Choose, which categoriacarta to update.
     */
    where: categoriacartaWhereUniqueInput
  }

  /**
   * categoriacarta updateMany
   */
  export type categoriacartaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categoriacartas.
     */
    data: XOR<categoriacartaUpdateManyMutationInput, categoriacartaUncheckedUpdateManyInput>
    /**
     * Filter which categoriacartas to update
     */
    where?: categoriacartaWhereInput
  }

  /**
   * categoriacarta upsert
   */
  export type categoriacartaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriacarta
     */
    select?: categoriacartaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriacartaInclude<ExtArgs> | null
    /**
     * The filter to search for the categoriacarta to update in case it exists.
     */
    where: categoriacartaWhereUniqueInput
    /**
     * In case the categoriacarta found by the `where` argument doesn't exist, create a new categoriacarta with this data.
     */
    create: XOR<categoriacartaCreateInput, categoriacartaUncheckedCreateInput>
    /**
     * In case the categoriacarta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriacartaUpdateInput, categoriacartaUncheckedUpdateInput>
  }

  /**
   * categoriacarta delete
   */
  export type categoriacartaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriacarta
     */
    select?: categoriacartaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriacartaInclude<ExtArgs> | null
    /**
     * Filter which categoriacarta to delete.
     */
    where: categoriacartaWhereUniqueInput
  }

  /**
   * categoriacarta deleteMany
   */
  export type categoriacartaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categoriacartas to delete
     */
    where?: categoriacartaWhereInput
  }

  /**
   * categoriacarta.cartaconducao
   */
  export type categoriacarta$cartaconducaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartaconducao
     */
    select?: cartaconducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartaconducaoInclude<ExtArgs> | null
    where?: cartaconducaoWhereInput
    orderBy?: cartaconducaoOrderByWithRelationInput | cartaconducaoOrderByWithRelationInput[]
    cursor?: cartaconducaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartaconducaoScalarFieldEnum | CartaconducaoScalarFieldEnum[]
  }

  /**
   * categoriacarta without action
   */
  export type categoriacartaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoriacarta
     */
    select?: categoriacartaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriacartaInclude<ExtArgs> | null
  }


  /**
   * Model contacto
   */

  export type AggregateContacto = {
    _count: ContactoCountAggregateOutputType | null
    _avg: ContactoAvgAggregateOutputType | null
    _sum: ContactoSumAggregateOutputType | null
    _min: ContactoMinAggregateOutputType | null
    _max: ContactoMaxAggregateOutputType | null
  }

  export type ContactoAvgAggregateOutputType = {
    idContacto: number | null
  }

  export type ContactoSumAggregateOutputType = {
    idContacto: number | null
  }

  export type ContactoMinAggregateOutputType = {
    idContacto: number | null
    contacto1: string | null
    contacto2: string | null
    email1: string | null
    email2: string | null
  }

  export type ContactoMaxAggregateOutputType = {
    idContacto: number | null
    contacto1: string | null
    contacto2: string | null
    email1: string | null
    email2: string | null
  }

  export type ContactoCountAggregateOutputType = {
    idContacto: number
    contacto1: number
    contacto2: number
    email1: number
    email2: number
    _all: number
  }


  export type ContactoAvgAggregateInputType = {
    idContacto?: true
  }

  export type ContactoSumAggregateInputType = {
    idContacto?: true
  }

  export type ContactoMinAggregateInputType = {
    idContacto?: true
    contacto1?: true
    contacto2?: true
    email1?: true
    email2?: true
  }

  export type ContactoMaxAggregateInputType = {
    idContacto?: true
    contacto1?: true
    contacto2?: true
    email1?: true
    email2?: true
  }

  export type ContactoCountAggregateInputType = {
    idContacto?: true
    contacto1?: true
    contacto2?: true
    email1?: true
    email2?: true
    _all?: true
  }

  export type ContactoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contacto to aggregate.
     */
    where?: contactoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contactos to fetch.
     */
    orderBy?: contactoOrderByWithRelationInput | contactoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contactoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contactos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contactos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contactos
    **/
    _count?: true | ContactoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactoMaxAggregateInputType
  }

  export type GetContactoAggregateType<T extends ContactoAggregateArgs> = {
        [P in keyof T & keyof AggregateContacto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContacto[P]>
      : GetScalarType<T[P], AggregateContacto[P]>
  }




  export type contactoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactoWhereInput
    orderBy?: contactoOrderByWithAggregationInput | contactoOrderByWithAggregationInput[]
    by: ContactoScalarFieldEnum[] | ContactoScalarFieldEnum
    having?: contactoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactoCountAggregateInputType | true
    _avg?: ContactoAvgAggregateInputType
    _sum?: ContactoSumAggregateInputType
    _min?: ContactoMinAggregateInputType
    _max?: ContactoMaxAggregateInputType
  }

  export type ContactoGroupByOutputType = {
    idContacto: number
    contacto1: string
    contacto2: string | null
    email1: string | null
    email2: string | null
    _count: ContactoCountAggregateOutputType | null
    _avg: ContactoAvgAggregateOutputType | null
    _sum: ContactoSumAggregateOutputType | null
    _min: ContactoMinAggregateOutputType | null
    _max: ContactoMaxAggregateOutputType | null
  }

  type GetContactoGroupByPayload<T extends contactoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactoGroupByOutputType[P]>
            : GetScalarType<T[P], ContactoGroupByOutputType[P]>
        }
      >
    >


  export type contactoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idContacto?: boolean
    contacto1?: boolean
    contacto2?: boolean
    email1?: boolean
    email2?: boolean
    pessoa?: boolean | contacto$pessoaArgs<ExtArgs>
    _count?: boolean | ContactoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contacto"]>


  export type contactoSelectScalar = {
    idContacto?: boolean
    contacto1?: boolean
    contacto2?: boolean
    email1?: boolean
    email2?: boolean
  }

  export type contactoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | contacto$pessoaArgs<ExtArgs>
    _count?: boolean | ContactoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $contactoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contacto"
    objects: {
      pessoa: Prisma.$pessoaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idContacto: number
      contacto1: string
      contacto2: string | null
      email1: string | null
      email2: string | null
    }, ExtArgs["result"]["contacto"]>
    composites: {}
  }

  type contactoGetPayload<S extends boolean | null | undefined | contactoDefaultArgs> = $Result.GetResult<Prisma.$contactoPayload, S>

  type contactoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<contactoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactoCountAggregateInputType | true
    }

  export interface contactoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contacto'], meta: { name: 'contacto' } }
    /**
     * Find zero or one Contacto that matches the filter.
     * @param {contactoFindUniqueArgs} args - Arguments to find a Contacto
     * @example
     * // Get one Contacto
     * const contacto = await prisma.contacto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends contactoFindUniqueArgs>(args: SelectSubset<T, contactoFindUniqueArgs<ExtArgs>>): Prisma__contactoClient<$Result.GetResult<Prisma.$contactoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contacto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {contactoFindUniqueOrThrowArgs} args - Arguments to find a Contacto
     * @example
     * // Get one Contacto
     * const contacto = await prisma.contacto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends contactoFindUniqueOrThrowArgs>(args: SelectSubset<T, contactoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__contactoClient<$Result.GetResult<Prisma.$contactoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contacto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactoFindFirstArgs} args - Arguments to find a Contacto
     * @example
     * // Get one Contacto
     * const contacto = await prisma.contacto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends contactoFindFirstArgs>(args?: SelectSubset<T, contactoFindFirstArgs<ExtArgs>>): Prisma__contactoClient<$Result.GetResult<Prisma.$contactoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contacto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactoFindFirstOrThrowArgs} args - Arguments to find a Contacto
     * @example
     * // Get one Contacto
     * const contacto = await prisma.contacto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends contactoFindFirstOrThrowArgs>(args?: SelectSubset<T, contactoFindFirstOrThrowArgs<ExtArgs>>): Prisma__contactoClient<$Result.GetResult<Prisma.$contactoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contactos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contactos
     * const contactos = await prisma.contacto.findMany()
     * 
     * // Get first 10 Contactos
     * const contactos = await prisma.contacto.findMany({ take: 10 })
     * 
     * // Only select the `idContacto`
     * const contactoWithIdContactoOnly = await prisma.contacto.findMany({ select: { idContacto: true } })
     * 
     */
    findMany<T extends contactoFindManyArgs>(args?: SelectSubset<T, contactoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contacto.
     * @param {contactoCreateArgs} args - Arguments to create a Contacto.
     * @example
     * // Create one Contacto
     * const Contacto = await prisma.contacto.create({
     *   data: {
     *     // ... data to create a Contacto
     *   }
     * })
     * 
     */
    create<T extends contactoCreateArgs>(args: SelectSubset<T, contactoCreateArgs<ExtArgs>>): Prisma__contactoClient<$Result.GetResult<Prisma.$contactoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contactos.
     * @param {contactoCreateManyArgs} args - Arguments to create many Contactos.
     * @example
     * // Create many Contactos
     * const contacto = await prisma.contacto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends contactoCreateManyArgs>(args?: SelectSubset<T, contactoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contacto.
     * @param {contactoDeleteArgs} args - Arguments to delete one Contacto.
     * @example
     * // Delete one Contacto
     * const Contacto = await prisma.contacto.delete({
     *   where: {
     *     // ... filter to delete one Contacto
     *   }
     * })
     * 
     */
    delete<T extends contactoDeleteArgs>(args: SelectSubset<T, contactoDeleteArgs<ExtArgs>>): Prisma__contactoClient<$Result.GetResult<Prisma.$contactoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contacto.
     * @param {contactoUpdateArgs} args - Arguments to update one Contacto.
     * @example
     * // Update one Contacto
     * const contacto = await prisma.contacto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends contactoUpdateArgs>(args: SelectSubset<T, contactoUpdateArgs<ExtArgs>>): Prisma__contactoClient<$Result.GetResult<Prisma.$contactoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contactos.
     * @param {contactoDeleteManyArgs} args - Arguments to filter Contactos to delete.
     * @example
     * // Delete a few Contactos
     * const { count } = await prisma.contacto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends contactoDeleteManyArgs>(args?: SelectSubset<T, contactoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contactos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contactos
     * const contacto = await prisma.contacto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends contactoUpdateManyArgs>(args: SelectSubset<T, contactoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contacto.
     * @param {contactoUpsertArgs} args - Arguments to update or create a Contacto.
     * @example
     * // Update or create a Contacto
     * const contacto = await prisma.contacto.upsert({
     *   create: {
     *     // ... data to create a Contacto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contacto we want to update
     *   }
     * })
     */
    upsert<T extends contactoUpsertArgs>(args: SelectSubset<T, contactoUpsertArgs<ExtArgs>>): Prisma__contactoClient<$Result.GetResult<Prisma.$contactoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contactos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactoCountArgs} args - Arguments to filter Contactos to count.
     * @example
     * // Count the number of Contactos
     * const count = await prisma.contacto.count({
     *   where: {
     *     // ... the filter for the Contactos we want to count
     *   }
     * })
    **/
    count<T extends contactoCountArgs>(
      args?: Subset<T, contactoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contacto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactoAggregateArgs>(args: Subset<T, ContactoAggregateArgs>): Prisma.PrismaPromise<GetContactoAggregateType<T>>

    /**
     * Group by Contacto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contactoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contactoGroupByArgs['orderBy'] }
        : { orderBy?: contactoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contactoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contacto model
   */
  readonly fields: contactoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contacto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contactoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoa<T extends contacto$pessoaArgs<ExtArgs> = {}>(args?: Subset<T, contacto$pessoaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the contacto model
   */ 
  interface contactoFieldRefs {
    readonly idContacto: FieldRef<"contacto", 'Int'>
    readonly contacto1: FieldRef<"contacto", 'String'>
    readonly contacto2: FieldRef<"contacto", 'String'>
    readonly email1: FieldRef<"contacto", 'String'>
    readonly email2: FieldRef<"contacto", 'String'>
  }
    

  // Custom InputTypes
  /**
   * contacto findUnique
   */
  export type contactoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacto
     */
    select?: contactoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactoInclude<ExtArgs> | null
    /**
     * Filter, which contacto to fetch.
     */
    where: contactoWhereUniqueInput
  }

  /**
   * contacto findUniqueOrThrow
   */
  export type contactoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacto
     */
    select?: contactoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactoInclude<ExtArgs> | null
    /**
     * Filter, which contacto to fetch.
     */
    where: contactoWhereUniqueInput
  }

  /**
   * contacto findFirst
   */
  export type contactoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacto
     */
    select?: contactoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactoInclude<ExtArgs> | null
    /**
     * Filter, which contacto to fetch.
     */
    where?: contactoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contactos to fetch.
     */
    orderBy?: contactoOrderByWithRelationInput | contactoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contactos.
     */
    cursor?: contactoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contactos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contactos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contactos.
     */
    distinct?: ContactoScalarFieldEnum | ContactoScalarFieldEnum[]
  }

  /**
   * contacto findFirstOrThrow
   */
  export type contactoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacto
     */
    select?: contactoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactoInclude<ExtArgs> | null
    /**
     * Filter, which contacto to fetch.
     */
    where?: contactoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contactos to fetch.
     */
    orderBy?: contactoOrderByWithRelationInput | contactoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contactos.
     */
    cursor?: contactoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contactos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contactos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contactos.
     */
    distinct?: ContactoScalarFieldEnum | ContactoScalarFieldEnum[]
  }

  /**
   * contacto findMany
   */
  export type contactoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacto
     */
    select?: contactoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactoInclude<ExtArgs> | null
    /**
     * Filter, which contactos to fetch.
     */
    where?: contactoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contactos to fetch.
     */
    orderBy?: contactoOrderByWithRelationInput | contactoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contactos.
     */
    cursor?: contactoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contactos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contactos.
     */
    skip?: number
    distinct?: ContactoScalarFieldEnum | ContactoScalarFieldEnum[]
  }

  /**
   * contacto create
   */
  export type contactoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacto
     */
    select?: contactoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactoInclude<ExtArgs> | null
    /**
     * The data needed to create a contacto.
     */
    data: XOR<contactoCreateInput, contactoUncheckedCreateInput>
  }

  /**
   * contacto createMany
   */
  export type contactoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contactos.
     */
    data: contactoCreateManyInput | contactoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * contacto update
   */
  export type contactoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacto
     */
    select?: contactoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactoInclude<ExtArgs> | null
    /**
     * The data needed to update a contacto.
     */
    data: XOR<contactoUpdateInput, contactoUncheckedUpdateInput>
    /**
     * Choose, which contacto to update.
     */
    where: contactoWhereUniqueInput
  }

  /**
   * contacto updateMany
   */
  export type contactoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contactos.
     */
    data: XOR<contactoUpdateManyMutationInput, contactoUncheckedUpdateManyInput>
    /**
     * Filter which contactos to update
     */
    where?: contactoWhereInput
  }

  /**
   * contacto upsert
   */
  export type contactoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacto
     */
    select?: contactoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactoInclude<ExtArgs> | null
    /**
     * The filter to search for the contacto to update in case it exists.
     */
    where: contactoWhereUniqueInput
    /**
     * In case the contacto found by the `where` argument doesn't exist, create a new contacto with this data.
     */
    create: XOR<contactoCreateInput, contactoUncheckedCreateInput>
    /**
     * In case the contacto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contactoUpdateInput, contactoUncheckedUpdateInput>
  }

  /**
   * contacto delete
   */
  export type contactoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacto
     */
    select?: contactoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactoInclude<ExtArgs> | null
    /**
     * Filter which contacto to delete.
     */
    where: contactoWhereUniqueInput
  }

  /**
   * contacto deleteMany
   */
  export type contactoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contactos to delete
     */
    where?: contactoWhereInput
  }

  /**
   * contacto.pessoa
   */
  export type contacto$pessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    where?: pessoaWhereInput
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    cursor?: pessoaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * contacto without action
   */
  export type contactoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacto
     */
    select?: contactoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactoInclude<ExtArgs> | null
  }


  /**
   * Model endereco
   */

  export type AggregateEndereco = {
    _count: EnderecoCountAggregateOutputType | null
    _avg: EnderecoAvgAggregateOutputType | null
    _sum: EnderecoSumAggregateOutputType | null
    _min: EnderecoMinAggregateOutputType | null
    _max: EnderecoMaxAggregateOutputType | null
  }

  export type EnderecoAvgAggregateOutputType = {
    idEndereco: number | null
    idMunicipio: number | null
  }

  export type EnderecoSumAggregateOutputType = {
    idEndereco: number | null
    idMunicipio: number | null
  }

  export type EnderecoMinAggregateOutputType = {
    idEndereco: number | null
    idMunicipio: number | null
    descricaoEndereco: string | null
  }

  export type EnderecoMaxAggregateOutputType = {
    idEndereco: number | null
    idMunicipio: number | null
    descricaoEndereco: string | null
  }

  export type EnderecoCountAggregateOutputType = {
    idEndereco: number
    idMunicipio: number
    descricaoEndereco: number
    _all: number
  }


  export type EnderecoAvgAggregateInputType = {
    idEndereco?: true
    idMunicipio?: true
  }

  export type EnderecoSumAggregateInputType = {
    idEndereco?: true
    idMunicipio?: true
  }

  export type EnderecoMinAggregateInputType = {
    idEndereco?: true
    idMunicipio?: true
    descricaoEndereco?: true
  }

  export type EnderecoMaxAggregateInputType = {
    idEndereco?: true
    idMunicipio?: true
    descricaoEndereco?: true
  }

  export type EnderecoCountAggregateInputType = {
    idEndereco?: true
    idMunicipio?: true
    descricaoEndereco?: true
    _all?: true
  }

  export type EnderecoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which endereco to aggregate.
     */
    where?: enderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enderecos to fetch.
     */
    orderBy?: enderecoOrderByWithRelationInput | enderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: enderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned enderecos
    **/
    _count?: true | EnderecoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnderecoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnderecoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnderecoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnderecoMaxAggregateInputType
  }

  export type GetEnderecoAggregateType<T extends EnderecoAggregateArgs> = {
        [P in keyof T & keyof AggregateEndereco]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEndereco[P]>
      : GetScalarType<T[P], AggregateEndereco[P]>
  }




  export type enderecoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enderecoWhereInput
    orderBy?: enderecoOrderByWithAggregationInput | enderecoOrderByWithAggregationInput[]
    by: EnderecoScalarFieldEnum[] | EnderecoScalarFieldEnum
    having?: enderecoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnderecoCountAggregateInputType | true
    _avg?: EnderecoAvgAggregateInputType
    _sum?: EnderecoSumAggregateInputType
    _min?: EnderecoMinAggregateInputType
    _max?: EnderecoMaxAggregateInputType
  }

  export type EnderecoGroupByOutputType = {
    idEndereco: number
    idMunicipio: number
    descricaoEndereco: string
    _count: EnderecoCountAggregateOutputType | null
    _avg: EnderecoAvgAggregateOutputType | null
    _sum: EnderecoSumAggregateOutputType | null
    _min: EnderecoMinAggregateOutputType | null
    _max: EnderecoMaxAggregateOutputType | null
  }

  type GetEnderecoGroupByPayload<T extends enderecoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnderecoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnderecoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnderecoGroupByOutputType[P]>
            : GetScalarType<T[P], EnderecoGroupByOutputType[P]>
        }
      >
    >


  export type enderecoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idEndereco?: boolean
    idMunicipio?: boolean
    descricaoEndereco?: boolean
    municipio?: boolean | municipioDefaultArgs<ExtArgs>
    pessoa?: boolean | endereco$pessoaArgs<ExtArgs>
    _count?: boolean | EnderecoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["endereco"]>


  export type enderecoSelectScalar = {
    idEndereco?: boolean
    idMunicipio?: boolean
    descricaoEndereco?: boolean
  }

  export type enderecoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipio?: boolean | municipioDefaultArgs<ExtArgs>
    pessoa?: boolean | endereco$pessoaArgs<ExtArgs>
    _count?: boolean | EnderecoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $enderecoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "endereco"
    objects: {
      municipio: Prisma.$municipioPayload<ExtArgs>
      pessoa: Prisma.$pessoaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idEndereco: number
      idMunicipio: number
      descricaoEndereco: string
    }, ExtArgs["result"]["endereco"]>
    composites: {}
  }

  type enderecoGetPayload<S extends boolean | null | undefined | enderecoDefaultArgs> = $Result.GetResult<Prisma.$enderecoPayload, S>

  type enderecoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<enderecoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnderecoCountAggregateInputType | true
    }

  export interface enderecoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['endereco'], meta: { name: 'endereco' } }
    /**
     * Find zero or one Endereco that matches the filter.
     * @param {enderecoFindUniqueArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends enderecoFindUniqueArgs>(args: SelectSubset<T, enderecoFindUniqueArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Endereco that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {enderecoFindUniqueOrThrowArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends enderecoFindUniqueOrThrowArgs>(args: SelectSubset<T, enderecoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Endereco that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enderecoFindFirstArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends enderecoFindFirstArgs>(args?: SelectSubset<T, enderecoFindFirstArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Endereco that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enderecoFindFirstOrThrowArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends enderecoFindFirstOrThrowArgs>(args?: SelectSubset<T, enderecoFindFirstOrThrowArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Enderecos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enderecoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enderecos
     * const enderecos = await prisma.endereco.findMany()
     * 
     * // Get first 10 Enderecos
     * const enderecos = await prisma.endereco.findMany({ take: 10 })
     * 
     * // Only select the `idEndereco`
     * const enderecoWithIdEnderecoOnly = await prisma.endereco.findMany({ select: { idEndereco: true } })
     * 
     */
    findMany<T extends enderecoFindManyArgs>(args?: SelectSubset<T, enderecoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Endereco.
     * @param {enderecoCreateArgs} args - Arguments to create a Endereco.
     * @example
     * // Create one Endereco
     * const Endereco = await prisma.endereco.create({
     *   data: {
     *     // ... data to create a Endereco
     *   }
     * })
     * 
     */
    create<T extends enderecoCreateArgs>(args: SelectSubset<T, enderecoCreateArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Enderecos.
     * @param {enderecoCreateManyArgs} args - Arguments to create many Enderecos.
     * @example
     * // Create many Enderecos
     * const endereco = await prisma.endereco.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends enderecoCreateManyArgs>(args?: SelectSubset<T, enderecoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Endereco.
     * @param {enderecoDeleteArgs} args - Arguments to delete one Endereco.
     * @example
     * // Delete one Endereco
     * const Endereco = await prisma.endereco.delete({
     *   where: {
     *     // ... filter to delete one Endereco
     *   }
     * })
     * 
     */
    delete<T extends enderecoDeleteArgs>(args: SelectSubset<T, enderecoDeleteArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Endereco.
     * @param {enderecoUpdateArgs} args - Arguments to update one Endereco.
     * @example
     * // Update one Endereco
     * const endereco = await prisma.endereco.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends enderecoUpdateArgs>(args: SelectSubset<T, enderecoUpdateArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Enderecos.
     * @param {enderecoDeleteManyArgs} args - Arguments to filter Enderecos to delete.
     * @example
     * // Delete a few Enderecos
     * const { count } = await prisma.endereco.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends enderecoDeleteManyArgs>(args?: SelectSubset<T, enderecoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enderecos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enderecoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enderecos
     * const endereco = await prisma.endereco.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends enderecoUpdateManyArgs>(args: SelectSubset<T, enderecoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Endereco.
     * @param {enderecoUpsertArgs} args - Arguments to update or create a Endereco.
     * @example
     * // Update or create a Endereco
     * const endereco = await prisma.endereco.upsert({
     *   create: {
     *     // ... data to create a Endereco
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Endereco we want to update
     *   }
     * })
     */
    upsert<T extends enderecoUpsertArgs>(args: SelectSubset<T, enderecoUpsertArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Enderecos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enderecoCountArgs} args - Arguments to filter Enderecos to count.
     * @example
     * // Count the number of Enderecos
     * const count = await prisma.endereco.count({
     *   where: {
     *     // ... the filter for the Enderecos we want to count
     *   }
     * })
    **/
    count<T extends enderecoCountArgs>(
      args?: Subset<T, enderecoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnderecoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Endereco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnderecoAggregateArgs>(args: Subset<T, EnderecoAggregateArgs>): Prisma.PrismaPromise<GetEnderecoAggregateType<T>>

    /**
     * Group by Endereco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enderecoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends enderecoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: enderecoGroupByArgs['orderBy'] }
        : { orderBy?: enderecoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, enderecoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnderecoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the endereco model
   */
  readonly fields: enderecoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for endereco.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__enderecoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    municipio<T extends municipioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, municipioDefaultArgs<ExtArgs>>): Prisma__municipioClient<$Result.GetResult<Prisma.$municipioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pessoa<T extends endereco$pessoaArgs<ExtArgs> = {}>(args?: Subset<T, endereco$pessoaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the endereco model
   */ 
  interface enderecoFieldRefs {
    readonly idEndereco: FieldRef<"endereco", 'Int'>
    readonly idMunicipio: FieldRef<"endereco", 'Int'>
    readonly descricaoEndereco: FieldRef<"endereco", 'String'>
  }
    

  // Custom InputTypes
  /**
   * endereco findUnique
   */
  export type enderecoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * Filter, which endereco to fetch.
     */
    where: enderecoWhereUniqueInput
  }

  /**
   * endereco findUniqueOrThrow
   */
  export type enderecoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * Filter, which endereco to fetch.
     */
    where: enderecoWhereUniqueInput
  }

  /**
   * endereco findFirst
   */
  export type enderecoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * Filter, which endereco to fetch.
     */
    where?: enderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enderecos to fetch.
     */
    orderBy?: enderecoOrderByWithRelationInput | enderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for enderecos.
     */
    cursor?: enderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of enderecos.
     */
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * endereco findFirstOrThrow
   */
  export type enderecoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * Filter, which endereco to fetch.
     */
    where?: enderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enderecos to fetch.
     */
    orderBy?: enderecoOrderByWithRelationInput | enderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for enderecos.
     */
    cursor?: enderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of enderecos.
     */
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * endereco findMany
   */
  export type enderecoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * Filter, which enderecos to fetch.
     */
    where?: enderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enderecos to fetch.
     */
    orderBy?: enderecoOrderByWithRelationInput | enderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing enderecos.
     */
    cursor?: enderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enderecos.
     */
    skip?: number
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * endereco create
   */
  export type enderecoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * The data needed to create a endereco.
     */
    data: XOR<enderecoCreateInput, enderecoUncheckedCreateInput>
  }

  /**
   * endereco createMany
   */
  export type enderecoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many enderecos.
     */
    data: enderecoCreateManyInput | enderecoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * endereco update
   */
  export type enderecoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * The data needed to update a endereco.
     */
    data: XOR<enderecoUpdateInput, enderecoUncheckedUpdateInput>
    /**
     * Choose, which endereco to update.
     */
    where: enderecoWhereUniqueInput
  }

  /**
   * endereco updateMany
   */
  export type enderecoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update enderecos.
     */
    data: XOR<enderecoUpdateManyMutationInput, enderecoUncheckedUpdateManyInput>
    /**
     * Filter which enderecos to update
     */
    where?: enderecoWhereInput
  }

  /**
   * endereco upsert
   */
  export type enderecoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * The filter to search for the endereco to update in case it exists.
     */
    where: enderecoWhereUniqueInput
    /**
     * In case the endereco found by the `where` argument doesn't exist, create a new endereco with this data.
     */
    create: XOR<enderecoCreateInput, enderecoUncheckedCreateInput>
    /**
     * In case the endereco was found with the provided `where` argument, update it with this data.
     */
    update: XOR<enderecoUpdateInput, enderecoUncheckedUpdateInput>
  }

  /**
   * endereco delete
   */
  export type enderecoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * Filter which endereco to delete.
     */
    where: enderecoWhereUniqueInput
  }

  /**
   * endereco deleteMany
   */
  export type enderecoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which enderecos to delete
     */
    where?: enderecoWhereInput
  }

  /**
   * endereco.pessoa
   */
  export type endereco$pessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    where?: pessoaWhereInput
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    cursor?: pessoaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * endereco without action
   */
  export type enderecoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
  }


  /**
   * Model ficheiro
   */

  export type AggregateFicheiro = {
    _count: FicheiroCountAggregateOutputType | null
    _avg: FicheiroAvgAggregateOutputType | null
    _sum: FicheiroSumAggregateOutputType | null
    _min: FicheiroMinAggregateOutputType | null
    _max: FicheiroMaxAggregateOutputType | null
  }

  export type FicheiroAvgAggregateOutputType = {
    idFicheiro: number | null
  }

  export type FicheiroSumAggregateOutputType = {
    idFicheiro: number | null
  }

  export type FicheiroMinAggregateOutputType = {
    idFicheiro: number | null
    nomeFicheiro: string | null
    dataEntrada: string | null
    dataValidacao: string | null
    estadoValidacao: $Enums.ficheiro_estadoValidacao | null
  }

  export type FicheiroMaxAggregateOutputType = {
    idFicheiro: number | null
    nomeFicheiro: string | null
    dataEntrada: string | null
    dataValidacao: string | null
    estadoValidacao: $Enums.ficheiro_estadoValidacao | null
  }

  export type FicheiroCountAggregateOutputType = {
    idFicheiro: number
    nomeFicheiro: number
    dataEntrada: number
    dataValidacao: number
    estadoValidacao: number
    _all: number
  }


  export type FicheiroAvgAggregateInputType = {
    idFicheiro?: true
  }

  export type FicheiroSumAggregateInputType = {
    idFicheiro?: true
  }

  export type FicheiroMinAggregateInputType = {
    idFicheiro?: true
    nomeFicheiro?: true
    dataEntrada?: true
    dataValidacao?: true
    estadoValidacao?: true
  }

  export type FicheiroMaxAggregateInputType = {
    idFicheiro?: true
    nomeFicheiro?: true
    dataEntrada?: true
    dataValidacao?: true
    estadoValidacao?: true
  }

  export type FicheiroCountAggregateInputType = {
    idFicheiro?: true
    nomeFicheiro?: true
    dataEntrada?: true
    dataValidacao?: true
    estadoValidacao?: true
    _all?: true
  }

  export type FicheiroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ficheiro to aggregate.
     */
    where?: ficheiroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ficheiros to fetch.
     */
    orderBy?: ficheiroOrderByWithRelationInput | ficheiroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ficheiroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ficheiros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ficheiros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ficheiros
    **/
    _count?: true | FicheiroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FicheiroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FicheiroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FicheiroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FicheiroMaxAggregateInputType
  }

  export type GetFicheiroAggregateType<T extends FicheiroAggregateArgs> = {
        [P in keyof T & keyof AggregateFicheiro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFicheiro[P]>
      : GetScalarType<T[P], AggregateFicheiro[P]>
  }




  export type ficheiroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ficheiroWhereInput
    orderBy?: ficheiroOrderByWithAggregationInput | ficheiroOrderByWithAggregationInput[]
    by: FicheiroScalarFieldEnum[] | FicheiroScalarFieldEnum
    having?: ficheiroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FicheiroCountAggregateInputType | true
    _avg?: FicheiroAvgAggregateInputType
    _sum?: FicheiroSumAggregateInputType
    _min?: FicheiroMinAggregateInputType
    _max?: FicheiroMaxAggregateInputType
  }

  export type FicheiroGroupByOutputType = {
    idFicheiro: number
    nomeFicheiro: string
    dataEntrada: string | null
    dataValidacao: string | null
    estadoValidacao: $Enums.ficheiro_estadoValidacao | null
    _count: FicheiroCountAggregateOutputType | null
    _avg: FicheiroAvgAggregateOutputType | null
    _sum: FicheiroSumAggregateOutputType | null
    _min: FicheiroMinAggregateOutputType | null
    _max: FicheiroMaxAggregateOutputType | null
  }

  type GetFicheiroGroupByPayload<T extends ficheiroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FicheiroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FicheiroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FicheiroGroupByOutputType[P]>
            : GetScalarType<T[P], FicheiroGroupByOutputType[P]>
        }
      >
    >


  export type ficheiroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idFicheiro?: boolean
    nomeFicheiro?: boolean
    dataEntrada?: boolean
    dataValidacao?: boolean
    estadoValidacao?: boolean
    bi?: boolean | ficheiro$biArgs<ExtArgs>
    cartaconducao?: boolean | ficheiro$cartaconducaoArgs<ExtArgs>
    funcionario?: boolean | ficheiro$funcionarioArgs<ExtArgs>
    pagamentomulta?: boolean | ficheiro$pagamentomultaArgs<ExtArgs>
    titulopropriedade?: boolean | ficheiro$titulopropriedadeArgs<ExtArgs>
    _count?: boolean | FicheiroCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ficheiro"]>


  export type ficheiroSelectScalar = {
    idFicheiro?: boolean
    nomeFicheiro?: boolean
    dataEntrada?: boolean
    dataValidacao?: boolean
    estadoValidacao?: boolean
  }

  export type ficheiroInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bi?: boolean | ficheiro$biArgs<ExtArgs>
    cartaconducao?: boolean | ficheiro$cartaconducaoArgs<ExtArgs>
    funcionario?: boolean | ficheiro$funcionarioArgs<ExtArgs>
    pagamentomulta?: boolean | ficheiro$pagamentomultaArgs<ExtArgs>
    titulopropriedade?: boolean | ficheiro$titulopropriedadeArgs<ExtArgs>
    _count?: boolean | FicheiroCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ficheiroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ficheiro"
    objects: {
      bi: Prisma.$biPayload<ExtArgs>[]
      cartaconducao: Prisma.$cartaconducaoPayload<ExtArgs>[]
      funcionario: Prisma.$funcionarioPayload<ExtArgs>[]
      pagamentomulta: Prisma.$pagamentomultaPayload<ExtArgs>[]
      titulopropriedade: Prisma.$titulopropriedadePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idFicheiro: number
      nomeFicheiro: string
      dataEntrada: string | null
      dataValidacao: string | null
      estadoValidacao: $Enums.ficheiro_estadoValidacao | null
    }, ExtArgs["result"]["ficheiro"]>
    composites: {}
  }

  type ficheiroGetPayload<S extends boolean | null | undefined | ficheiroDefaultArgs> = $Result.GetResult<Prisma.$ficheiroPayload, S>

  type ficheiroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ficheiroFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FicheiroCountAggregateInputType | true
    }

  export interface ficheiroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ficheiro'], meta: { name: 'ficheiro' } }
    /**
     * Find zero or one Ficheiro that matches the filter.
     * @param {ficheiroFindUniqueArgs} args - Arguments to find a Ficheiro
     * @example
     * // Get one Ficheiro
     * const ficheiro = await prisma.ficheiro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ficheiroFindUniqueArgs>(args: SelectSubset<T, ficheiroFindUniqueArgs<ExtArgs>>): Prisma__ficheiroClient<$Result.GetResult<Prisma.$ficheiroPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ficheiro that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ficheiroFindUniqueOrThrowArgs} args - Arguments to find a Ficheiro
     * @example
     * // Get one Ficheiro
     * const ficheiro = await prisma.ficheiro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ficheiroFindUniqueOrThrowArgs>(args: SelectSubset<T, ficheiroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ficheiroClient<$Result.GetResult<Prisma.$ficheiroPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ficheiro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ficheiroFindFirstArgs} args - Arguments to find a Ficheiro
     * @example
     * // Get one Ficheiro
     * const ficheiro = await prisma.ficheiro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ficheiroFindFirstArgs>(args?: SelectSubset<T, ficheiroFindFirstArgs<ExtArgs>>): Prisma__ficheiroClient<$Result.GetResult<Prisma.$ficheiroPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ficheiro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ficheiroFindFirstOrThrowArgs} args - Arguments to find a Ficheiro
     * @example
     * // Get one Ficheiro
     * const ficheiro = await prisma.ficheiro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ficheiroFindFirstOrThrowArgs>(args?: SelectSubset<T, ficheiroFindFirstOrThrowArgs<ExtArgs>>): Prisma__ficheiroClient<$Result.GetResult<Prisma.$ficheiroPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ficheiros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ficheiroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ficheiros
     * const ficheiros = await prisma.ficheiro.findMany()
     * 
     * // Get first 10 Ficheiros
     * const ficheiros = await prisma.ficheiro.findMany({ take: 10 })
     * 
     * // Only select the `idFicheiro`
     * const ficheiroWithIdFicheiroOnly = await prisma.ficheiro.findMany({ select: { idFicheiro: true } })
     * 
     */
    findMany<T extends ficheiroFindManyArgs>(args?: SelectSubset<T, ficheiroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ficheiroPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ficheiro.
     * @param {ficheiroCreateArgs} args - Arguments to create a Ficheiro.
     * @example
     * // Create one Ficheiro
     * const Ficheiro = await prisma.ficheiro.create({
     *   data: {
     *     // ... data to create a Ficheiro
     *   }
     * })
     * 
     */
    create<T extends ficheiroCreateArgs>(args: SelectSubset<T, ficheiroCreateArgs<ExtArgs>>): Prisma__ficheiroClient<$Result.GetResult<Prisma.$ficheiroPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ficheiros.
     * @param {ficheiroCreateManyArgs} args - Arguments to create many Ficheiros.
     * @example
     * // Create many Ficheiros
     * const ficheiro = await prisma.ficheiro.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ficheiroCreateManyArgs>(args?: SelectSubset<T, ficheiroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ficheiro.
     * @param {ficheiroDeleteArgs} args - Arguments to delete one Ficheiro.
     * @example
     * // Delete one Ficheiro
     * const Ficheiro = await prisma.ficheiro.delete({
     *   where: {
     *     // ... filter to delete one Ficheiro
     *   }
     * })
     * 
     */
    delete<T extends ficheiroDeleteArgs>(args: SelectSubset<T, ficheiroDeleteArgs<ExtArgs>>): Prisma__ficheiroClient<$Result.GetResult<Prisma.$ficheiroPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ficheiro.
     * @param {ficheiroUpdateArgs} args - Arguments to update one Ficheiro.
     * @example
     * // Update one Ficheiro
     * const ficheiro = await prisma.ficheiro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ficheiroUpdateArgs>(args: SelectSubset<T, ficheiroUpdateArgs<ExtArgs>>): Prisma__ficheiroClient<$Result.GetResult<Prisma.$ficheiroPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ficheiros.
     * @param {ficheiroDeleteManyArgs} args - Arguments to filter Ficheiros to delete.
     * @example
     * // Delete a few Ficheiros
     * const { count } = await prisma.ficheiro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ficheiroDeleteManyArgs>(args?: SelectSubset<T, ficheiroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ficheiros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ficheiroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ficheiros
     * const ficheiro = await prisma.ficheiro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ficheiroUpdateManyArgs>(args: SelectSubset<T, ficheiroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ficheiro.
     * @param {ficheiroUpsertArgs} args - Arguments to update or create a Ficheiro.
     * @example
     * // Update or create a Ficheiro
     * const ficheiro = await prisma.ficheiro.upsert({
     *   create: {
     *     // ... data to create a Ficheiro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ficheiro we want to update
     *   }
     * })
     */
    upsert<T extends ficheiroUpsertArgs>(args: SelectSubset<T, ficheiroUpsertArgs<ExtArgs>>): Prisma__ficheiroClient<$Result.GetResult<Prisma.$ficheiroPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ficheiros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ficheiroCountArgs} args - Arguments to filter Ficheiros to count.
     * @example
     * // Count the number of Ficheiros
     * const count = await prisma.ficheiro.count({
     *   where: {
     *     // ... the filter for the Ficheiros we want to count
     *   }
     * })
    **/
    count<T extends ficheiroCountArgs>(
      args?: Subset<T, ficheiroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FicheiroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ficheiro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FicheiroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FicheiroAggregateArgs>(args: Subset<T, FicheiroAggregateArgs>): Prisma.PrismaPromise<GetFicheiroAggregateType<T>>

    /**
     * Group by Ficheiro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ficheiroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ficheiroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ficheiroGroupByArgs['orderBy'] }
        : { orderBy?: ficheiroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ficheiroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFicheiroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ficheiro model
   */
  readonly fields: ficheiroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ficheiro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ficheiroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bi<T extends ficheiro$biArgs<ExtArgs> = {}>(args?: Subset<T, ficheiro$biArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$biPayload<ExtArgs>, T, "findMany"> | Null>
    cartaconducao<T extends ficheiro$cartaconducaoArgs<ExtArgs> = {}>(args?: Subset<T, ficheiro$cartaconducaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cartaconducaoPayload<ExtArgs>, T, "findMany"> | Null>
    funcionario<T extends ficheiro$funcionarioArgs<ExtArgs> = {}>(args?: Subset<T, ficheiro$funcionarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$funcionarioPayload<ExtArgs>, T, "findMany"> | Null>
    pagamentomulta<T extends ficheiro$pagamentomultaArgs<ExtArgs> = {}>(args?: Subset<T, ficheiro$pagamentomultaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagamentomultaPayload<ExtArgs>, T, "findMany"> | Null>
    titulopropriedade<T extends ficheiro$titulopropriedadeArgs<ExtArgs> = {}>(args?: Subset<T, ficheiro$titulopropriedadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$titulopropriedadePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ficheiro model
   */ 
  interface ficheiroFieldRefs {
    readonly idFicheiro: FieldRef<"ficheiro", 'Int'>
    readonly nomeFicheiro: FieldRef<"ficheiro", 'String'>
    readonly dataEntrada: FieldRef<"ficheiro", 'String'>
    readonly dataValidacao: FieldRef<"ficheiro", 'String'>
    readonly estadoValidacao: FieldRef<"ficheiro", 'ficheiro_estadoValidacao'>
  }
    

  // Custom InputTypes
  /**
   * ficheiro findUnique
   */
  export type ficheiroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ficheiro
     */
    select?: ficheiroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ficheiroInclude<ExtArgs> | null
    /**
     * Filter, which ficheiro to fetch.
     */
    where: ficheiroWhereUniqueInput
  }

  /**
   * ficheiro findUniqueOrThrow
   */
  export type ficheiroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ficheiro
     */
    select?: ficheiroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ficheiroInclude<ExtArgs> | null
    /**
     * Filter, which ficheiro to fetch.
     */
    where: ficheiroWhereUniqueInput
  }

  /**
   * ficheiro findFirst
   */
  export type ficheiroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ficheiro
     */
    select?: ficheiroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ficheiroInclude<ExtArgs> | null
    /**
     * Filter, which ficheiro to fetch.
     */
    where?: ficheiroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ficheiros to fetch.
     */
    orderBy?: ficheiroOrderByWithRelationInput | ficheiroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ficheiros.
     */
    cursor?: ficheiroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ficheiros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ficheiros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ficheiros.
     */
    distinct?: FicheiroScalarFieldEnum | FicheiroScalarFieldEnum[]
  }

  /**
   * ficheiro findFirstOrThrow
   */
  export type ficheiroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ficheiro
     */
    select?: ficheiroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ficheiroInclude<ExtArgs> | null
    /**
     * Filter, which ficheiro to fetch.
     */
    where?: ficheiroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ficheiros to fetch.
     */
    orderBy?: ficheiroOrderByWithRelationInput | ficheiroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ficheiros.
     */
    cursor?: ficheiroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ficheiros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ficheiros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ficheiros.
     */
    distinct?: FicheiroScalarFieldEnum | FicheiroScalarFieldEnum[]
  }

  /**
   * ficheiro findMany
   */
  export type ficheiroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ficheiro
     */
    select?: ficheiroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ficheiroInclude<ExtArgs> | null
    /**
     * Filter, which ficheiros to fetch.
     */
    where?: ficheiroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ficheiros to fetch.
     */
    orderBy?: ficheiroOrderByWithRelationInput | ficheiroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ficheiros.
     */
    cursor?: ficheiroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ficheiros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ficheiros.
     */
    skip?: number
    distinct?: FicheiroScalarFieldEnum | FicheiroScalarFieldEnum[]
  }

  /**
   * ficheiro create
   */
  export type ficheiroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ficheiro
     */
    select?: ficheiroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ficheiroInclude<ExtArgs> | null
    /**
     * The data needed to create a ficheiro.
     */
    data: XOR<ficheiroCreateInput, ficheiroUncheckedCreateInput>
  }

  /**
   * ficheiro createMany
   */
  export type ficheiroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ficheiros.
     */
    data: ficheiroCreateManyInput | ficheiroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ficheiro update
   */
  export type ficheiroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ficheiro
     */
    select?: ficheiroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ficheiroInclude<ExtArgs> | null
    /**
     * The data needed to update a ficheiro.
     */
    data: XOR<ficheiroUpdateInput, ficheiroUncheckedUpdateInput>
    /**
     * Choose, which ficheiro to update.
     */
    where: ficheiroWhereUniqueInput
  }

  /**
   * ficheiro updateMany
   */
  export type ficheiroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ficheiros.
     */
    data: XOR<ficheiroUpdateManyMutationInput, ficheiroUncheckedUpdateManyInput>
    /**
     * Filter which ficheiros to update
     */
    where?: ficheiroWhereInput
  }

  /**
   * ficheiro upsert
   */
  export type ficheiroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ficheiro
     */
    select?: ficheiroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ficheiroInclude<ExtArgs> | null
    /**
     * The filter to search for the ficheiro to update in case it exists.
     */
    where: ficheiroWhereUniqueInput
    /**
     * In case the ficheiro found by the `where` argument doesn't exist, create a new ficheiro with this data.
     */
    create: XOR<ficheiroCreateInput, ficheiroUncheckedCreateInput>
    /**
     * In case the ficheiro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ficheiroUpdateInput, ficheiroUncheckedUpdateInput>
  }

  /**
   * ficheiro delete
   */
  export type ficheiroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ficheiro
     */
    select?: ficheiroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ficheiroInclude<ExtArgs> | null
    /**
     * Filter which ficheiro to delete.
     */
    where: ficheiroWhereUniqueInput
  }

  /**
   * ficheiro deleteMany
   */
  export type ficheiroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ficheiros to delete
     */
    where?: ficheiroWhereInput
  }

  /**
   * ficheiro.bi
   */
  export type ficheiro$biArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bi
     */
    select?: biSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: biInclude<ExtArgs> | null
    where?: biWhereInput
    orderBy?: biOrderByWithRelationInput | biOrderByWithRelationInput[]
    cursor?: biWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BiScalarFieldEnum | BiScalarFieldEnum[]
  }

  /**
   * ficheiro.cartaconducao
   */
  export type ficheiro$cartaconducaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cartaconducao
     */
    select?: cartaconducaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cartaconducaoInclude<ExtArgs> | null
    where?: cartaconducaoWhereInput
    orderBy?: cartaconducaoOrderByWithRelationInput | cartaconducaoOrderByWithRelationInput[]
    cursor?: cartaconducaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartaconducaoScalarFieldEnum | CartaconducaoScalarFieldEnum[]
  }

  /**
   * ficheiro.funcionario
   */
  export type ficheiro$funcionarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funcionario
     */
    select?: funcionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: funcionarioInclude<ExtArgs> | null
    where?: funcionarioWhereInput
    orderBy?: funcionarioOrderByWithRelationInput | funcionarioOrderByWithRelationInput[]
    cursor?: funcionarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FuncionarioScalarFieldEnum | FuncionarioScalarFieldEnum[]
  }

  /**
   * ficheiro.pagamentomulta
   */
  export type ficheiro$pagamentomultaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentomulta
     */
    select?: pagamentomultaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagamentomultaInclude<ExtArgs> | null
    where?: pagamentomultaWhereInput
    orderBy?: pagamentomultaOrderByWithRelationInput | pagamentomultaOrderByWithRelationInput[]
    cursor?: pagamentomultaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagamentomultaScalarFieldEnum | PagamentomultaScalarFieldEnum[]
  }

  /**
   * ficheiro.titulopropriedade
   */
  export type ficheiro$titulopropriedadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the titulopropriedade
     */
    select?: titulopropriedadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: titulopropriedadeInclude<ExtArgs> | null
    where?: titulopropriedadeWhereInput
    orderBy?: titulopropriedadeOrderByWithRelationInput | titulopropriedadeOrderByWithRelationInput[]
    cursor?: titulopropriedadeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TitulopropriedadeScalarFieldEnum | TitulopropriedadeScalarFieldEnum[]
  }

  /**
   * ficheiro without action
   */
  export type ficheiroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ficheiro
     */
    select?: ficheiroSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ficheiroInclude<ExtArgs> | null
  }


  /**
   * Model funcionario
   */

  export type AggregateFuncionario = {
    _count: FuncionarioCountAggregateOutputType | null
    _avg: FuncionarioAvgAggregateOutputType | null
    _sum: FuncionarioSumAggregateOutputType | null
    _min: FuncionarioMinAggregateOutputType | null
    _max: FuncionarioMaxAggregateOutputType | null
  }

  export type FuncionarioAvgAggregateOutputType = {
    codFuncionario: number | null
    codPessoa: number | null
    codficheiroFotoPerfil: number | null
    codficheiroFotoPendente: number | null
    senha: number | null
  }

  export type FuncionarioSumAggregateOutputType = {
    codFuncionario: number | null
    codPessoa: number | null
    codficheiroFotoPerfil: number | null
    codficheiroFotoPendente: number | null
    senha: number | null
  }

  export type FuncionarioMinAggregateOutputType = {
    codFuncionario: number | null
    codPessoa: number | null
    codficheiroFotoPerfil: number | null
    codficheiroFotoPendente: number | null
    numeroAgente: string | null
    senha: number | null
  }

  export type FuncionarioMaxAggregateOutputType = {
    codFuncionario: number | null
    codPessoa: number | null
    codficheiroFotoPerfil: number | null
    codficheiroFotoPendente: number | null
    numeroAgente: string | null
    senha: number | null
  }

  export type FuncionarioCountAggregateOutputType = {
    codFuncionario: number
    codPessoa: number
    codficheiroFotoPerfil: number
    codficheiroFotoPendente: number
    numeroAgente: number
    senha: number
    _all: number
  }


  export type FuncionarioAvgAggregateInputType = {
    codFuncionario?: true
    codPessoa?: true
    codficheiroFotoPerfil?: true
    codficheiroFotoPendente?: true
    senha?: true
  }

  export type FuncionarioSumAggregateInputType = {
    codFuncionario?: true
    codPessoa?: true
    codficheiroFotoPerfil?: true
    codficheiroFotoPendente?: true
    senha?: true
  }

  export type FuncionarioMinAggregateInputType = {
    codFuncionario?: true
    codPessoa?: true
    codficheiroFotoPerfil?: true
    codficheiroFotoPendente?: true
    numeroAgente?: true
    senha?: true
  }

  export type FuncionarioMaxAggregateInputType = {
    codFuncionario?: true
    codPessoa?: true
    codficheiroFotoPerfil?: true
    codficheiroFotoPendente?: true
    numeroAgente?: true
    senha?: true
  }

  export type FuncionarioCountAggregateInputType = {
    codFuncionario?: true
    codPessoa?: true
    codficheiroFotoPerfil?: true
    codficheiroFotoPendente?: true
    numeroAgente?: true
    senha?: true
    _all?: true
  }

  export type FuncionarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which funcionario to aggregate.
     */
    where?: funcionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of funcionarios to fetch.
     */
    orderBy?: funcionarioOrderByWithRelationInput | funcionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: funcionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` funcionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` funcionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned funcionarios
    **/
    _count?: true | FuncionarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FuncionarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FuncionarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FuncionarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FuncionarioMaxAggregateInputType
  }

  export type GetFuncionarioAggregateType<T extends FuncionarioAggregateArgs> = {
        [P in keyof T & keyof AggregateFuncionario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFuncionario[P]>
      : GetScalarType<T[P], AggregateFuncionario[P]>
  }




  export type funcionarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: funcionarioWhereInput
    orderBy?: funcionarioOrderByWithAggregationInput | funcionarioOrderByWithAggregationInput[]
    by: FuncionarioScalarFieldEnum[] | FuncionarioScalarFieldEnum
    having?: funcionarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FuncionarioCountAggregateInputType | true
    _avg?: FuncionarioAvgAggregateInputType
    _sum?: FuncionarioSumAggregateInputType
    _min?: FuncionarioMinAggregateInputType
    _max?: FuncionarioMaxAggregateInputType
  }

  export type FuncionarioGroupByOutputType = {
    codFuncionario: number
    codPessoa: number
    codficheiroFotoPerfil: number
    codficheiroFotoPendente: number | null
    numeroAgente: string | null
    senha: number
    _count: FuncionarioCountAggregateOutputType | null
    _avg: FuncionarioAvgAggregateOutputType | null
    _sum: FuncionarioSumAggregateOutputType | null
    _min: FuncionarioMinAggregateOutputType | null
    _max: FuncionarioMaxAggregateOutputType | null
  }

  type GetFuncionarioGroupByPayload<T extends funcionarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FuncionarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FuncionarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FuncionarioGroupByOutputType[P]>
            : GetScalarType<T[P], FuncionarioGroupByOutputType[P]>
        }
      >
    >


  export type funcionarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codFuncionario?: boolean
    codPessoa?: boolean
    codficheiroFotoPerfil?: boolean
    codficheiroFotoPendente?: boolean
    numeroAgente?: boolean
    senha?: boolean
    ficheiro?: boolean | ficheiroDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funcionario"]>


  export type funcionarioSelectScalar = {
    codFuncionario?: boolean
    codPessoa?: boolean
    codficheiroFotoPerfil?: boolean
    codficheiroFotoPendente?: boolean
    numeroAgente?: boolean
    senha?: boolean
  }

  export type funcionarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ficheiro?: boolean | ficheiroDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }

  export type $funcionarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "funcionario"
    objects: {
      ficheiro: Prisma.$ficheiroPayload<ExtArgs>
      pessoa: Prisma.$pessoaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      codFuncionario: number
      codPessoa: number
      codficheiroFotoPerfil: number
      codficheiroFotoPendente: number | null
      numeroAgente: string | null
      senha: number
    }, ExtArgs["result"]["funcionario"]>
    composites: {}
  }

  type funcionarioGetPayload<S extends boolean | null | undefined | funcionarioDefaultArgs> = $Result.GetResult<Prisma.$funcionarioPayload, S>

  type funcionarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<funcionarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FuncionarioCountAggregateInputType | true
    }

  export interface funcionarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['funcionario'], meta: { name: 'funcionario' } }
    /**
     * Find zero or one Funcionario that matches the filter.
     * @param {funcionarioFindUniqueArgs} args - Arguments to find a Funcionario
     * @example
     * // Get one Funcionario
     * const funcionario = await prisma.funcionario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends funcionarioFindUniqueArgs>(args: SelectSubset<T, funcionarioFindUniqueArgs<ExtArgs>>): Prisma__funcionarioClient<$Result.GetResult<Prisma.$funcionarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Funcionario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {funcionarioFindUniqueOrThrowArgs} args - Arguments to find a Funcionario
     * @example
     * // Get one Funcionario
     * const funcionario = await prisma.funcionario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends funcionarioFindUniqueOrThrowArgs>(args: SelectSubset<T, funcionarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__funcionarioClient<$Result.GetResult<Prisma.$funcionarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Funcionario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {funcionarioFindFirstArgs} args - Arguments to find a Funcionario
     * @example
     * // Get one Funcionario
     * const funcionario = await prisma.funcionario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends funcionarioFindFirstArgs>(args?: SelectSubset<T, funcionarioFindFirstArgs<ExtArgs>>): Prisma__funcionarioClient<$Result.GetResult<Prisma.$funcionarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Funcionario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {funcionarioFindFirstOrThrowArgs} args - Arguments to find a Funcionario
     * @example
     * // Get one Funcionario
     * const funcionario = await prisma.funcionario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends funcionarioFindFirstOrThrowArgs>(args?: SelectSubset<T, funcionarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__funcionarioClient<$Result.GetResult<Prisma.$funcionarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Funcionarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {funcionarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Funcionarios
     * const funcionarios = await prisma.funcionario.findMany()
     * 
     * // Get first 10 Funcionarios
     * const funcionarios = await prisma.funcionario.findMany({ take: 10 })
     * 
     * // Only select the `codFuncionario`
     * const funcionarioWithCodFuncionarioOnly = await prisma.funcionario.findMany({ select: { codFuncionario: true } })
     * 
     */
    findMany<T extends funcionarioFindManyArgs>(args?: SelectSubset<T, funcionarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$funcionarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Funcionario.
     * @param {funcionarioCreateArgs} args - Arguments to create a Funcionario.
     * @example
     * // Create one Funcionario
     * const Funcionario = await prisma.funcionario.create({
     *   data: {
     *     // ... data to create a Funcionario
     *   }
     * })
     * 
     */
    create<T extends funcionarioCreateArgs>(args: SelectSubset<T, funcionarioCreateArgs<ExtArgs>>): Prisma__funcionarioClient<$Result.GetResult<Prisma.$funcionarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Funcionarios.
     * @param {funcionarioCreateManyArgs} args - Arguments to create many Funcionarios.
     * @example
     * // Create many Funcionarios
     * const funcionario = await prisma.funcionario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends funcionarioCreateManyArgs>(args?: SelectSubset<T, funcionarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Funcionario.
     * @param {funcionarioDeleteArgs} args - Arguments to delete one Funcionario.
     * @example
     * // Delete one Funcionario
     * const Funcionario = await prisma.funcionario.delete({
     *   where: {
     *     // ... filter to delete one Funcionario
     *   }
     * })
     * 
     */
    delete<T extends funcionarioDeleteArgs>(args: SelectSubset<T, funcionarioDeleteArgs<ExtArgs>>): Prisma__funcionarioClient<$Result.GetResult<Prisma.$funcionarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Funcionario.
     * @param {funcionarioUpdateArgs} args - Arguments to update one Funcionario.
     * @example
     * // Update one Funcionario
     * const funcionario = await prisma.funcionario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends funcionarioUpdateArgs>(args: SelectSubset<T, funcionarioUpdateArgs<ExtArgs>>): Prisma__funcionarioClient<$Result.GetResult<Prisma.$funcionarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Funcionarios.
     * @param {funcionarioDeleteManyArgs} args - Arguments to filter Funcionarios to delete.
     * @example
     * // Delete a few Funcionarios
     * const { count } = await prisma.funcionario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends funcionarioDeleteManyArgs>(args?: SelectSubset<T, funcionarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Funcionarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {funcionarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Funcionarios
     * const funcionario = await prisma.funcionario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends funcionarioUpdateManyArgs>(args: SelectSubset<T, funcionarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Funcionario.
     * @param {funcionarioUpsertArgs} args - Arguments to update or create a Funcionario.
     * @example
     * // Update or create a Funcionario
     * const funcionario = await prisma.funcionario.upsert({
     *   create: {
     *     // ... data to create a Funcionario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Funcionario we want to update
     *   }
     * })
     */
    upsert<T extends funcionarioUpsertArgs>(args: SelectSubset<T, funcionarioUpsertArgs<ExtArgs>>): Prisma__funcionarioClient<$Result.GetResult<Prisma.$funcionarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Funcionarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {funcionarioCountArgs} args - Arguments to filter Funcionarios to count.
     * @example
     * // Count the number of Funcionarios
     * const count = await prisma.funcionario.count({
     *   where: {
     *     // ... the filter for the Funcionarios we want to count
     *   }
     * })
    **/
    count<T extends funcionarioCountArgs>(
      args?: Subset<T, funcionarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FuncionarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Funcionario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FuncionarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FuncionarioAggregateArgs>(args: Subset<T, FuncionarioAggregateArgs>): Prisma.PrismaPromise<GetFuncionarioAggregateType<T>>

    /**
     * Group by Funcionario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {funcionarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends funcionarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: funcionarioGroupByArgs['orderBy'] }
        : { orderBy?: funcionarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, funcionarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFuncionarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the funcionario model
   */
  readonly fields: funcionarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for funcionario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__funcionarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ficheiro<T extends ficheiroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ficheiroDefaultArgs<ExtArgs>>): Prisma__ficheiroClient<$Result.GetResult<Prisma.$ficheiroPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pessoa<T extends pessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pessoaDefaultArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the funcionario model
   */ 
  interface funcionarioFieldRefs {
    readonly codFuncionario: FieldRef<"funcionario", 'Int'>
    readonly codPessoa: FieldRef<"funcionario", 'Int'>
    readonly codficheiroFotoPerfil: FieldRef<"funcionario", 'Int'>
    readonly codficheiroFotoPendente: FieldRef<"funcionario", 'Int'>
    readonly numeroAgente: FieldRef<"funcionario", 'String'>
    readonly senha: FieldRef<"funcionario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * funcionario findUnique
   */
  export type funcionarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funcionario
     */
    select?: funcionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: funcionarioInclude<ExtArgs> | null
    /**
     * Filter, which funcionario to fetch.
     */
    where: funcionarioWhereUniqueInput
  }

  /**
   * funcionario findUniqueOrThrow
   */
  export type funcionarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funcionario
     */
    select?: funcionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: funcionarioInclude<ExtArgs> | null
    /**
     * Filter, which funcionario to fetch.
     */
    where: funcionarioWhereUniqueInput
  }

  /**
   * funcionario findFirst
   */
  export type funcionarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funcionario
     */
    select?: funcionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: funcionarioInclude<ExtArgs> | null
    /**
     * Filter, which funcionario to fetch.
     */
    where?: funcionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of funcionarios to fetch.
     */
    orderBy?: funcionarioOrderByWithRelationInput | funcionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for funcionarios.
     */
    cursor?: funcionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` funcionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` funcionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of funcionarios.
     */
    distinct?: FuncionarioScalarFieldEnum | FuncionarioScalarFieldEnum[]
  }

  /**
   * funcionario findFirstOrThrow
   */
  export type funcionarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funcionario
     */
    select?: funcionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: funcionarioInclude<ExtArgs> | null
    /**
     * Filter, which funcionario to fetch.
     */
    where?: funcionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of funcionarios to fetch.
     */
    orderBy?: funcionarioOrderByWithRelationInput | funcionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for funcionarios.
     */
    cursor?: funcionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` funcionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` funcionarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of funcionarios.
     */
    distinct?: FuncionarioScalarFieldEnum | FuncionarioScalarFieldEnum[]
  }

  /**
   * funcionario findMany
   */
  export type funcionarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funcionario
     */
    select?: funcionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: funcionarioInclude<ExtArgs> | null
    /**
     * Filter, which funcionarios to fetch.
     */
    where?: funcionarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of funcionarios to fetch.
     */
    orderBy?: funcionarioOrderByWithRelationInput | funcionarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing funcionarios.
     */
    cursor?: funcionarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` funcionarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` funcionarios.
     */
    skip?: number
    distinct?: FuncionarioScalarFieldEnum | FuncionarioScalarFieldEnum[]
  }

  /**
   * funcionario create
   */
  export type funcionarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funcionario
     */
    select?: funcionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: funcionarioInclude<ExtArgs> | null
    /**
     * The data needed to create a funcionario.
     */
    data: XOR<funcionarioCreateInput, funcionarioUncheckedCreateInput>
  }

  /**
   * funcionario createMany
   */
  export type funcionarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many funcionarios.
     */
    data: funcionarioCreateManyInput | funcionarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * funcionario update
   */
  export type funcionarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funcionario
     */
    select?: funcionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: funcionarioInclude<ExtArgs> | null
    /**
     * The data needed to update a funcionario.
     */
    data: XOR<funcionarioUpdateInput, funcionarioUncheckedUpdateInput>
    /**
     * Choose, which funcionario to update.
     */
    where: funcionarioWhereUniqueInput
  }

  /**
   * funcionario updateMany
   */
  export type funcionarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update funcionarios.
     */
    data: XOR<funcionarioUpdateManyMutationInput, funcionarioUncheckedUpdateManyInput>
    /**
     * Filter which funcionarios to update
     */
    where?: funcionarioWhereInput
  }

  /**
   * funcionario upsert
   */
  export type funcionarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funcionario
     */
    select?: funcionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: funcionarioInclude<ExtArgs> | null
    /**
     * The filter to search for the funcionario to update in case it exists.
     */
    where: funcionarioWhereUniqueInput
    /**
     * In case the funcionario found by the `where` argument doesn't exist, create a new funcionario with this data.
     */
    create: XOR<funcionarioCreateInput, funcionarioUncheckedCreateInput>
    /**
     * In case the funcionario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<funcionarioUpdateInput, funcionarioUncheckedUpdateInput>
  }

  /**
   * funcionario delete
   */
  export type funcionarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funcionario
     */
    select?: funcionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: funcionarioInclude<ExtArgs> | null
    /**
     * Filter which funcionario to delete.
     */
    where: funcionarioWhereUniqueInput
  }

  /**
   * funcionario deleteMany
   */
  export type funcionarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which funcionarios to delete
     */
    where?: funcionarioWhereInput
  }

  /**
   * funcionario without action
   */
  export type funcionarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funcionario
     */
    select?: funcionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: funcionarioInclude<ExtArgs> | null
  }


  /**
   * Model infracao
   */

  export type AggregateInfracao = {
    _count: InfracaoCountAggregateOutputType | null
    _avg: InfracaoAvgAggregateOutputType | null
    _sum: InfracaoSumAggregateOutputType | null
    _min: InfracaoMinAggregateOutputType | null
    _max: InfracaoMaxAggregateOutputType | null
  }

  export type InfracaoAvgAggregateOutputType = {
    codInfracao: number | null
    codMulta: number | null
    codTipoInfracao: number | null
  }

  export type InfracaoSumAggregateOutputType = {
    codInfracao: number | null
    codMulta: number | null
    codTipoInfracao: number | null
  }

  export type InfracaoMinAggregateOutputType = {
    codInfracao: number | null
    codMulta: number | null
    codTipoInfracao: number | null
  }

  export type InfracaoMaxAggregateOutputType = {
    codInfracao: number | null
    codMulta: number | null
    codTipoInfracao: number | null
  }

  export type InfracaoCountAggregateOutputType = {
    codInfracao: number
    codMulta: number
    codTipoInfracao: number
    _all: number
  }


  export type InfracaoAvgAggregateInputType = {
    codInfracao?: true
    codMulta?: true
    codTipoInfracao?: true
  }

  export type InfracaoSumAggregateInputType = {
    codInfracao?: true
    codMulta?: true
    codTipoInfracao?: true
  }

  export type InfracaoMinAggregateInputType = {
    codInfracao?: true
    codMulta?: true
    codTipoInfracao?: true
  }

  export type InfracaoMaxAggregateInputType = {
    codInfracao?: true
    codMulta?: true
    codTipoInfracao?: true
  }

  export type InfracaoCountAggregateInputType = {
    codInfracao?: true
    codMulta?: true
    codTipoInfracao?: true
    _all?: true
  }

  export type InfracaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which infracao to aggregate.
     */
    where?: infracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infracaos to fetch.
     */
    orderBy?: infracaoOrderByWithRelationInput | infracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: infracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned infracaos
    **/
    _count?: true | InfracaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InfracaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InfracaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InfracaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InfracaoMaxAggregateInputType
  }

  export type GetInfracaoAggregateType<T extends InfracaoAggregateArgs> = {
        [P in keyof T & keyof AggregateInfracao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInfracao[P]>
      : GetScalarType<T[P], AggregateInfracao[P]>
  }




  export type infracaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: infracaoWhereInput
    orderBy?: infracaoOrderByWithAggregationInput | infracaoOrderByWithAggregationInput[]
    by: InfracaoScalarFieldEnum[] | InfracaoScalarFieldEnum
    having?: infracaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InfracaoCountAggregateInputType | true
    _avg?: InfracaoAvgAggregateInputType
    _sum?: InfracaoSumAggregateInputType
    _min?: InfracaoMinAggregateInputType
    _max?: InfracaoMaxAggregateInputType
  }

  export type InfracaoGroupByOutputType = {
    codInfracao: number
    codMulta: number
    codTipoInfracao: number
    _count: InfracaoCountAggregateOutputType | null
    _avg: InfracaoAvgAggregateOutputType | null
    _sum: InfracaoSumAggregateOutputType | null
    _min: InfracaoMinAggregateOutputType | null
    _max: InfracaoMaxAggregateOutputType | null
  }

  type GetInfracaoGroupByPayload<T extends infracaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InfracaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InfracaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InfracaoGroupByOutputType[P]>
            : GetScalarType<T[P], InfracaoGroupByOutputType[P]>
        }
      >
    >


  export type infracaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codInfracao?: boolean
    codMulta?: boolean
    codTipoInfracao?: boolean
    multa_infracao_codMultaTomulta?: boolean | multaDefaultArgs<ExtArgs>
    tipoinfracao?: boolean | tipoinfracaoDefaultArgs<ExtArgs>
    multa_multa_codInfracaoToinfracao?: boolean | infracao$multa_multa_codInfracaoToinfracaoArgs<ExtArgs>
    _count?: boolean | InfracaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["infracao"]>


  export type infracaoSelectScalar = {
    codInfracao?: boolean
    codMulta?: boolean
    codTipoInfracao?: boolean
  }

  export type infracaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    multa_infracao_codMultaTomulta?: boolean | multaDefaultArgs<ExtArgs>
    tipoinfracao?: boolean | tipoinfracaoDefaultArgs<ExtArgs>
    multa_multa_codInfracaoToinfracao?: boolean | infracao$multa_multa_codInfracaoToinfracaoArgs<ExtArgs>
    _count?: boolean | InfracaoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $infracaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "infracao"
    objects: {
      multa_infracao_codMultaTomulta: Prisma.$multaPayload<ExtArgs>
      tipoinfracao: Prisma.$tipoinfracaoPayload<ExtArgs>
      multa_multa_codInfracaoToinfracao: Prisma.$multaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      codInfracao: number
      codMulta: number
      codTipoInfracao: number
    }, ExtArgs["result"]["infracao"]>
    composites: {}
  }

  type infracaoGetPayload<S extends boolean | null | undefined | infracaoDefaultArgs> = $Result.GetResult<Prisma.$infracaoPayload, S>

  type infracaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<infracaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InfracaoCountAggregateInputType | true
    }

  export interface infracaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['infracao'], meta: { name: 'infracao' } }
    /**
     * Find zero or one Infracao that matches the filter.
     * @param {infracaoFindUniqueArgs} args - Arguments to find a Infracao
     * @example
     * // Get one Infracao
     * const infracao = await prisma.infracao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends infracaoFindUniqueArgs>(args: SelectSubset<T, infracaoFindUniqueArgs<ExtArgs>>): Prisma__infracaoClient<$Result.GetResult<Prisma.$infracaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Infracao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {infracaoFindUniqueOrThrowArgs} args - Arguments to find a Infracao
     * @example
     * // Get one Infracao
     * const infracao = await prisma.infracao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends infracaoFindUniqueOrThrowArgs>(args: SelectSubset<T, infracaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__infracaoClient<$Result.GetResult<Prisma.$infracaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Infracao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infracaoFindFirstArgs} args - Arguments to find a Infracao
     * @example
     * // Get one Infracao
     * const infracao = await prisma.infracao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends infracaoFindFirstArgs>(args?: SelectSubset<T, infracaoFindFirstArgs<ExtArgs>>): Prisma__infracaoClient<$Result.GetResult<Prisma.$infracaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Infracao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infracaoFindFirstOrThrowArgs} args - Arguments to find a Infracao
     * @example
     * // Get one Infracao
     * const infracao = await prisma.infracao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends infracaoFindFirstOrThrowArgs>(args?: SelectSubset<T, infracaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__infracaoClient<$Result.GetResult<Prisma.$infracaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Infracaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infracaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Infracaos
     * const infracaos = await prisma.infracao.findMany()
     * 
     * // Get first 10 Infracaos
     * const infracaos = await prisma.infracao.findMany({ take: 10 })
     * 
     * // Only select the `codInfracao`
     * const infracaoWithCodInfracaoOnly = await prisma.infracao.findMany({ select: { codInfracao: true } })
     * 
     */
    findMany<T extends infracaoFindManyArgs>(args?: SelectSubset<T, infracaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$infracaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Infracao.
     * @param {infracaoCreateArgs} args - Arguments to create a Infracao.
     * @example
     * // Create one Infracao
     * const Infracao = await prisma.infracao.create({
     *   data: {
     *     // ... data to create a Infracao
     *   }
     * })
     * 
     */
    create<T extends infracaoCreateArgs>(args: SelectSubset<T, infracaoCreateArgs<ExtArgs>>): Prisma__infracaoClient<$Result.GetResult<Prisma.$infracaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Infracaos.
     * @param {infracaoCreateManyArgs} args - Arguments to create many Infracaos.
     * @example
     * // Create many Infracaos
     * const infracao = await prisma.infracao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends infracaoCreateManyArgs>(args?: SelectSubset<T, infracaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Infracao.
     * @param {infracaoDeleteArgs} args - Arguments to delete one Infracao.
     * @example
     * // Delete one Infracao
     * const Infracao = await prisma.infracao.delete({
     *   where: {
     *     // ... filter to delete one Infracao
     *   }
     * })
     * 
     */
    delete<T extends infracaoDeleteArgs>(args: SelectSubset<T, infracaoDeleteArgs<ExtArgs>>): Prisma__infracaoClient<$Result.GetResult<Prisma.$infracaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Infracao.
     * @param {infracaoUpdateArgs} args - Arguments to update one Infracao.
     * @example
     * // Update one Infracao
     * const infracao = await prisma.infracao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends infracaoUpdateArgs>(args: SelectSubset<T, infracaoUpdateArgs<ExtArgs>>): Prisma__infracaoClient<$Result.GetResult<Prisma.$infracaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Infracaos.
     * @param {infracaoDeleteManyArgs} args - Arguments to filter Infracaos to delete.
     * @example
     * // Delete a few Infracaos
     * const { count } = await prisma.infracao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends infracaoDeleteManyArgs>(args?: SelectSubset<T, infracaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Infracaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infracaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Infracaos
     * const infracao = await prisma.infracao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends infracaoUpdateManyArgs>(args: SelectSubset<T, infracaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Infracao.
     * @param {infracaoUpsertArgs} args - Arguments to update or create a Infracao.
     * @example
     * // Update or create a Infracao
     * const infracao = await prisma.infracao.upsert({
     *   create: {
     *     // ... data to create a Infracao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Infracao we want to update
     *   }
     * })
     */
    upsert<T extends infracaoUpsertArgs>(args: SelectSubset<T, infracaoUpsertArgs<ExtArgs>>): Prisma__infracaoClient<$Result.GetResult<Prisma.$infracaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Infracaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infracaoCountArgs} args - Arguments to filter Infracaos to count.
     * @example
     * // Count the number of Infracaos
     * const count = await prisma.infracao.count({
     *   where: {
     *     // ... the filter for the Infracaos we want to count
     *   }
     * })
    **/
    count<T extends infracaoCountArgs>(
      args?: Subset<T, infracaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InfracaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Infracao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfracaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InfracaoAggregateArgs>(args: Subset<T, InfracaoAggregateArgs>): Prisma.PrismaPromise<GetInfracaoAggregateType<T>>

    /**
     * Group by Infracao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {infracaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends infracaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: infracaoGroupByArgs['orderBy'] }
        : { orderBy?: infracaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, infracaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInfracaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the infracao model
   */
  readonly fields: infracaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for infracao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__infracaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    multa_infracao_codMultaTomulta<T extends multaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, multaDefaultArgs<ExtArgs>>): Prisma__multaClient<$Result.GetResult<Prisma.$multaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tipoinfracao<T extends tipoinfracaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tipoinfracaoDefaultArgs<ExtArgs>>): Prisma__tipoinfracaoClient<$Result.GetResult<Prisma.$tipoinfracaoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    multa_multa_codInfracaoToinfracao<T extends infracao$multa_multa_codInfracaoToinfracaoArgs<ExtArgs> = {}>(args?: Subset<T, infracao$multa_multa_codInfracaoToinfracaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$multaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the infracao model
   */ 
  interface infracaoFieldRefs {
    readonly codInfracao: FieldRef<"infracao", 'Int'>
    readonly codMulta: FieldRef<"infracao", 'Int'>
    readonly codTipoInfracao: FieldRef<"infracao", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * infracao findUnique
   */
  export type infracaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infracao
     */
    select?: infracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: infracaoInclude<ExtArgs> | null
    /**
     * Filter, which infracao to fetch.
     */
    where: infracaoWhereUniqueInput
  }

  /**
   * infracao findUniqueOrThrow
   */
  export type infracaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infracao
     */
    select?: infracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: infracaoInclude<ExtArgs> | null
    /**
     * Filter, which infracao to fetch.
     */
    where: infracaoWhereUniqueInput
  }

  /**
   * infracao findFirst
   */
  export type infracaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infracao
     */
    select?: infracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: infracaoInclude<ExtArgs> | null
    /**
     * Filter, which infracao to fetch.
     */
    where?: infracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infracaos to fetch.
     */
    orderBy?: infracaoOrderByWithRelationInput | infracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for infracaos.
     */
    cursor?: infracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of infracaos.
     */
    distinct?: InfracaoScalarFieldEnum | InfracaoScalarFieldEnum[]
  }

  /**
   * infracao findFirstOrThrow
   */
  export type infracaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infracao
     */
    select?: infracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: infracaoInclude<ExtArgs> | null
    /**
     * Filter, which infracao to fetch.
     */
    where?: infracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infracaos to fetch.
     */
    orderBy?: infracaoOrderByWithRelationInput | infracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for infracaos.
     */
    cursor?: infracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of infracaos.
     */
    distinct?: InfracaoScalarFieldEnum | InfracaoScalarFieldEnum[]
  }

  /**
   * infracao findMany
   */
  export type infracaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infracao
     */
    select?: infracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: infracaoInclude<ExtArgs> | null
    /**
     * Filter, which infracaos to fetch.
     */
    where?: infracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of infracaos to fetch.
     */
    orderBy?: infracaoOrderByWithRelationInput | infracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing infracaos.
     */
    cursor?: infracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` infracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` infracaos.
     */
    skip?: number
    distinct?: InfracaoScalarFieldEnum | InfracaoScalarFieldEnum[]
  }

  /**
   * infracao create
   */
  export type infracaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infracao
     */
    select?: infracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: infracaoInclude<ExtArgs> | null
    /**
     * The data needed to create a infracao.
     */
    data: XOR<infracaoCreateInput, infracaoUncheckedCreateInput>
  }

  /**
   * infracao createMany
   */
  export type infracaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many infracaos.
     */
    data: infracaoCreateManyInput | infracaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * infracao update
   */
  export type infracaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infracao
     */
    select?: infracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: infracaoInclude<ExtArgs> | null
    /**
     * The data needed to update a infracao.
     */
    data: XOR<infracaoUpdateInput, infracaoUncheckedUpdateInput>
    /**
     * Choose, which infracao to update.
     */
    where: infracaoWhereUniqueInput
  }

  /**
   * infracao updateMany
   */
  export type infracaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update infracaos.
     */
    data: XOR<infracaoUpdateManyMutationInput, infracaoUncheckedUpdateManyInput>
    /**
     * Filter which infracaos to update
     */
    where?: infracaoWhereInput
  }

  /**
   * infracao upsert
   */
  export type infracaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infracao
     */
    select?: infracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: infracaoInclude<ExtArgs> | null
    /**
     * The filter to search for the infracao to update in case it exists.
     */
    where: infracaoWhereUniqueInput
    /**
     * In case the infracao found by the `where` argument doesn't exist, create a new infracao with this data.
     */
    create: XOR<infracaoCreateInput, infracaoUncheckedCreateInput>
    /**
     * In case the infracao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<infracaoUpdateInput, infracaoUncheckedUpdateInput>
  }

  /**
   * infracao delete
   */
  export type infracaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infracao
     */
    select?: infracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: infracaoInclude<ExtArgs> | null
    /**
     * Filter which infracao to delete.
     */
    where: infracaoWhereUniqueInput
  }

  /**
   * infracao deleteMany
   */
  export type infracaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which infracaos to delete
     */
    where?: infracaoWhereInput
  }

  /**
   * infracao.multa_multa_codInfracaoToinfracao
   */
  export type infracao$multa_multa_codInfracaoToinfracaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multa
     */
    select?: multaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: multaInclude<ExtArgs> | null
    where?: multaWhereInput
    orderBy?: multaOrderByWithRelationInput | multaOrderByWithRelationInput[]
    cursor?: multaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MultaScalarFieldEnum | MultaScalarFieldEnum[]
  }

  /**
   * infracao without action
   */
  export type infracaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infracao
     */
    select?: infracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: infracaoInclude<ExtArgs> | null
  }


  /**
   * Model livrete
   */

  export type AggregateLivrete = {
    _count: LivreteCountAggregateOutputType | null
    _avg: LivreteAvgAggregateOutputType | null
    _sum: LivreteSumAggregateOutputType | null
    _min: LivreteMinAggregateOutputType | null
    _max: LivreteMaxAggregateOutputType | null
  }

  export type LivreteAvgAggregateOutputType = {
    codLivrete: number | null
    codViatura: number | null
    codServico: number | null
    codMarca: number | null
  }

  export type LivreteSumAggregateOutputType = {
    codLivrete: number | null
    codViatura: number | null
    codServico: number | null
    codMarca: number | null
  }

  export type LivreteMinAggregateOutputType = {
    codLivrete: number | null
    codViatura: number | null
    numeroQuadro: string | null
    corViatura: string | null
    MedidasPneumaticos: string | null
    codServico: number | null
    dataEmissao: Date | null
    dataPrimeiroRegistro: Date | null
    lotacao: string | null
    cilindrada: string | null
    numeroCilindro: string | null
    conbustivel: string | null
    peso: string | null
    tara: string | null
    tipoCaixa: string | null
    distanciaEixo: string | null
    modelo: string | null
    codMarca: number | null
  }

  export type LivreteMaxAggregateOutputType = {
    codLivrete: number | null
    codViatura: number | null
    numeroQuadro: string | null
    corViatura: string | null
    MedidasPneumaticos: string | null
    codServico: number | null
    dataEmissao: Date | null
    dataPrimeiroRegistro: Date | null
    lotacao: string | null
    cilindrada: string | null
    numeroCilindro: string | null
    conbustivel: string | null
    peso: string | null
    tara: string | null
    tipoCaixa: string | null
    distanciaEixo: string | null
    modelo: string | null
    codMarca: number | null
  }

  export type LivreteCountAggregateOutputType = {
    codLivrete: number
    codViatura: number
    numeroQuadro: number
    corViatura: number
    MedidasPneumaticos: number
    codServico: number
    dataEmissao: number
    dataPrimeiroRegistro: number
    lotacao: number
    cilindrada: number
    numeroCilindro: number
    conbustivel: number
    peso: number
    tara: number
    tipoCaixa: number
    distanciaEixo: number
    modelo: number
    codMarca: number
    _all: number
  }


  export type LivreteAvgAggregateInputType = {
    codLivrete?: true
    codViatura?: true
    codServico?: true
    codMarca?: true
  }

  export type LivreteSumAggregateInputType = {
    codLivrete?: true
    codViatura?: true
    codServico?: true
    codMarca?: true
  }

  export type LivreteMinAggregateInputType = {
    codLivrete?: true
    codViatura?: true
    numeroQuadro?: true
    corViatura?: true
    MedidasPneumaticos?: true
    codServico?: true
    dataEmissao?: true
    dataPrimeiroRegistro?: true
    lotacao?: true
    cilindrada?: true
    numeroCilindro?: true
    conbustivel?: true
    peso?: true
    tara?: true
    tipoCaixa?: true
    distanciaEixo?: true
    modelo?: true
    codMarca?: true
  }

  export type LivreteMaxAggregateInputType = {
    codLivrete?: true
    codViatura?: true
    numeroQuadro?: true
    corViatura?: true
    MedidasPneumaticos?: true
    codServico?: true
    dataEmissao?: true
    dataPrimeiroRegistro?: true
    lotacao?: true
    cilindrada?: true
    numeroCilindro?: true
    conbustivel?: true
    peso?: true
    tara?: true
    tipoCaixa?: true
    distanciaEixo?: true
    modelo?: true
    codMarca?: true
  }

  export type LivreteCountAggregateInputType = {
    codLivrete?: true
    codViatura?: true
    numeroQuadro?: true
    corViatura?: true
    MedidasPneumaticos?: true
    codServico?: true
    dataEmissao?: true
    dataPrimeiroRegistro?: true
    lotacao?: true
    cilindrada?: true
    numeroCilindro?: true
    conbustivel?: true
    peso?: true
    tara?: true
    tipoCaixa?: true
    distanciaEixo?: true
    modelo?: true
    codMarca?: true
    _all?: true
  }

  export type LivreteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which livrete to aggregate.
     */
    where?: livreteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of livretes to fetch.
     */
    orderBy?: livreteOrderByWithRelationInput | livreteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: livreteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` livretes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` livretes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned livretes
    **/
    _count?: true | LivreteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LivreteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LivreteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LivreteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LivreteMaxAggregateInputType
  }

  export type GetLivreteAggregateType<T extends LivreteAggregateArgs> = {
        [P in keyof T & keyof AggregateLivrete]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLivrete[P]>
      : GetScalarType<T[P], AggregateLivrete[P]>
  }




  export type livreteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: livreteWhereInput
    orderBy?: livreteOrderByWithAggregationInput | livreteOrderByWithAggregationInput[]
    by: LivreteScalarFieldEnum[] | LivreteScalarFieldEnum
    having?: livreteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LivreteCountAggregateInputType | true
    _avg?: LivreteAvgAggregateInputType
    _sum?: LivreteSumAggregateInputType
    _min?: LivreteMinAggregateInputType
    _max?: LivreteMaxAggregateInputType
  }

  export type LivreteGroupByOutputType = {
    codLivrete: number
    codViatura: number
    numeroQuadro: string
    corViatura: string
    MedidasPneumaticos: string
    codServico: number
    dataEmissao: Date
    dataPrimeiroRegistro: Date
    lotacao: string
    cilindrada: string
    numeroCilindro: string
    conbustivel: string
    peso: string
    tara: string
    tipoCaixa: string
    distanciaEixo: string
    modelo: string
    codMarca: number
    _count: LivreteCountAggregateOutputType | null
    _avg: LivreteAvgAggregateOutputType | null
    _sum: LivreteSumAggregateOutputType | null
    _min: LivreteMinAggregateOutputType | null
    _max: LivreteMaxAggregateOutputType | null
  }

  type GetLivreteGroupByPayload<T extends livreteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LivreteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LivreteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LivreteGroupByOutputType[P]>
            : GetScalarType<T[P], LivreteGroupByOutputType[P]>
        }
      >
    >


  export type livreteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codLivrete?: boolean
    codViatura?: boolean
    numeroQuadro?: boolean
    corViatura?: boolean
    MedidasPneumaticos?: boolean
    codServico?: boolean
    dataEmissao?: boolean
    dataPrimeiroRegistro?: boolean
    lotacao?: boolean
    cilindrada?: boolean
    numeroCilindro?: boolean
    conbustivel?: boolean
    peso?: boolean
    tara?: boolean
    tipoCaixa?: boolean
    distanciaEixo?: boolean
    modelo?: boolean
    codMarca?: boolean
    marca?: boolean | marcaDefaultArgs<ExtArgs>
    viatura?: boolean | viaturaDefaultArgs<ExtArgs>
    serivicoviatura?: boolean | serivicoviaturaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["livrete"]>


  export type livreteSelectScalar = {
    codLivrete?: boolean
    codViatura?: boolean
    numeroQuadro?: boolean
    corViatura?: boolean
    MedidasPneumaticos?: boolean
    codServico?: boolean
    dataEmissao?: boolean
    dataPrimeiroRegistro?: boolean
    lotacao?: boolean
    cilindrada?: boolean
    numeroCilindro?: boolean
    conbustivel?: boolean
    peso?: boolean
    tara?: boolean
    tipoCaixa?: boolean
    distanciaEixo?: boolean
    modelo?: boolean
    codMarca?: boolean
  }

  export type livreteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marca?: boolean | marcaDefaultArgs<ExtArgs>
    viatura?: boolean | viaturaDefaultArgs<ExtArgs>
    serivicoviatura?: boolean | serivicoviaturaDefaultArgs<ExtArgs>
  }

  export type $livretePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "livrete"
    objects: {
      marca: Prisma.$marcaPayload<ExtArgs>
      viatura: Prisma.$viaturaPayload<ExtArgs>
      serivicoviatura: Prisma.$serivicoviaturaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      codLivrete: number
      codViatura: number
      numeroQuadro: string
      corViatura: string
      MedidasPneumaticos: string
      codServico: number
      dataEmissao: Date
      dataPrimeiroRegistro: Date
      lotacao: string
      cilindrada: string
      numeroCilindro: string
      conbustivel: string
      peso: string
      tara: string
      tipoCaixa: string
      distanciaEixo: string
      modelo: string
      codMarca: number
    }, ExtArgs["result"]["livrete"]>
    composites: {}
  }

  type livreteGetPayload<S extends boolean | null | undefined | livreteDefaultArgs> = $Result.GetResult<Prisma.$livretePayload, S>

  type livreteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<livreteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LivreteCountAggregateInputType | true
    }

  export interface livreteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['livrete'], meta: { name: 'livrete' } }
    /**
     * Find zero or one Livrete that matches the filter.
     * @param {livreteFindUniqueArgs} args - Arguments to find a Livrete
     * @example
     * // Get one Livrete
     * const livrete = await prisma.livrete.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends livreteFindUniqueArgs>(args: SelectSubset<T, livreteFindUniqueArgs<ExtArgs>>): Prisma__livreteClient<$Result.GetResult<Prisma.$livretePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Livrete that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {livreteFindUniqueOrThrowArgs} args - Arguments to find a Livrete
     * @example
     * // Get one Livrete
     * const livrete = await prisma.livrete.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends livreteFindUniqueOrThrowArgs>(args: SelectSubset<T, livreteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__livreteClient<$Result.GetResult<Prisma.$livretePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Livrete that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {livreteFindFirstArgs} args - Arguments to find a Livrete
     * @example
     * // Get one Livrete
     * const livrete = await prisma.livrete.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends livreteFindFirstArgs>(args?: SelectSubset<T, livreteFindFirstArgs<ExtArgs>>): Prisma__livreteClient<$Result.GetResult<Prisma.$livretePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Livrete that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {livreteFindFirstOrThrowArgs} args - Arguments to find a Livrete
     * @example
     * // Get one Livrete
     * const livrete = await prisma.livrete.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends livreteFindFirstOrThrowArgs>(args?: SelectSubset<T, livreteFindFirstOrThrowArgs<ExtArgs>>): Prisma__livreteClient<$Result.GetResult<Prisma.$livretePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Livretes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {livreteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Livretes
     * const livretes = await prisma.livrete.findMany()
     * 
     * // Get first 10 Livretes
     * const livretes = await prisma.livrete.findMany({ take: 10 })
     * 
     * // Only select the `codLivrete`
     * const livreteWithCodLivreteOnly = await prisma.livrete.findMany({ select: { codLivrete: true } })
     * 
     */
    findMany<T extends livreteFindManyArgs>(args?: SelectSubset<T, livreteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$livretePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Livrete.
     * @param {livreteCreateArgs} args - Arguments to create a Livrete.
     * @example
     * // Create one Livrete
     * const Livrete = await prisma.livrete.create({
     *   data: {
     *     // ... data to create a Livrete
     *   }
     * })
     * 
     */
    create<T extends livreteCreateArgs>(args: SelectSubset<T, livreteCreateArgs<ExtArgs>>): Prisma__livreteClient<$Result.GetResult<Prisma.$livretePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Livretes.
     * @param {livreteCreateManyArgs} args - Arguments to create many Livretes.
     * @example
     * // Create many Livretes
     * const livrete = await prisma.livrete.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends livreteCreateManyArgs>(args?: SelectSubset<T, livreteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Livrete.
     * @param {livreteDeleteArgs} args - Arguments to delete one Livrete.
     * @example
     * // Delete one Livrete
     * const Livrete = await prisma.livrete.delete({
     *   where: {
     *     // ... filter to delete one Livrete
     *   }
     * })
     * 
     */
    delete<T extends livreteDeleteArgs>(args: SelectSubset<T, livreteDeleteArgs<ExtArgs>>): Prisma__livreteClient<$Result.GetResult<Prisma.$livretePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Livrete.
     * @param {livreteUpdateArgs} args - Arguments to update one Livrete.
     * @example
     * // Update one Livrete
     * const livrete = await prisma.livrete.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends livreteUpdateArgs>(args: SelectSubset<T, livreteUpdateArgs<ExtArgs>>): Prisma__livreteClient<$Result.GetResult<Prisma.$livretePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Livretes.
     * @param {livreteDeleteManyArgs} args - Arguments to filter Livretes to delete.
     * @example
     * // Delete a few Livretes
     * const { count } = await prisma.livrete.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends livreteDeleteManyArgs>(args?: SelectSubset<T, livreteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Livretes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {livreteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Livretes
     * const livrete = await prisma.livrete.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends livreteUpdateManyArgs>(args: SelectSubset<T, livreteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Livrete.
     * @param {livreteUpsertArgs} args - Arguments to update or create a Livrete.
     * @example
     * // Update or create a Livrete
     * const livrete = await prisma.livrete.upsert({
     *   create: {
     *     // ... data to create a Livrete
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Livrete we want to update
     *   }
     * })
     */
    upsert<T extends livreteUpsertArgs>(args: SelectSubset<T, livreteUpsertArgs<ExtArgs>>): Prisma__livreteClient<$Result.GetResult<Prisma.$livretePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Livretes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {livreteCountArgs} args - Arguments to filter Livretes to count.
     * @example
     * // Count the number of Livretes
     * const count = await prisma.livrete.count({
     *   where: {
     *     // ... the filter for the Livretes we want to count
     *   }
     * })
    **/
    count<T extends livreteCountArgs>(
      args?: Subset<T, livreteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LivreteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Livrete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivreteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LivreteAggregateArgs>(args: Subset<T, LivreteAggregateArgs>): Prisma.PrismaPromise<GetLivreteAggregateType<T>>

    /**
     * Group by Livrete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {livreteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends livreteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: livreteGroupByArgs['orderBy'] }
        : { orderBy?: livreteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, livreteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLivreteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the livrete model
   */
  readonly fields: livreteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for livrete.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__livreteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    marca<T extends marcaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, marcaDefaultArgs<ExtArgs>>): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    viatura<T extends viaturaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, viaturaDefaultArgs<ExtArgs>>): Prisma__viaturaClient<$Result.GetResult<Prisma.$viaturaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    serivicoviatura<T extends serivicoviaturaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, serivicoviaturaDefaultArgs<ExtArgs>>): Prisma__serivicoviaturaClient<$Result.GetResult<Prisma.$serivicoviaturaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the livrete model
   */ 
  interface livreteFieldRefs {
    readonly codLivrete: FieldRef<"livrete", 'Int'>
    readonly codViatura: FieldRef<"livrete", 'Int'>
    readonly numeroQuadro: FieldRef<"livrete", 'String'>
    readonly corViatura: FieldRef<"livrete", 'String'>
    readonly MedidasPneumaticos: FieldRef<"livrete", 'String'>
    readonly codServico: FieldRef<"livrete", 'Int'>
    readonly dataEmissao: FieldRef<"livrete", 'DateTime'>
    readonly dataPrimeiroRegistro: FieldRef<"livrete", 'DateTime'>
    readonly lotacao: FieldRef<"livrete", 'String'>
    readonly cilindrada: FieldRef<"livrete", 'String'>
    readonly numeroCilindro: FieldRef<"livrete", 'String'>
    readonly conbustivel: FieldRef<"livrete", 'String'>
    readonly peso: FieldRef<"livrete", 'String'>
    readonly tara: FieldRef<"livrete", 'String'>
    readonly tipoCaixa: FieldRef<"livrete", 'String'>
    readonly distanciaEixo: FieldRef<"livrete", 'String'>
    readonly modelo: FieldRef<"livrete", 'String'>
    readonly codMarca: FieldRef<"livrete", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * livrete findUnique
   */
  export type livreteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the livrete
     */
    select?: livreteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: livreteInclude<ExtArgs> | null
    /**
     * Filter, which livrete to fetch.
     */
    where: livreteWhereUniqueInput
  }

  /**
   * livrete findUniqueOrThrow
   */
  export type livreteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the livrete
     */
    select?: livreteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: livreteInclude<ExtArgs> | null
    /**
     * Filter, which livrete to fetch.
     */
    where: livreteWhereUniqueInput
  }

  /**
   * livrete findFirst
   */
  export type livreteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the livrete
     */
    select?: livreteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: livreteInclude<ExtArgs> | null
    /**
     * Filter, which livrete to fetch.
     */
    where?: livreteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of livretes to fetch.
     */
    orderBy?: livreteOrderByWithRelationInput | livreteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for livretes.
     */
    cursor?: livreteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` livretes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` livretes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of livretes.
     */
    distinct?: LivreteScalarFieldEnum | LivreteScalarFieldEnum[]
  }

  /**
   * livrete findFirstOrThrow
   */
  export type livreteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the livrete
     */
    select?: livreteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: livreteInclude<ExtArgs> | null
    /**
     * Filter, which livrete to fetch.
     */
    where?: livreteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of livretes to fetch.
     */
    orderBy?: livreteOrderByWithRelationInput | livreteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for livretes.
     */
    cursor?: livreteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` livretes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` livretes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of livretes.
     */
    distinct?: LivreteScalarFieldEnum | LivreteScalarFieldEnum[]
  }

  /**
   * livrete findMany
   */
  export type livreteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the livrete
     */
    select?: livreteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: livreteInclude<ExtArgs> | null
    /**
     * Filter, which livretes to fetch.
     */
    where?: livreteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of livretes to fetch.
     */
    orderBy?: livreteOrderByWithRelationInput | livreteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing livretes.
     */
    cursor?: livreteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` livretes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` livretes.
     */
    skip?: number
    distinct?: LivreteScalarFieldEnum | LivreteScalarFieldEnum[]
  }

  /**
   * livrete create
   */
  export type livreteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the livrete
     */
    select?: livreteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: livreteInclude<ExtArgs> | null
    /**
     * The data needed to create a livrete.
     */
    data: XOR<livreteCreateInput, livreteUncheckedCreateInput>
  }

  /**
   * livrete createMany
   */
  export type livreteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many livretes.
     */
    data: livreteCreateManyInput | livreteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * livrete update
   */
  export type livreteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the livrete
     */
    select?: livreteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: livreteInclude<ExtArgs> | null
    /**
     * The data needed to update a livrete.
     */
    data: XOR<livreteUpdateInput, livreteUncheckedUpdateInput>
    /**
     * Choose, which livrete to update.
     */
    where: livreteWhereUniqueInput
  }

  /**
   * livrete updateMany
   */
  export type livreteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update livretes.
     */
    data: XOR<livreteUpdateManyMutationInput, livreteUncheckedUpdateManyInput>
    /**
     * Filter which livretes to update
     */
    where?: livreteWhereInput
  }

  /**
   * livrete upsert
   */
  export type livreteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the livrete
     */
    select?: livreteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: livreteInclude<ExtArgs> | null
    /**
     * The filter to search for the livrete to update in case it exists.
     */
    where: livreteWhereUniqueInput
    /**
     * In case the livrete found by the `where` argument doesn't exist, create a new livrete with this data.
     */
    create: XOR<livreteCreateInput, livreteUncheckedCreateInput>
    /**
     * In case the livrete was found with the provided `where` argument, update it with this data.
     */
    update: XOR<livreteUpdateInput, livreteUncheckedUpdateInput>
  }

  /**
   * livrete delete
   */
  export type livreteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the livrete
     */
    select?: livreteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: livreteInclude<ExtArgs> | null
    /**
     * Filter which livrete to delete.
     */
    where: livreteWhereUniqueInput
  }

  /**
   * livrete deleteMany
   */
  export type livreteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which livretes to delete
     */
    where?: livreteWhereInput
  }

  /**
   * livrete without action
   */
  export type livreteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the livrete
     */
    select?: livreteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: livreteInclude<ExtArgs> | null
  }


  /**
   * Model marca
   */

  export type AggregateMarca = {
    _count: MarcaCountAggregateOutputType | null
    _avg: MarcaAvgAggregateOutputType | null
    _sum: MarcaSumAggregateOutputType | null
    _min: MarcaMinAggregateOutputType | null
    _max: MarcaMaxAggregateOutputType | null
  }

  export type MarcaAvgAggregateOutputType = {
    codMarca: number | null
  }

  export type MarcaSumAggregateOutputType = {
    codMarca: number | null
  }

  export type MarcaMinAggregateOutputType = {
    codMarca: number | null
    descMarca: string | null
  }

  export type MarcaMaxAggregateOutputType = {
    codMarca: number | null
    descMarca: string | null
  }

  export type MarcaCountAggregateOutputType = {
    codMarca: number
    descMarca: number
    _all: number
  }


  export type MarcaAvgAggregateInputType = {
    codMarca?: true
  }

  export type MarcaSumAggregateInputType = {
    codMarca?: true
  }

  export type MarcaMinAggregateInputType = {
    codMarca?: true
    descMarca?: true
  }

  export type MarcaMaxAggregateInputType = {
    codMarca?: true
    descMarca?: true
  }

  export type MarcaCountAggregateInputType = {
    codMarca?: true
    descMarca?: true
    _all?: true
  }

  export type MarcaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which marca to aggregate.
     */
    where?: marcaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marcas to fetch.
     */
    orderBy?: marcaOrderByWithRelationInput | marcaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: marcaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marcas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marcas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned marcas
    **/
    _count?: true | MarcaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarcaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarcaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarcaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarcaMaxAggregateInputType
  }

  export type GetMarcaAggregateType<T extends MarcaAggregateArgs> = {
        [P in keyof T & keyof AggregateMarca]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarca[P]>
      : GetScalarType<T[P], AggregateMarca[P]>
  }




  export type marcaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: marcaWhereInput
    orderBy?: marcaOrderByWithAggregationInput | marcaOrderByWithAggregationInput[]
    by: MarcaScalarFieldEnum[] | MarcaScalarFieldEnum
    having?: marcaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarcaCountAggregateInputType | true
    _avg?: MarcaAvgAggregateInputType
    _sum?: MarcaSumAggregateInputType
    _min?: MarcaMinAggregateInputType
    _max?: MarcaMaxAggregateInputType
  }

  export type MarcaGroupByOutputType = {
    codMarca: number
    descMarca: string
    _count: MarcaCountAggregateOutputType | null
    _avg: MarcaAvgAggregateOutputType | null
    _sum: MarcaSumAggregateOutputType | null
    _min: MarcaMinAggregateOutputType | null
    _max: MarcaMaxAggregateOutputType | null
  }

  type GetMarcaGroupByPayload<T extends marcaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarcaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarcaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarcaGroupByOutputType[P]>
            : GetScalarType<T[P], MarcaGroupByOutputType[P]>
        }
      >
    >


  export type marcaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codMarca?: boolean
    descMarca?: boolean
    livrete?: boolean | marca$livreteArgs<ExtArgs>
    _count?: boolean | MarcaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marca"]>


  export type marcaSelectScalar = {
    codMarca?: boolean
    descMarca?: boolean
  }

  export type marcaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livrete?: boolean | marca$livreteArgs<ExtArgs>
    _count?: boolean | MarcaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $marcaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "marca"
    objects: {
      livrete: Prisma.$livretePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      codMarca: number
      descMarca: string
    }, ExtArgs["result"]["marca"]>
    composites: {}
  }

  type marcaGetPayload<S extends boolean | null | undefined | marcaDefaultArgs> = $Result.GetResult<Prisma.$marcaPayload, S>

  type marcaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<marcaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarcaCountAggregateInputType | true
    }

  export interface marcaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['marca'], meta: { name: 'marca' } }
    /**
     * Find zero or one Marca that matches the filter.
     * @param {marcaFindUniqueArgs} args - Arguments to find a Marca
     * @example
     * // Get one Marca
     * const marca = await prisma.marca.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends marcaFindUniqueArgs>(args: SelectSubset<T, marcaFindUniqueArgs<ExtArgs>>): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Marca that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {marcaFindUniqueOrThrowArgs} args - Arguments to find a Marca
     * @example
     * // Get one Marca
     * const marca = await prisma.marca.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends marcaFindUniqueOrThrowArgs>(args: SelectSubset<T, marcaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Marca that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marcaFindFirstArgs} args - Arguments to find a Marca
     * @example
     * // Get one Marca
     * const marca = await prisma.marca.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends marcaFindFirstArgs>(args?: SelectSubset<T, marcaFindFirstArgs<ExtArgs>>): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Marca that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marcaFindFirstOrThrowArgs} args - Arguments to find a Marca
     * @example
     * // Get one Marca
     * const marca = await prisma.marca.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends marcaFindFirstOrThrowArgs>(args?: SelectSubset<T, marcaFindFirstOrThrowArgs<ExtArgs>>): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Marcas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marcaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Marcas
     * const marcas = await prisma.marca.findMany()
     * 
     * // Get first 10 Marcas
     * const marcas = await prisma.marca.findMany({ take: 10 })
     * 
     * // Only select the `codMarca`
     * const marcaWithCodMarcaOnly = await prisma.marca.findMany({ select: { codMarca: true } })
     * 
     */
    findMany<T extends marcaFindManyArgs>(args?: SelectSubset<T, marcaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Marca.
     * @param {marcaCreateArgs} args - Arguments to create a Marca.
     * @example
     * // Create one Marca
     * const Marca = await prisma.marca.create({
     *   data: {
     *     // ... data to create a Marca
     *   }
     * })
     * 
     */
    create<T extends marcaCreateArgs>(args: SelectSubset<T, marcaCreateArgs<ExtArgs>>): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Marcas.
     * @param {marcaCreateManyArgs} args - Arguments to create many Marcas.
     * @example
     * // Create many Marcas
     * const marca = await prisma.marca.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends marcaCreateManyArgs>(args?: SelectSubset<T, marcaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Marca.
     * @param {marcaDeleteArgs} args - Arguments to delete one Marca.
     * @example
     * // Delete one Marca
     * const Marca = await prisma.marca.delete({
     *   where: {
     *     // ... filter to delete one Marca
     *   }
     * })
     * 
     */
    delete<T extends marcaDeleteArgs>(args: SelectSubset<T, marcaDeleteArgs<ExtArgs>>): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Marca.
     * @param {marcaUpdateArgs} args - Arguments to update one Marca.
     * @example
     * // Update one Marca
     * const marca = await prisma.marca.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends marcaUpdateArgs>(args: SelectSubset<T, marcaUpdateArgs<ExtArgs>>): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Marcas.
     * @param {marcaDeleteManyArgs} args - Arguments to filter Marcas to delete.
     * @example
     * // Delete a few Marcas
     * const { count } = await prisma.marca.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends marcaDeleteManyArgs>(args?: SelectSubset<T, marcaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marcas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marcaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Marcas
     * const marca = await prisma.marca.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends marcaUpdateManyArgs>(args: SelectSubset<T, marcaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Marca.
     * @param {marcaUpsertArgs} args - Arguments to update or create a Marca.
     * @example
     * // Update or create a Marca
     * const marca = await prisma.marca.upsert({
     *   create: {
     *     // ... data to create a Marca
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Marca we want to update
     *   }
     * })
     */
    upsert<T extends marcaUpsertArgs>(args: SelectSubset<T, marcaUpsertArgs<ExtArgs>>): Prisma__marcaClient<$Result.GetResult<Prisma.$marcaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Marcas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marcaCountArgs} args - Arguments to filter Marcas to count.
     * @example
     * // Count the number of Marcas
     * const count = await prisma.marca.count({
     *   where: {
     *     // ... the filter for the Marcas we want to count
     *   }
     * })
    **/
    count<T extends marcaCountArgs>(
      args?: Subset<T, marcaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarcaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Marca.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarcaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarcaAggregateArgs>(args: Subset<T, MarcaAggregateArgs>): Prisma.PrismaPromise<GetMarcaAggregateType<T>>

    /**
     * Group by Marca.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marcaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends marcaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: marcaGroupByArgs['orderBy'] }
        : { orderBy?: marcaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, marcaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarcaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the marca model
   */
  readonly fields: marcaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for marca.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__marcaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    livrete<T extends marca$livreteArgs<ExtArgs> = {}>(args?: Subset<T, marca$livreteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$livretePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the marca model
   */ 
  interface marcaFieldRefs {
    readonly codMarca: FieldRef<"marca", 'Int'>
    readonly descMarca: FieldRef<"marca", 'String'>
  }
    

  // Custom InputTypes
  /**
   * marca findUnique
   */
  export type marcaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * Filter, which marca to fetch.
     */
    where: marcaWhereUniqueInput
  }

  /**
   * marca findUniqueOrThrow
   */
  export type marcaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * Filter, which marca to fetch.
     */
    where: marcaWhereUniqueInput
  }

  /**
   * marca findFirst
   */
  export type marcaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * Filter, which marca to fetch.
     */
    where?: marcaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marcas to fetch.
     */
    orderBy?: marcaOrderByWithRelationInput | marcaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for marcas.
     */
    cursor?: marcaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marcas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marcas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of marcas.
     */
    distinct?: MarcaScalarFieldEnum | MarcaScalarFieldEnum[]
  }

  /**
   * marca findFirstOrThrow
   */
  export type marcaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * Filter, which marca to fetch.
     */
    where?: marcaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marcas to fetch.
     */
    orderBy?: marcaOrderByWithRelationInput | marcaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for marcas.
     */
    cursor?: marcaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marcas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marcas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of marcas.
     */
    distinct?: MarcaScalarFieldEnum | MarcaScalarFieldEnum[]
  }

  /**
   * marca findMany
   */
  export type marcaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * Filter, which marcas to fetch.
     */
    where?: marcaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marcas to fetch.
     */
    orderBy?: marcaOrderByWithRelationInput | marcaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing marcas.
     */
    cursor?: marcaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marcas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marcas.
     */
    skip?: number
    distinct?: MarcaScalarFieldEnum | MarcaScalarFieldEnum[]
  }

  /**
   * marca create
   */
  export type marcaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * The data needed to create a marca.
     */
    data: XOR<marcaCreateInput, marcaUncheckedCreateInput>
  }

  /**
   * marca createMany
   */
  export type marcaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many marcas.
     */
    data: marcaCreateManyInput | marcaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * marca update
   */
  export type marcaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * The data needed to update a marca.
     */
    data: XOR<marcaUpdateInput, marcaUncheckedUpdateInput>
    /**
     * Choose, which marca to update.
     */
    where: marcaWhereUniqueInput
  }

  /**
   * marca updateMany
   */
  export type marcaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update marcas.
     */
    data: XOR<marcaUpdateManyMutationInput, marcaUncheckedUpdateManyInput>
    /**
     * Filter which marcas to update
     */
    where?: marcaWhereInput
  }

  /**
   * marca upsert
   */
  export type marcaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * The filter to search for the marca to update in case it exists.
     */
    where: marcaWhereUniqueInput
    /**
     * In case the marca found by the `where` argument doesn't exist, create a new marca with this data.
     */
    create: XOR<marcaCreateInput, marcaUncheckedCreateInput>
    /**
     * In case the marca was found with the provided `where` argument, update it with this data.
     */
    update: XOR<marcaUpdateInput, marcaUncheckedUpdateInput>
  }

  /**
   * marca delete
   */
  export type marcaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marcaInclude<ExtArgs> | null
    /**
     * Filter which marca to delete.
     */
    where: marcaWhereUniqueInput
  }

  /**
   * marca deleteMany
   */
  export type marcaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which marcas to delete
     */
    where?: marcaWhereInput
  }

  /**
   * marca.livrete
   */
  export type marca$livreteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the livrete
     */
    select?: livreteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: livreteInclude<ExtArgs> | null
    where?: livreteWhereInput
    orderBy?: livreteOrderByWithRelationInput | livreteOrderByWithRelationInput[]
    cursor?: livreteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LivreteScalarFieldEnum | LivreteScalarFieldEnum[]
  }

  /**
   * marca without action
   */
  export type marcaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marca
     */
    select?: marcaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marcaInclude<ExtArgs> | null
  }


  /**
   * Model multa
   */

  export type AggregateMulta = {
    _count: MultaCountAggregateOutputType | null
    _avg: MultaAvgAggregateOutputType | null
    _sum: MultaSumAggregateOutputType | null
    _min: MultaMinAggregateOutputType | null
    _max: MultaMaxAggregateOutputType | null
  }

  export type MultaAvgAggregateOutputType = {
    codMulta: number | null
    codAutomobilista: number | null
    CodViatura: number | null
    codInfracao: number | null
  }

  export type MultaSumAggregateOutputType = {
    codMulta: number | null
    codAutomobilista: number | null
    CodViatura: number | null
    codInfracao: number | null
  }

  export type MultaMinAggregateOutputType = {
    codMulta: number | null
    codAutomobilista: number | null
    CodViatura: number | null
    codInfracao: number | null
    valorMulta: string | null
    estadoMulta: $Enums.multa_estadoMulta | null
  }

  export type MultaMaxAggregateOutputType = {
    codMulta: number | null
    codAutomobilista: number | null
    CodViatura: number | null
    codInfracao: number | null
    valorMulta: string | null
    estadoMulta: $Enums.multa_estadoMulta | null
  }

  export type MultaCountAggregateOutputType = {
    codMulta: number
    codAutomobilista: number
    CodViatura: number
    codInfracao: number
    valorMulta: number
    estadoMulta: number
    _all: number
  }


  export type MultaAvgAggregateInputType = {
    codMulta?: true
    codAutomobilista?: true
    CodViatura?: true
    codInfracao?: true
  }

  export type MultaSumAggregateInputType = {
    codMulta?: true
    codAutomobilista?: true
    CodViatura?: true
    codInfracao?: true
  }

  export type MultaMinAggregateInputType = {
    codMulta?: true
    codAutomobilista?: true
    CodViatura?: true
    codInfracao?: true
    valorMulta?: true
    estadoMulta?: true
  }

  export type MultaMaxAggregateInputType = {
    codMulta?: true
    codAutomobilista?: true
    CodViatura?: true
    codInfracao?: true
    valorMulta?: true
    estadoMulta?: true
  }

  export type MultaCountAggregateInputType = {
    codMulta?: true
    codAutomobilista?: true
    CodViatura?: true
    codInfracao?: true
    valorMulta?: true
    estadoMulta?: true
    _all?: true
  }

  export type MultaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which multa to aggregate.
     */
    where?: multaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of multas to fetch.
     */
    orderBy?: multaOrderByWithRelationInput | multaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: multaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` multas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` multas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned multas
    **/
    _count?: true | MultaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MultaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MultaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MultaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MultaMaxAggregateInputType
  }

  export type GetMultaAggregateType<T extends MultaAggregateArgs> = {
        [P in keyof T & keyof AggregateMulta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMulta[P]>
      : GetScalarType<T[P], AggregateMulta[P]>
  }




  export type multaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: multaWhereInput
    orderBy?: multaOrderByWithAggregationInput | multaOrderByWithAggregationInput[]
    by: MultaScalarFieldEnum[] | MultaScalarFieldEnum
    having?: multaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MultaCountAggregateInputType | true
    _avg?: MultaAvgAggregateInputType
    _sum?: MultaSumAggregateInputType
    _min?: MultaMinAggregateInputType
    _max?: MultaMaxAggregateInputType
  }

  export type MultaGroupByOutputType = {
    codMulta: number
    codAutomobilista: number | null
    CodViatura: number | null
    codInfracao: number
    valorMulta: string
    estadoMulta: $Enums.multa_estadoMulta
    _count: MultaCountAggregateOutputType | null
    _avg: MultaAvgAggregateOutputType | null
    _sum: MultaSumAggregateOutputType | null
    _min: MultaMinAggregateOutputType | null
    _max: MultaMaxAggregateOutputType | null
  }

  type GetMultaGroupByPayload<T extends multaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MultaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MultaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MultaGroupByOutputType[P]>
            : GetScalarType<T[P], MultaGroupByOutputType[P]>
        }
      >
    >


  export type multaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codMulta?: boolean
    codAutomobilista?: boolean
    CodViatura?: boolean
    codInfracao?: boolean
    valorMulta?: boolean
    estadoMulta?: boolean
    infracao_infracao_codMultaTomulta?: boolean | multa$infracao_infracao_codMultaTomultaArgs<ExtArgs>
    automobilista?: boolean | multa$automobilistaArgs<ExtArgs>
    infracao_multa_codInfracaoToinfracao?: boolean | infracaoDefaultArgs<ExtArgs>
    viatura?: boolean | multa$viaturaArgs<ExtArgs>
    pagamentomulta?: boolean | multa$pagamentomultaArgs<ExtArgs>
    _count?: boolean | MultaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multa"]>


  export type multaSelectScalar = {
    codMulta?: boolean
    codAutomobilista?: boolean
    CodViatura?: boolean
    codInfracao?: boolean
    valorMulta?: boolean
    estadoMulta?: boolean
  }

  export type multaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    infracao_infracao_codMultaTomulta?: boolean | multa$infracao_infracao_codMultaTomultaArgs<ExtArgs>
    automobilista?: boolean | multa$automobilistaArgs<ExtArgs>
    infracao_multa_codInfracaoToinfracao?: boolean | infracaoDefaultArgs<ExtArgs>
    viatura?: boolean | multa$viaturaArgs<ExtArgs>
    pagamentomulta?: boolean | multa$pagamentomultaArgs<ExtArgs>
    _count?: boolean | MultaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $multaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "multa"
    objects: {
      infracao_infracao_codMultaTomulta: Prisma.$infracaoPayload<ExtArgs>[]
      automobilista: Prisma.$automobilistaPayload<ExtArgs> | null
      infracao_multa_codInfracaoToinfracao: Prisma.$infracaoPayload<ExtArgs>
      viatura: Prisma.$viaturaPayload<ExtArgs> | null
      pagamentomulta: Prisma.$pagamentomultaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      codMulta: number
      codAutomobilista: number | null
      CodViatura: number | null
      codInfracao: number
      valorMulta: string
      estadoMulta: $Enums.multa_estadoMulta
    }, ExtArgs["result"]["multa"]>
    composites: {}
  }

  type multaGetPayload<S extends boolean | null | undefined | multaDefaultArgs> = $Result.GetResult<Prisma.$multaPayload, S>

  type multaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<multaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MultaCountAggregateInputType | true
    }

  export interface multaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['multa'], meta: { name: 'multa' } }
    /**
     * Find zero or one Multa that matches the filter.
     * @param {multaFindUniqueArgs} args - Arguments to find a Multa
     * @example
     * // Get one Multa
     * const multa = await prisma.multa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends multaFindUniqueArgs>(args: SelectSubset<T, multaFindUniqueArgs<ExtArgs>>): Prisma__multaClient<$Result.GetResult<Prisma.$multaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Multa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {multaFindUniqueOrThrowArgs} args - Arguments to find a Multa
     * @example
     * // Get one Multa
     * const multa = await prisma.multa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends multaFindUniqueOrThrowArgs>(args: SelectSubset<T, multaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__multaClient<$Result.GetResult<Prisma.$multaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Multa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {multaFindFirstArgs} args - Arguments to find a Multa
     * @example
     * // Get one Multa
     * const multa = await prisma.multa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends multaFindFirstArgs>(args?: SelectSubset<T, multaFindFirstArgs<ExtArgs>>): Prisma__multaClient<$Result.GetResult<Prisma.$multaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Multa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {multaFindFirstOrThrowArgs} args - Arguments to find a Multa
     * @example
     * // Get one Multa
     * const multa = await prisma.multa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends multaFindFirstOrThrowArgs>(args?: SelectSubset<T, multaFindFirstOrThrowArgs<ExtArgs>>): Prisma__multaClient<$Result.GetResult<Prisma.$multaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Multas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {multaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Multas
     * const multas = await prisma.multa.findMany()
     * 
     * // Get first 10 Multas
     * const multas = await prisma.multa.findMany({ take: 10 })
     * 
     * // Only select the `codMulta`
     * const multaWithCodMultaOnly = await prisma.multa.findMany({ select: { codMulta: true } })
     * 
     */
    findMany<T extends multaFindManyArgs>(args?: SelectSubset<T, multaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$multaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Multa.
     * @param {multaCreateArgs} args - Arguments to create a Multa.
     * @example
     * // Create one Multa
     * const Multa = await prisma.multa.create({
     *   data: {
     *     // ... data to create a Multa
     *   }
     * })
     * 
     */
    create<T extends multaCreateArgs>(args: SelectSubset<T, multaCreateArgs<ExtArgs>>): Prisma__multaClient<$Result.GetResult<Prisma.$multaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Multas.
     * @param {multaCreateManyArgs} args - Arguments to create many Multas.
     * @example
     * // Create many Multas
     * const multa = await prisma.multa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends multaCreateManyArgs>(args?: SelectSubset<T, multaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Multa.
     * @param {multaDeleteArgs} args - Arguments to delete one Multa.
     * @example
     * // Delete one Multa
     * const Multa = await prisma.multa.delete({
     *   where: {
     *     // ... filter to delete one Multa
     *   }
     * })
     * 
     */
    delete<T extends multaDeleteArgs>(args: SelectSubset<T, multaDeleteArgs<ExtArgs>>): Prisma__multaClient<$Result.GetResult<Prisma.$multaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Multa.
     * @param {multaUpdateArgs} args - Arguments to update one Multa.
     * @example
     * // Update one Multa
     * const multa = await prisma.multa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends multaUpdateArgs>(args: SelectSubset<T, multaUpdateArgs<ExtArgs>>): Prisma__multaClient<$Result.GetResult<Prisma.$multaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Multas.
     * @param {multaDeleteManyArgs} args - Arguments to filter Multas to delete.
     * @example
     * // Delete a few Multas
     * const { count } = await prisma.multa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends multaDeleteManyArgs>(args?: SelectSubset<T, multaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Multas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {multaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Multas
     * const multa = await prisma.multa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends multaUpdateManyArgs>(args: SelectSubset<T, multaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Multa.
     * @param {multaUpsertArgs} args - Arguments to update or create a Multa.
     * @example
     * // Update or create a Multa
     * const multa = await prisma.multa.upsert({
     *   create: {
     *     // ... data to create a Multa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Multa we want to update
     *   }
     * })
     */
    upsert<T extends multaUpsertArgs>(args: SelectSubset<T, multaUpsertArgs<ExtArgs>>): Prisma__multaClient<$Result.GetResult<Prisma.$multaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Multas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {multaCountArgs} args - Arguments to filter Multas to count.
     * @example
     * // Count the number of Multas
     * const count = await prisma.multa.count({
     *   where: {
     *     // ... the filter for the Multas we want to count
     *   }
     * })
    **/
    count<T extends multaCountArgs>(
      args?: Subset<T, multaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MultaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Multa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MultaAggregateArgs>(args: Subset<T, MultaAggregateArgs>): Prisma.PrismaPromise<GetMultaAggregateType<T>>

    /**
     * Group by Multa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {multaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends multaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: multaGroupByArgs['orderBy'] }
        : { orderBy?: multaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, multaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMultaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the multa model
   */
  readonly fields: multaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for multa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__multaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    infracao_infracao_codMultaTomulta<T extends multa$infracao_infracao_codMultaTomultaArgs<ExtArgs> = {}>(args?: Subset<T, multa$infracao_infracao_codMultaTomultaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$infracaoPayload<ExtArgs>, T, "findMany"> | Null>
    automobilista<T extends multa$automobilistaArgs<ExtArgs> = {}>(args?: Subset<T, multa$automobilistaArgs<ExtArgs>>): Prisma__automobilistaClient<$Result.GetResult<Prisma.$automobilistaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    infracao_multa_codInfracaoToinfracao<T extends infracaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, infracaoDefaultArgs<ExtArgs>>): Prisma__infracaoClient<$Result.GetResult<Prisma.$infracaoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    viatura<T extends multa$viaturaArgs<ExtArgs> = {}>(args?: Subset<T, multa$viaturaArgs<ExtArgs>>): Prisma__viaturaClient<$Result.GetResult<Prisma.$viaturaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    pagamentomulta<T extends multa$pagamentomultaArgs<ExtArgs> = {}>(args?: Subset<T, multa$pagamentomultaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagamentomultaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the multa model
   */ 
  interface multaFieldRefs {
    readonly codMulta: FieldRef<"multa", 'Int'>
    readonly codAutomobilista: FieldRef<"multa", 'Int'>
    readonly CodViatura: FieldRef<"multa", 'Int'>
    readonly codInfracao: FieldRef<"multa", 'Int'>
    readonly valorMulta: FieldRef<"multa", 'String'>
    readonly estadoMulta: FieldRef<"multa", 'multa_estadoMulta'>
  }
    

  // Custom InputTypes
  /**
   * multa findUnique
   */
  export type multaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multa
     */
    select?: multaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: multaInclude<ExtArgs> | null
    /**
     * Filter, which multa to fetch.
     */
    where: multaWhereUniqueInput
  }

  /**
   * multa findUniqueOrThrow
   */
  export type multaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multa
     */
    select?: multaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: multaInclude<ExtArgs> | null
    /**
     * Filter, which multa to fetch.
     */
    where: multaWhereUniqueInput
  }

  /**
   * multa findFirst
   */
  export type multaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multa
     */
    select?: multaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: multaInclude<ExtArgs> | null
    /**
     * Filter, which multa to fetch.
     */
    where?: multaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of multas to fetch.
     */
    orderBy?: multaOrderByWithRelationInput | multaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for multas.
     */
    cursor?: multaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` multas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` multas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of multas.
     */
    distinct?: MultaScalarFieldEnum | MultaScalarFieldEnum[]
  }

  /**
   * multa findFirstOrThrow
   */
  export type multaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multa
     */
    select?: multaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: multaInclude<ExtArgs> | null
    /**
     * Filter, which multa to fetch.
     */
    where?: multaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of multas to fetch.
     */
    orderBy?: multaOrderByWithRelationInput | multaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for multas.
     */
    cursor?: multaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` multas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` multas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of multas.
     */
    distinct?: MultaScalarFieldEnum | MultaScalarFieldEnum[]
  }

  /**
   * multa findMany
   */
  export type multaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multa
     */
    select?: multaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: multaInclude<ExtArgs> | null
    /**
     * Filter, which multas to fetch.
     */
    where?: multaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of multas to fetch.
     */
    orderBy?: multaOrderByWithRelationInput | multaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing multas.
     */
    cursor?: multaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` multas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` multas.
     */
    skip?: number
    distinct?: MultaScalarFieldEnum | MultaScalarFieldEnum[]
  }

  /**
   * multa create
   */
  export type multaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multa
     */
    select?: multaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: multaInclude<ExtArgs> | null
    /**
     * The data needed to create a multa.
     */
    data: XOR<multaCreateInput, multaUncheckedCreateInput>
  }

  /**
   * multa createMany
   */
  export type multaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many multas.
     */
    data: multaCreateManyInput | multaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * multa update
   */
  export type multaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multa
     */
    select?: multaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: multaInclude<ExtArgs> | null
    /**
     * The data needed to update a multa.
     */
    data: XOR<multaUpdateInput, multaUncheckedUpdateInput>
    /**
     * Choose, which multa to update.
     */
    where: multaWhereUniqueInput
  }

  /**
   * multa updateMany
   */
  export type multaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update multas.
     */
    data: XOR<multaUpdateManyMutationInput, multaUncheckedUpdateManyInput>
    /**
     * Filter which multas to update
     */
    where?: multaWhereInput
  }

  /**
   * multa upsert
   */
  export type multaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multa
     */
    select?: multaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: multaInclude<ExtArgs> | null
    /**
     * The filter to search for the multa to update in case it exists.
     */
    where: multaWhereUniqueInput
    /**
     * In case the multa found by the `where` argument doesn't exist, create a new multa with this data.
     */
    create: XOR<multaCreateInput, multaUncheckedCreateInput>
    /**
     * In case the multa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<multaUpdateInput, multaUncheckedUpdateInput>
  }

  /**
   * multa delete
   */
  export type multaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multa
     */
    select?: multaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: multaInclude<ExtArgs> | null
    /**
     * Filter which multa to delete.
     */
    where: multaWhereUniqueInput
  }

  /**
   * multa deleteMany
   */
  export type multaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which multas to delete
     */
    where?: multaWhereInput
  }

  /**
   * multa.infracao_infracao_codMultaTomulta
   */
  export type multa$infracao_infracao_codMultaTomultaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infracao
     */
    select?: infracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: infracaoInclude<ExtArgs> | null
    where?: infracaoWhereInput
    orderBy?: infracaoOrderByWithRelationInput | infracaoOrderByWithRelationInput[]
    cursor?: infracaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InfracaoScalarFieldEnum | InfracaoScalarFieldEnum[]
  }

  /**
   * multa.automobilista
   */
  export type multa$automobilistaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the automobilista
     */
    select?: automobilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: automobilistaInclude<ExtArgs> | null
    where?: automobilistaWhereInput
  }

  /**
   * multa.viatura
   */
  export type multa$viaturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viatura
     */
    select?: viaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viaturaInclude<ExtArgs> | null
    where?: viaturaWhereInput
  }

  /**
   * multa.pagamentomulta
   */
  export type multa$pagamentomultaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentomulta
     */
    select?: pagamentomultaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagamentomultaInclude<ExtArgs> | null
    where?: pagamentomultaWhereInput
    orderBy?: pagamentomultaOrderByWithRelationInput | pagamentomultaOrderByWithRelationInput[]
    cursor?: pagamentomultaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagamentomultaScalarFieldEnum | PagamentomultaScalarFieldEnum[]
  }

  /**
   * multa without action
   */
  export type multaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multa
     */
    select?: multaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: multaInclude<ExtArgs> | null
  }


  /**
   * Model municipio
   */

  export type AggregateMunicipio = {
    _count: MunicipioCountAggregateOutputType | null
    _avg: MunicipioAvgAggregateOutputType | null
    _sum: MunicipioSumAggregateOutputType | null
    _min: MunicipioMinAggregateOutputType | null
    _max: MunicipioMaxAggregateOutputType | null
  }

  export type MunicipioAvgAggregateOutputType = {
    idMunicipio: number | null
    idProvincia: number | null
  }

  export type MunicipioSumAggregateOutputType = {
    idMunicipio: number | null
    idProvincia: number | null
  }

  export type MunicipioMinAggregateOutputType = {
    idMunicipio: number | null
    idProvincia: number | null
    municipio: string | null
  }

  export type MunicipioMaxAggregateOutputType = {
    idMunicipio: number | null
    idProvincia: number | null
    municipio: string | null
  }

  export type MunicipioCountAggregateOutputType = {
    idMunicipio: number
    idProvincia: number
    municipio: number
    _all: number
  }


  export type MunicipioAvgAggregateInputType = {
    idMunicipio?: true
    idProvincia?: true
  }

  export type MunicipioSumAggregateInputType = {
    idMunicipio?: true
    idProvincia?: true
  }

  export type MunicipioMinAggregateInputType = {
    idMunicipio?: true
    idProvincia?: true
    municipio?: true
  }

  export type MunicipioMaxAggregateInputType = {
    idMunicipio?: true
    idProvincia?: true
    municipio?: true
  }

  export type MunicipioCountAggregateInputType = {
    idMunicipio?: true
    idProvincia?: true
    municipio?: true
    _all?: true
  }

  export type MunicipioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which municipio to aggregate.
     */
    where?: municipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of municipios to fetch.
     */
    orderBy?: municipioOrderByWithRelationInput | municipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: municipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` municipios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned municipios
    **/
    _count?: true | MunicipioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MunicipioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MunicipioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MunicipioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MunicipioMaxAggregateInputType
  }

  export type GetMunicipioAggregateType<T extends MunicipioAggregateArgs> = {
        [P in keyof T & keyof AggregateMunicipio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMunicipio[P]>
      : GetScalarType<T[P], AggregateMunicipio[P]>
  }




  export type municipioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: municipioWhereInput
    orderBy?: municipioOrderByWithAggregationInput | municipioOrderByWithAggregationInput[]
    by: MunicipioScalarFieldEnum[] | MunicipioScalarFieldEnum
    having?: municipioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MunicipioCountAggregateInputType | true
    _avg?: MunicipioAvgAggregateInputType
    _sum?: MunicipioSumAggregateInputType
    _min?: MunicipioMinAggregateInputType
    _max?: MunicipioMaxAggregateInputType
  }

  export type MunicipioGroupByOutputType = {
    idMunicipio: number
    idProvincia: number
    municipio: string
    _count: MunicipioCountAggregateOutputType | null
    _avg: MunicipioAvgAggregateOutputType | null
    _sum: MunicipioSumAggregateOutputType | null
    _min: MunicipioMinAggregateOutputType | null
    _max: MunicipioMaxAggregateOutputType | null
  }

  type GetMunicipioGroupByPayload<T extends municipioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MunicipioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MunicipioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MunicipioGroupByOutputType[P]>
            : GetScalarType<T[P], MunicipioGroupByOutputType[P]>
        }
      >
    >


  export type municipioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idMunicipio?: boolean
    idProvincia?: boolean
    municipio?: boolean
    endereco?: boolean | municipio$enderecoArgs<ExtArgs>
    provincia?: boolean | provinciaDefaultArgs<ExtArgs>
    _count?: boolean | MunicipioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["municipio"]>


  export type municipioSelectScalar = {
    idMunicipio?: boolean
    idProvincia?: boolean
    municipio?: boolean
  }

  export type municipioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | municipio$enderecoArgs<ExtArgs>
    provincia?: boolean | provinciaDefaultArgs<ExtArgs>
    _count?: boolean | MunicipioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $municipioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "municipio"
    objects: {
      endereco: Prisma.$enderecoPayload<ExtArgs>[]
      provincia: Prisma.$provinciaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idMunicipio: number
      idProvincia: number
      municipio: string
    }, ExtArgs["result"]["municipio"]>
    composites: {}
  }

  type municipioGetPayload<S extends boolean | null | undefined | municipioDefaultArgs> = $Result.GetResult<Prisma.$municipioPayload, S>

  type municipioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<municipioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MunicipioCountAggregateInputType | true
    }

  export interface municipioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['municipio'], meta: { name: 'municipio' } }
    /**
     * Find zero or one Municipio that matches the filter.
     * @param {municipioFindUniqueArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends municipioFindUniqueArgs>(args: SelectSubset<T, municipioFindUniqueArgs<ExtArgs>>): Prisma__municipioClient<$Result.GetResult<Prisma.$municipioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Municipio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {municipioFindUniqueOrThrowArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends municipioFindUniqueOrThrowArgs>(args: SelectSubset<T, municipioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__municipioClient<$Result.GetResult<Prisma.$municipioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Municipio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {municipioFindFirstArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends municipioFindFirstArgs>(args?: SelectSubset<T, municipioFindFirstArgs<ExtArgs>>): Prisma__municipioClient<$Result.GetResult<Prisma.$municipioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Municipio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {municipioFindFirstOrThrowArgs} args - Arguments to find a Municipio
     * @example
     * // Get one Municipio
     * const municipio = await prisma.municipio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends municipioFindFirstOrThrowArgs>(args?: SelectSubset<T, municipioFindFirstOrThrowArgs<ExtArgs>>): Prisma__municipioClient<$Result.GetResult<Prisma.$municipioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Municipios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {municipioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Municipios
     * const municipios = await prisma.municipio.findMany()
     * 
     * // Get first 10 Municipios
     * const municipios = await prisma.municipio.findMany({ take: 10 })
     * 
     * // Only select the `idMunicipio`
     * const municipioWithIdMunicipioOnly = await prisma.municipio.findMany({ select: { idMunicipio: true } })
     * 
     */
    findMany<T extends municipioFindManyArgs>(args?: SelectSubset<T, municipioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$municipioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Municipio.
     * @param {municipioCreateArgs} args - Arguments to create a Municipio.
     * @example
     * // Create one Municipio
     * const Municipio = await prisma.municipio.create({
     *   data: {
     *     // ... data to create a Municipio
     *   }
     * })
     * 
     */
    create<T extends municipioCreateArgs>(args: SelectSubset<T, municipioCreateArgs<ExtArgs>>): Prisma__municipioClient<$Result.GetResult<Prisma.$municipioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Municipios.
     * @param {municipioCreateManyArgs} args - Arguments to create many Municipios.
     * @example
     * // Create many Municipios
     * const municipio = await prisma.municipio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends municipioCreateManyArgs>(args?: SelectSubset<T, municipioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Municipio.
     * @param {municipioDeleteArgs} args - Arguments to delete one Municipio.
     * @example
     * // Delete one Municipio
     * const Municipio = await prisma.municipio.delete({
     *   where: {
     *     // ... filter to delete one Municipio
     *   }
     * })
     * 
     */
    delete<T extends municipioDeleteArgs>(args: SelectSubset<T, municipioDeleteArgs<ExtArgs>>): Prisma__municipioClient<$Result.GetResult<Prisma.$municipioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Municipio.
     * @param {municipioUpdateArgs} args - Arguments to update one Municipio.
     * @example
     * // Update one Municipio
     * const municipio = await prisma.municipio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends municipioUpdateArgs>(args: SelectSubset<T, municipioUpdateArgs<ExtArgs>>): Prisma__municipioClient<$Result.GetResult<Prisma.$municipioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Municipios.
     * @param {municipioDeleteManyArgs} args - Arguments to filter Municipios to delete.
     * @example
     * // Delete a few Municipios
     * const { count } = await prisma.municipio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends municipioDeleteManyArgs>(args?: SelectSubset<T, municipioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Municipios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {municipioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Municipios
     * const municipio = await prisma.municipio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends municipioUpdateManyArgs>(args: SelectSubset<T, municipioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Municipio.
     * @param {municipioUpsertArgs} args - Arguments to update or create a Municipio.
     * @example
     * // Update or create a Municipio
     * const municipio = await prisma.municipio.upsert({
     *   create: {
     *     // ... data to create a Municipio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Municipio we want to update
     *   }
     * })
     */
    upsert<T extends municipioUpsertArgs>(args: SelectSubset<T, municipioUpsertArgs<ExtArgs>>): Prisma__municipioClient<$Result.GetResult<Prisma.$municipioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Municipios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {municipioCountArgs} args - Arguments to filter Municipios to count.
     * @example
     * // Count the number of Municipios
     * const count = await prisma.municipio.count({
     *   where: {
     *     // ... the filter for the Municipios we want to count
     *   }
     * })
    **/
    count<T extends municipioCountArgs>(
      args?: Subset<T, municipioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MunicipioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Municipio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MunicipioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MunicipioAggregateArgs>(args: Subset<T, MunicipioAggregateArgs>): Prisma.PrismaPromise<GetMunicipioAggregateType<T>>

    /**
     * Group by Municipio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {municipioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends municipioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: municipioGroupByArgs['orderBy'] }
        : { orderBy?: municipioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, municipioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMunicipioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the municipio model
   */
  readonly fields: municipioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for municipio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__municipioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    endereco<T extends municipio$enderecoArgs<ExtArgs> = {}>(args?: Subset<T, municipio$enderecoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "findMany"> | Null>
    provincia<T extends provinciaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, provinciaDefaultArgs<ExtArgs>>): Prisma__provinciaClient<$Result.GetResult<Prisma.$provinciaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the municipio model
   */ 
  interface municipioFieldRefs {
    readonly idMunicipio: FieldRef<"municipio", 'Int'>
    readonly idProvincia: FieldRef<"municipio", 'Int'>
    readonly municipio: FieldRef<"municipio", 'String'>
  }
    

  // Custom InputTypes
  /**
   * municipio findUnique
   */
  export type municipioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipio
     */
    select?: municipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: municipioInclude<ExtArgs> | null
    /**
     * Filter, which municipio to fetch.
     */
    where: municipioWhereUniqueInput
  }

  /**
   * municipio findUniqueOrThrow
   */
  export type municipioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipio
     */
    select?: municipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: municipioInclude<ExtArgs> | null
    /**
     * Filter, which municipio to fetch.
     */
    where: municipioWhereUniqueInput
  }

  /**
   * municipio findFirst
   */
  export type municipioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipio
     */
    select?: municipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: municipioInclude<ExtArgs> | null
    /**
     * Filter, which municipio to fetch.
     */
    where?: municipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of municipios to fetch.
     */
    orderBy?: municipioOrderByWithRelationInput | municipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for municipios.
     */
    cursor?: municipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` municipios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of municipios.
     */
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * municipio findFirstOrThrow
   */
  export type municipioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipio
     */
    select?: municipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: municipioInclude<ExtArgs> | null
    /**
     * Filter, which municipio to fetch.
     */
    where?: municipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of municipios to fetch.
     */
    orderBy?: municipioOrderByWithRelationInput | municipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for municipios.
     */
    cursor?: municipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` municipios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of municipios.
     */
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * municipio findMany
   */
  export type municipioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipio
     */
    select?: municipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: municipioInclude<ExtArgs> | null
    /**
     * Filter, which municipios to fetch.
     */
    where?: municipioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of municipios to fetch.
     */
    orderBy?: municipioOrderByWithRelationInput | municipioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing municipios.
     */
    cursor?: municipioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` municipios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` municipios.
     */
    skip?: number
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * municipio create
   */
  export type municipioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipio
     */
    select?: municipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: municipioInclude<ExtArgs> | null
    /**
     * The data needed to create a municipio.
     */
    data: XOR<municipioCreateInput, municipioUncheckedCreateInput>
  }

  /**
   * municipio createMany
   */
  export type municipioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many municipios.
     */
    data: municipioCreateManyInput | municipioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * municipio update
   */
  export type municipioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipio
     */
    select?: municipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: municipioInclude<ExtArgs> | null
    /**
     * The data needed to update a municipio.
     */
    data: XOR<municipioUpdateInput, municipioUncheckedUpdateInput>
    /**
     * Choose, which municipio to update.
     */
    where: municipioWhereUniqueInput
  }

  /**
   * municipio updateMany
   */
  export type municipioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update municipios.
     */
    data: XOR<municipioUpdateManyMutationInput, municipioUncheckedUpdateManyInput>
    /**
     * Filter which municipios to update
     */
    where?: municipioWhereInput
  }

  /**
   * municipio upsert
   */
  export type municipioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipio
     */
    select?: municipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: municipioInclude<ExtArgs> | null
    /**
     * The filter to search for the municipio to update in case it exists.
     */
    where: municipioWhereUniqueInput
    /**
     * In case the municipio found by the `where` argument doesn't exist, create a new municipio with this data.
     */
    create: XOR<municipioCreateInput, municipioUncheckedCreateInput>
    /**
     * In case the municipio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<municipioUpdateInput, municipioUncheckedUpdateInput>
  }

  /**
   * municipio delete
   */
  export type municipioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipio
     */
    select?: municipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: municipioInclude<ExtArgs> | null
    /**
     * Filter which municipio to delete.
     */
    where: municipioWhereUniqueInput
  }

  /**
   * municipio deleteMany
   */
  export type municipioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which municipios to delete
     */
    where?: municipioWhereInput
  }

  /**
   * municipio.endereco
   */
  export type municipio$enderecoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    where?: enderecoWhereInput
    orderBy?: enderecoOrderByWithRelationInput | enderecoOrderByWithRelationInput[]
    cursor?: enderecoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * municipio without action
   */
  export type municipioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipio
     */
    select?: municipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: municipioInclude<ExtArgs> | null
  }


  /**
   * Model pagamentomulta
   */

  export type AggregatePagamentomulta = {
    _count: PagamentomultaCountAggregateOutputType | null
    _avg: PagamentomultaAvgAggregateOutputType | null
    _sum: PagamentomultaSumAggregateOutputType | null
    _min: PagamentomultaMinAggregateOutputType | null
    _max: PagamentomultaMaxAggregateOutputType | null
  }

  export type PagamentomultaAvgAggregateOutputType = {
    codPagamentoMulta: number | null
    codMulta: number | null
    codFicheiroPagamento: number | null
  }

  export type PagamentomultaSumAggregateOutputType = {
    codPagamentoMulta: number | null
    codMulta: number | null
    codFicheiroPagamento: number | null
  }

  export type PagamentomultaMinAggregateOutputType = {
    codPagamentoMulta: number | null
    codMulta: number | null
    dataPagamento: Date | null
    valorPago: string | null
    descCodigoDeposito: string | null
    codFicheiroPagamento: number | null
  }

  export type PagamentomultaMaxAggregateOutputType = {
    codPagamentoMulta: number | null
    codMulta: number | null
    dataPagamento: Date | null
    valorPago: string | null
    descCodigoDeposito: string | null
    codFicheiroPagamento: number | null
  }

  export type PagamentomultaCountAggregateOutputType = {
    codPagamentoMulta: number
    codMulta: number
    dataPagamento: number
    valorPago: number
    descCodigoDeposito: number
    codFicheiroPagamento: number
    _all: number
  }


  export type PagamentomultaAvgAggregateInputType = {
    codPagamentoMulta?: true
    codMulta?: true
    codFicheiroPagamento?: true
  }

  export type PagamentomultaSumAggregateInputType = {
    codPagamentoMulta?: true
    codMulta?: true
    codFicheiroPagamento?: true
  }

  export type PagamentomultaMinAggregateInputType = {
    codPagamentoMulta?: true
    codMulta?: true
    dataPagamento?: true
    valorPago?: true
    descCodigoDeposito?: true
    codFicheiroPagamento?: true
  }

  export type PagamentomultaMaxAggregateInputType = {
    codPagamentoMulta?: true
    codMulta?: true
    dataPagamento?: true
    valorPago?: true
    descCodigoDeposito?: true
    codFicheiroPagamento?: true
  }

  export type PagamentomultaCountAggregateInputType = {
    codPagamentoMulta?: true
    codMulta?: true
    dataPagamento?: true
    valorPago?: true
    descCodigoDeposito?: true
    codFicheiroPagamento?: true
    _all?: true
  }

  export type PagamentomultaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pagamentomulta to aggregate.
     */
    where?: pagamentomultaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagamentomultas to fetch.
     */
    orderBy?: pagamentomultaOrderByWithRelationInput | pagamentomultaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pagamentomultaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagamentomultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagamentomultas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pagamentomultas
    **/
    _count?: true | PagamentomultaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagamentomultaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagamentomultaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagamentomultaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagamentomultaMaxAggregateInputType
  }

  export type GetPagamentomultaAggregateType<T extends PagamentomultaAggregateArgs> = {
        [P in keyof T & keyof AggregatePagamentomulta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePagamentomulta[P]>
      : GetScalarType<T[P], AggregatePagamentomulta[P]>
  }




  export type pagamentomultaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pagamentomultaWhereInput
    orderBy?: pagamentomultaOrderByWithAggregationInput | pagamentomultaOrderByWithAggregationInput[]
    by: PagamentomultaScalarFieldEnum[] | PagamentomultaScalarFieldEnum
    having?: pagamentomultaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagamentomultaCountAggregateInputType | true
    _avg?: PagamentomultaAvgAggregateInputType
    _sum?: PagamentomultaSumAggregateInputType
    _min?: PagamentomultaMinAggregateInputType
    _max?: PagamentomultaMaxAggregateInputType
  }

  export type PagamentomultaGroupByOutputType = {
    codPagamentoMulta: number
    codMulta: number
    dataPagamento: Date
    valorPago: string
    descCodigoDeposito: string
    codFicheiroPagamento: number
    _count: PagamentomultaCountAggregateOutputType | null
    _avg: PagamentomultaAvgAggregateOutputType | null
    _sum: PagamentomultaSumAggregateOutputType | null
    _min: PagamentomultaMinAggregateOutputType | null
    _max: PagamentomultaMaxAggregateOutputType | null
  }

  type GetPagamentomultaGroupByPayload<T extends pagamentomultaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagamentomultaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagamentomultaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagamentomultaGroupByOutputType[P]>
            : GetScalarType<T[P], PagamentomultaGroupByOutputType[P]>
        }
      >
    >


  export type pagamentomultaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codPagamentoMulta?: boolean
    codMulta?: boolean
    dataPagamento?: boolean
    valorPago?: boolean
    descCodigoDeposito?: boolean
    codFicheiroPagamento?: boolean
    multa?: boolean | multaDefaultArgs<ExtArgs>
    ficheiro?: boolean | ficheiroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagamentomulta"]>


  export type pagamentomultaSelectScalar = {
    codPagamentoMulta?: boolean
    codMulta?: boolean
    dataPagamento?: boolean
    valorPago?: boolean
    descCodigoDeposito?: boolean
    codFicheiroPagamento?: boolean
  }

  export type pagamentomultaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    multa?: boolean | multaDefaultArgs<ExtArgs>
    ficheiro?: boolean | ficheiroDefaultArgs<ExtArgs>
  }

  export type $pagamentomultaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pagamentomulta"
    objects: {
      multa: Prisma.$multaPayload<ExtArgs>
      ficheiro: Prisma.$ficheiroPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      codPagamentoMulta: number
      codMulta: number
      dataPagamento: Date
      valorPago: string
      descCodigoDeposito: string
      codFicheiroPagamento: number
    }, ExtArgs["result"]["pagamentomulta"]>
    composites: {}
  }

  type pagamentomultaGetPayload<S extends boolean | null | undefined | pagamentomultaDefaultArgs> = $Result.GetResult<Prisma.$pagamentomultaPayload, S>

  type pagamentomultaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pagamentomultaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PagamentomultaCountAggregateInputType | true
    }

  export interface pagamentomultaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pagamentomulta'], meta: { name: 'pagamentomulta' } }
    /**
     * Find zero or one Pagamentomulta that matches the filter.
     * @param {pagamentomultaFindUniqueArgs} args - Arguments to find a Pagamentomulta
     * @example
     * // Get one Pagamentomulta
     * const pagamentomulta = await prisma.pagamentomulta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pagamentomultaFindUniqueArgs>(args: SelectSubset<T, pagamentomultaFindUniqueArgs<ExtArgs>>): Prisma__pagamentomultaClient<$Result.GetResult<Prisma.$pagamentomultaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pagamentomulta that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pagamentomultaFindUniqueOrThrowArgs} args - Arguments to find a Pagamentomulta
     * @example
     * // Get one Pagamentomulta
     * const pagamentomulta = await prisma.pagamentomulta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pagamentomultaFindUniqueOrThrowArgs>(args: SelectSubset<T, pagamentomultaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pagamentomultaClient<$Result.GetResult<Prisma.$pagamentomultaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pagamentomulta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagamentomultaFindFirstArgs} args - Arguments to find a Pagamentomulta
     * @example
     * // Get one Pagamentomulta
     * const pagamentomulta = await prisma.pagamentomulta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pagamentomultaFindFirstArgs>(args?: SelectSubset<T, pagamentomultaFindFirstArgs<ExtArgs>>): Prisma__pagamentomultaClient<$Result.GetResult<Prisma.$pagamentomultaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pagamentomulta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagamentomultaFindFirstOrThrowArgs} args - Arguments to find a Pagamentomulta
     * @example
     * // Get one Pagamentomulta
     * const pagamentomulta = await prisma.pagamentomulta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pagamentomultaFindFirstOrThrowArgs>(args?: SelectSubset<T, pagamentomultaFindFirstOrThrowArgs<ExtArgs>>): Prisma__pagamentomultaClient<$Result.GetResult<Prisma.$pagamentomultaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pagamentomultas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagamentomultaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagamentomultas
     * const pagamentomultas = await prisma.pagamentomulta.findMany()
     * 
     * // Get first 10 Pagamentomultas
     * const pagamentomultas = await prisma.pagamentomulta.findMany({ take: 10 })
     * 
     * // Only select the `codPagamentoMulta`
     * const pagamentomultaWithCodPagamentoMultaOnly = await prisma.pagamentomulta.findMany({ select: { codPagamentoMulta: true } })
     * 
     */
    findMany<T extends pagamentomultaFindManyArgs>(args?: SelectSubset<T, pagamentomultaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pagamentomultaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pagamentomulta.
     * @param {pagamentomultaCreateArgs} args - Arguments to create a Pagamentomulta.
     * @example
     * // Create one Pagamentomulta
     * const Pagamentomulta = await prisma.pagamentomulta.create({
     *   data: {
     *     // ... data to create a Pagamentomulta
     *   }
     * })
     * 
     */
    create<T extends pagamentomultaCreateArgs>(args: SelectSubset<T, pagamentomultaCreateArgs<ExtArgs>>): Prisma__pagamentomultaClient<$Result.GetResult<Prisma.$pagamentomultaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pagamentomultas.
     * @param {pagamentomultaCreateManyArgs} args - Arguments to create many Pagamentomultas.
     * @example
     * // Create many Pagamentomultas
     * const pagamentomulta = await prisma.pagamentomulta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pagamentomultaCreateManyArgs>(args?: SelectSubset<T, pagamentomultaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pagamentomulta.
     * @param {pagamentomultaDeleteArgs} args - Arguments to delete one Pagamentomulta.
     * @example
     * // Delete one Pagamentomulta
     * const Pagamentomulta = await prisma.pagamentomulta.delete({
     *   where: {
     *     // ... filter to delete one Pagamentomulta
     *   }
     * })
     * 
     */
    delete<T extends pagamentomultaDeleteArgs>(args: SelectSubset<T, pagamentomultaDeleteArgs<ExtArgs>>): Prisma__pagamentomultaClient<$Result.GetResult<Prisma.$pagamentomultaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pagamentomulta.
     * @param {pagamentomultaUpdateArgs} args - Arguments to update one Pagamentomulta.
     * @example
     * // Update one Pagamentomulta
     * const pagamentomulta = await prisma.pagamentomulta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pagamentomultaUpdateArgs>(args: SelectSubset<T, pagamentomultaUpdateArgs<ExtArgs>>): Prisma__pagamentomultaClient<$Result.GetResult<Prisma.$pagamentomultaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pagamentomultas.
     * @param {pagamentomultaDeleteManyArgs} args - Arguments to filter Pagamentomultas to delete.
     * @example
     * // Delete a few Pagamentomultas
     * const { count } = await prisma.pagamentomulta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pagamentomultaDeleteManyArgs>(args?: SelectSubset<T, pagamentomultaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagamentomultas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagamentomultaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagamentomultas
     * const pagamentomulta = await prisma.pagamentomulta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pagamentomultaUpdateManyArgs>(args: SelectSubset<T, pagamentomultaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pagamentomulta.
     * @param {pagamentomultaUpsertArgs} args - Arguments to update or create a Pagamentomulta.
     * @example
     * // Update or create a Pagamentomulta
     * const pagamentomulta = await prisma.pagamentomulta.upsert({
     *   create: {
     *     // ... data to create a Pagamentomulta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pagamentomulta we want to update
     *   }
     * })
     */
    upsert<T extends pagamentomultaUpsertArgs>(args: SelectSubset<T, pagamentomultaUpsertArgs<ExtArgs>>): Prisma__pagamentomultaClient<$Result.GetResult<Prisma.$pagamentomultaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pagamentomultas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagamentomultaCountArgs} args - Arguments to filter Pagamentomultas to count.
     * @example
     * // Count the number of Pagamentomultas
     * const count = await prisma.pagamentomulta.count({
     *   where: {
     *     // ... the filter for the Pagamentomultas we want to count
     *   }
     * })
    **/
    count<T extends pagamentomultaCountArgs>(
      args?: Subset<T, pagamentomultaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagamentomultaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pagamentomulta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentomultaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagamentomultaAggregateArgs>(args: Subset<T, PagamentomultaAggregateArgs>): Prisma.PrismaPromise<GetPagamentomultaAggregateType<T>>

    /**
     * Group by Pagamentomulta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pagamentomultaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pagamentomultaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pagamentomultaGroupByArgs['orderBy'] }
        : { orderBy?: pagamentomultaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pagamentomultaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagamentomultaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pagamentomulta model
   */
  readonly fields: pagamentomultaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pagamentomulta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pagamentomultaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    multa<T extends multaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, multaDefaultArgs<ExtArgs>>): Prisma__multaClient<$Result.GetResult<Prisma.$multaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ficheiro<T extends ficheiroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ficheiroDefaultArgs<ExtArgs>>): Prisma__ficheiroClient<$Result.GetResult<Prisma.$ficheiroPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pagamentomulta model
   */ 
  interface pagamentomultaFieldRefs {
    readonly codPagamentoMulta: FieldRef<"pagamentomulta", 'Int'>
    readonly codMulta: FieldRef<"pagamentomulta", 'Int'>
    readonly dataPagamento: FieldRef<"pagamentomulta", 'DateTime'>
    readonly valorPago: FieldRef<"pagamentomulta", 'String'>
    readonly descCodigoDeposito: FieldRef<"pagamentomulta", 'String'>
    readonly codFicheiroPagamento: FieldRef<"pagamentomulta", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * pagamentomulta findUnique
   */
  export type pagamentomultaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentomulta
     */
    select?: pagamentomultaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagamentomultaInclude<ExtArgs> | null
    /**
     * Filter, which pagamentomulta to fetch.
     */
    where: pagamentomultaWhereUniqueInput
  }

  /**
   * pagamentomulta findUniqueOrThrow
   */
  export type pagamentomultaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentomulta
     */
    select?: pagamentomultaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagamentomultaInclude<ExtArgs> | null
    /**
     * Filter, which pagamentomulta to fetch.
     */
    where: pagamentomultaWhereUniqueInput
  }

  /**
   * pagamentomulta findFirst
   */
  export type pagamentomultaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentomulta
     */
    select?: pagamentomultaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagamentomultaInclude<ExtArgs> | null
    /**
     * Filter, which pagamentomulta to fetch.
     */
    where?: pagamentomultaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagamentomultas to fetch.
     */
    orderBy?: pagamentomultaOrderByWithRelationInput | pagamentomultaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pagamentomultas.
     */
    cursor?: pagamentomultaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagamentomultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagamentomultas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pagamentomultas.
     */
    distinct?: PagamentomultaScalarFieldEnum | PagamentomultaScalarFieldEnum[]
  }

  /**
   * pagamentomulta findFirstOrThrow
   */
  export type pagamentomultaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentomulta
     */
    select?: pagamentomultaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagamentomultaInclude<ExtArgs> | null
    /**
     * Filter, which pagamentomulta to fetch.
     */
    where?: pagamentomultaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagamentomultas to fetch.
     */
    orderBy?: pagamentomultaOrderByWithRelationInput | pagamentomultaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pagamentomultas.
     */
    cursor?: pagamentomultaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagamentomultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagamentomultas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pagamentomultas.
     */
    distinct?: PagamentomultaScalarFieldEnum | PagamentomultaScalarFieldEnum[]
  }

  /**
   * pagamentomulta findMany
   */
  export type pagamentomultaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentomulta
     */
    select?: pagamentomultaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagamentomultaInclude<ExtArgs> | null
    /**
     * Filter, which pagamentomultas to fetch.
     */
    where?: pagamentomultaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pagamentomultas to fetch.
     */
    orderBy?: pagamentomultaOrderByWithRelationInput | pagamentomultaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pagamentomultas.
     */
    cursor?: pagamentomultaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pagamentomultas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pagamentomultas.
     */
    skip?: number
    distinct?: PagamentomultaScalarFieldEnum | PagamentomultaScalarFieldEnum[]
  }

  /**
   * pagamentomulta create
   */
  export type pagamentomultaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentomulta
     */
    select?: pagamentomultaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagamentomultaInclude<ExtArgs> | null
    /**
     * The data needed to create a pagamentomulta.
     */
    data: XOR<pagamentomultaCreateInput, pagamentomultaUncheckedCreateInput>
  }

  /**
   * pagamentomulta createMany
   */
  export type pagamentomultaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pagamentomultas.
     */
    data: pagamentomultaCreateManyInput | pagamentomultaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pagamentomulta update
   */
  export type pagamentomultaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentomulta
     */
    select?: pagamentomultaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagamentomultaInclude<ExtArgs> | null
    /**
     * The data needed to update a pagamentomulta.
     */
    data: XOR<pagamentomultaUpdateInput, pagamentomultaUncheckedUpdateInput>
    /**
     * Choose, which pagamentomulta to update.
     */
    where: pagamentomultaWhereUniqueInput
  }

  /**
   * pagamentomulta updateMany
   */
  export type pagamentomultaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pagamentomultas.
     */
    data: XOR<pagamentomultaUpdateManyMutationInput, pagamentomultaUncheckedUpdateManyInput>
    /**
     * Filter which pagamentomultas to update
     */
    where?: pagamentomultaWhereInput
  }

  /**
   * pagamentomulta upsert
   */
  export type pagamentomultaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentomulta
     */
    select?: pagamentomultaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagamentomultaInclude<ExtArgs> | null
    /**
     * The filter to search for the pagamentomulta to update in case it exists.
     */
    where: pagamentomultaWhereUniqueInput
    /**
     * In case the pagamentomulta found by the `where` argument doesn't exist, create a new pagamentomulta with this data.
     */
    create: XOR<pagamentomultaCreateInput, pagamentomultaUncheckedCreateInput>
    /**
     * In case the pagamentomulta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pagamentomultaUpdateInput, pagamentomultaUncheckedUpdateInput>
  }

  /**
   * pagamentomulta delete
   */
  export type pagamentomultaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentomulta
     */
    select?: pagamentomultaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagamentomultaInclude<ExtArgs> | null
    /**
     * Filter which pagamentomulta to delete.
     */
    where: pagamentomultaWhereUniqueInput
  }

  /**
   * pagamentomulta deleteMany
   */
  export type pagamentomultaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pagamentomultas to delete
     */
    where?: pagamentomultaWhereInput
  }

  /**
   * pagamentomulta without action
   */
  export type pagamentomultaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pagamentomulta
     */
    select?: pagamentomultaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pagamentomultaInclude<ExtArgs> | null
  }


  /**
   * Model pais
   */

  export type AggregatePais = {
    _count: PaisCountAggregateOutputType | null
    _avg: PaisAvgAggregateOutputType | null
    _sum: PaisSumAggregateOutputType | null
    _min: PaisMinAggregateOutputType | null
    _max: PaisMaxAggregateOutputType | null
  }

  export type PaisAvgAggregateOutputType = {
    idPais: number | null
  }

  export type PaisSumAggregateOutputType = {
    idPais: number | null
  }

  export type PaisMinAggregateOutputType = {
    idPais: number | null
    pais: string | null
  }

  export type PaisMaxAggregateOutputType = {
    idPais: number | null
    pais: string | null
  }

  export type PaisCountAggregateOutputType = {
    idPais: number
    pais: number
    _all: number
  }


  export type PaisAvgAggregateInputType = {
    idPais?: true
  }

  export type PaisSumAggregateInputType = {
    idPais?: true
  }

  export type PaisMinAggregateInputType = {
    idPais?: true
    pais?: true
  }

  export type PaisMaxAggregateInputType = {
    idPais?: true
    pais?: true
  }

  export type PaisCountAggregateInputType = {
    idPais?: true
    pais?: true
    _all?: true
  }

  export type PaisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pais to aggregate.
     */
    where?: paisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pais to fetch.
     */
    orderBy?: paisOrderByWithRelationInput | paisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pais
    **/
    _count?: true | PaisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaisMaxAggregateInputType
  }

  export type GetPaisAggregateType<T extends PaisAggregateArgs> = {
        [P in keyof T & keyof AggregatePais]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePais[P]>
      : GetScalarType<T[P], AggregatePais[P]>
  }




  export type paisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paisWhereInput
    orderBy?: paisOrderByWithAggregationInput | paisOrderByWithAggregationInput[]
    by: PaisScalarFieldEnum[] | PaisScalarFieldEnum
    having?: paisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaisCountAggregateInputType | true
    _avg?: PaisAvgAggregateInputType
    _sum?: PaisSumAggregateInputType
    _min?: PaisMinAggregateInputType
    _max?: PaisMaxAggregateInputType
  }

  export type PaisGroupByOutputType = {
    idPais: number
    pais: string
    _count: PaisCountAggregateOutputType | null
    _avg: PaisAvgAggregateOutputType | null
    _sum: PaisSumAggregateOutputType | null
    _min: PaisMinAggregateOutputType | null
    _max: PaisMaxAggregateOutputType | null
  }

  type GetPaisGroupByPayload<T extends paisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaisGroupByOutputType[P]>
            : GetScalarType<T[P], PaisGroupByOutputType[P]>
        }
      >
    >


  export type paisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPais?: boolean
    pais?: boolean
    pessoa?: boolean | pais$pessoaArgs<ExtArgs>
    _count?: boolean | PaisCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pais"]>


  export type paisSelectScalar = {
    idPais?: boolean
    pais?: boolean
  }

  export type paisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | pais$pessoaArgs<ExtArgs>
    _count?: boolean | PaisCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $paisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pais"
    objects: {
      pessoa: Prisma.$pessoaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idPais: number
      pais: string
    }, ExtArgs["result"]["pais"]>
    composites: {}
  }

  type paisGetPayload<S extends boolean | null | undefined | paisDefaultArgs> = $Result.GetResult<Prisma.$paisPayload, S>

  type paisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<paisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaisCountAggregateInputType | true
    }

  export interface paisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pais'], meta: { name: 'pais' } }
    /**
     * Find zero or one Pais that matches the filter.
     * @param {paisFindUniqueArgs} args - Arguments to find a Pais
     * @example
     * // Get one Pais
     * const pais = await prisma.pais.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paisFindUniqueArgs>(args: SelectSubset<T, paisFindUniqueArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pais that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {paisFindUniqueOrThrowArgs} args - Arguments to find a Pais
     * @example
     * // Get one Pais
     * const pais = await prisma.pais.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paisFindUniqueOrThrowArgs>(args: SelectSubset<T, paisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisFindFirstArgs} args - Arguments to find a Pais
     * @example
     * // Get one Pais
     * const pais = await prisma.pais.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paisFindFirstArgs>(args?: SelectSubset<T, paisFindFirstArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pais that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisFindFirstOrThrowArgs} args - Arguments to find a Pais
     * @example
     * // Get one Pais
     * const pais = await prisma.pais.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paisFindFirstOrThrowArgs>(args?: SelectSubset<T, paisFindFirstOrThrowArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pais
     * const pais = await prisma.pais.findMany()
     * 
     * // Get first 10 Pais
     * const pais = await prisma.pais.findMany({ take: 10 })
     * 
     * // Only select the `idPais`
     * const paisWithIdPaisOnly = await prisma.pais.findMany({ select: { idPais: true } })
     * 
     */
    findMany<T extends paisFindManyArgs>(args?: SelectSubset<T, paisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pais.
     * @param {paisCreateArgs} args - Arguments to create a Pais.
     * @example
     * // Create one Pais
     * const Pais = await prisma.pais.create({
     *   data: {
     *     // ... data to create a Pais
     *   }
     * })
     * 
     */
    create<T extends paisCreateArgs>(args: SelectSubset<T, paisCreateArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pais.
     * @param {paisCreateManyArgs} args - Arguments to create many Pais.
     * @example
     * // Create many Pais
     * const pais = await prisma.pais.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paisCreateManyArgs>(args?: SelectSubset<T, paisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pais.
     * @param {paisDeleteArgs} args - Arguments to delete one Pais.
     * @example
     * // Delete one Pais
     * const Pais = await prisma.pais.delete({
     *   where: {
     *     // ... filter to delete one Pais
     *   }
     * })
     * 
     */
    delete<T extends paisDeleteArgs>(args: SelectSubset<T, paisDeleteArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pais.
     * @param {paisUpdateArgs} args - Arguments to update one Pais.
     * @example
     * // Update one Pais
     * const pais = await prisma.pais.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paisUpdateArgs>(args: SelectSubset<T, paisUpdateArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pais.
     * @param {paisDeleteManyArgs} args - Arguments to filter Pais to delete.
     * @example
     * // Delete a few Pais
     * const { count } = await prisma.pais.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paisDeleteManyArgs>(args?: SelectSubset<T, paisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pais
     * const pais = await prisma.pais.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paisUpdateManyArgs>(args: SelectSubset<T, paisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pais.
     * @param {paisUpsertArgs} args - Arguments to update or create a Pais.
     * @example
     * // Update or create a Pais
     * const pais = await prisma.pais.upsert({
     *   create: {
     *     // ... data to create a Pais
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pais we want to update
     *   }
     * })
     */
    upsert<T extends paisUpsertArgs>(args: SelectSubset<T, paisUpsertArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisCountArgs} args - Arguments to filter Pais to count.
     * @example
     * // Count the number of Pais
     * const count = await prisma.pais.count({
     *   where: {
     *     // ... the filter for the Pais we want to count
     *   }
     * })
    **/
    count<T extends paisCountArgs>(
      args?: Subset<T, paisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaisAggregateArgs>(args: Subset<T, PaisAggregateArgs>): Prisma.PrismaPromise<GetPaisAggregateType<T>>

    /**
     * Group by Pais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paisGroupByArgs['orderBy'] }
        : { orderBy?: paisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pais model
   */
  readonly fields: paisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pais.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoa<T extends pais$pessoaArgs<ExtArgs> = {}>(args?: Subset<T, pais$pessoaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pais model
   */ 
  interface paisFieldRefs {
    readonly idPais: FieldRef<"pais", 'Int'>
    readonly pais: FieldRef<"pais", 'String'>
  }
    

  // Custom InputTypes
  /**
   * pais findUnique
   */
  export type paisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter, which pais to fetch.
     */
    where: paisWhereUniqueInput
  }

  /**
   * pais findUniqueOrThrow
   */
  export type paisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter, which pais to fetch.
     */
    where: paisWhereUniqueInput
  }

  /**
   * pais findFirst
   */
  export type paisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter, which pais to fetch.
     */
    where?: paisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pais to fetch.
     */
    orderBy?: paisOrderByWithRelationInput | paisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pais.
     */
    cursor?: paisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pais.
     */
    distinct?: PaisScalarFieldEnum | PaisScalarFieldEnum[]
  }

  /**
   * pais findFirstOrThrow
   */
  export type paisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter, which pais to fetch.
     */
    where?: paisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pais to fetch.
     */
    orderBy?: paisOrderByWithRelationInput | paisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pais.
     */
    cursor?: paisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pais.
     */
    distinct?: PaisScalarFieldEnum | PaisScalarFieldEnum[]
  }

  /**
   * pais findMany
   */
  export type paisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter, which pais to fetch.
     */
    where?: paisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pais to fetch.
     */
    orderBy?: paisOrderByWithRelationInput | paisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pais.
     */
    cursor?: paisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pais.
     */
    skip?: number
    distinct?: PaisScalarFieldEnum | PaisScalarFieldEnum[]
  }

  /**
   * pais create
   */
  export type paisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * The data needed to create a pais.
     */
    data: XOR<paisCreateInput, paisUncheckedCreateInput>
  }

  /**
   * pais createMany
   */
  export type paisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pais.
     */
    data: paisCreateManyInput | paisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pais update
   */
  export type paisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * The data needed to update a pais.
     */
    data: XOR<paisUpdateInput, paisUncheckedUpdateInput>
    /**
     * Choose, which pais to update.
     */
    where: paisWhereUniqueInput
  }

  /**
   * pais updateMany
   */
  export type paisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pais.
     */
    data: XOR<paisUpdateManyMutationInput, paisUncheckedUpdateManyInput>
    /**
     * Filter which pais to update
     */
    where?: paisWhereInput
  }

  /**
   * pais upsert
   */
  export type paisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * The filter to search for the pais to update in case it exists.
     */
    where: paisWhereUniqueInput
    /**
     * In case the pais found by the `where` argument doesn't exist, create a new pais with this data.
     */
    create: XOR<paisCreateInput, paisUncheckedCreateInput>
    /**
     * In case the pais was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paisUpdateInput, paisUncheckedUpdateInput>
  }

  /**
   * pais delete
   */
  export type paisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter which pais to delete.
     */
    where: paisWhereUniqueInput
  }

  /**
   * pais deleteMany
   */
  export type paisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pais to delete
     */
    where?: paisWhereInput
  }

  /**
   * pais.pessoa
   */
  export type pais$pessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    where?: pessoaWhereInput
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    cursor?: pessoaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * pais without action
   */
  export type paisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
  }


  /**
   * Model pessoa
   */

  export type AggregatePessoa = {
    _count: PessoaCountAggregateOutputType | null
    _avg: PessoaAvgAggregateOutputType | null
    _sum: PessoaSumAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  export type PessoaAvgAggregateOutputType = {
    codPessoa: number | null
    codEndereco: number | null
    codNacionalidade: number | null
    codContacto: number | null
    codBi: number | null
  }

  export type PessoaSumAggregateOutputType = {
    codPessoa: number | null
    codEndereco: number | null
    codNacionalidade: number | null
    codContacto: number | null
    codBi: number | null
  }

  export type PessoaMinAggregateOutputType = {
    codPessoa: number | null
    codEndereco: number | null
    codNacionalidade: number | null
    codContacto: number | null
    nome: string | null
    genero: $Enums.pessoa_genero | null
    estadoCivil: $Enums.pessoa_estadoCivil | null
    dataCadastro: string | null
    dataNascimento: string | null
    codBi: number | null
    senha: string | null
  }

  export type PessoaMaxAggregateOutputType = {
    codPessoa: number | null
    codEndereco: number | null
    codNacionalidade: number | null
    codContacto: number | null
    nome: string | null
    genero: $Enums.pessoa_genero | null
    estadoCivil: $Enums.pessoa_estadoCivil | null
    dataCadastro: string | null
    dataNascimento: string | null
    codBi: number | null
    senha: string | null
  }

  export type PessoaCountAggregateOutputType = {
    codPessoa: number
    codEndereco: number
    codNacionalidade: number
    codContacto: number
    nome: number
    genero: number
    estadoCivil: number
    dataCadastro: number
    dataNascimento: number
    codBi: number
    senha: number
    _all: number
  }


  export type PessoaAvgAggregateInputType = {
    codPessoa?: true
    codEndereco?: true
    codNacionalidade?: true
    codContacto?: true
    codBi?: true
  }

  export type PessoaSumAggregateInputType = {
    codPessoa?: true
    codEndereco?: true
    codNacionalidade?: true
    codContacto?: true
    codBi?: true
  }

  export type PessoaMinAggregateInputType = {
    codPessoa?: true
    codEndereco?: true
    codNacionalidade?: true
    codContacto?: true
    nome?: true
    genero?: true
    estadoCivil?: true
    dataCadastro?: true
    dataNascimento?: true
    codBi?: true
    senha?: true
  }

  export type PessoaMaxAggregateInputType = {
    codPessoa?: true
    codEndereco?: true
    codNacionalidade?: true
    codContacto?: true
    nome?: true
    genero?: true
    estadoCivil?: true
    dataCadastro?: true
    dataNascimento?: true
    codBi?: true
    senha?: true
  }

  export type PessoaCountAggregateInputType = {
    codPessoa?: true
    codEndereco?: true
    codNacionalidade?: true
    codContacto?: true
    nome?: true
    genero?: true
    estadoCivil?: true
    dataCadastro?: true
    dataNascimento?: true
    codBi?: true
    senha?: true
    _all?: true
  }

  export type PessoaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pessoa to aggregate.
     */
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     */
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pessoas
    **/
    _count?: true | PessoaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PessoaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PessoaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PessoaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PessoaMaxAggregateInputType
  }

  export type GetPessoaAggregateType<T extends PessoaAggregateArgs> = {
        [P in keyof T & keyof AggregatePessoa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePessoa[P]>
      : GetScalarType<T[P], AggregatePessoa[P]>
  }




  export type pessoaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaWhereInput
    orderBy?: pessoaOrderByWithAggregationInput | pessoaOrderByWithAggregationInput[]
    by: PessoaScalarFieldEnum[] | PessoaScalarFieldEnum
    having?: pessoaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PessoaCountAggregateInputType | true
    _avg?: PessoaAvgAggregateInputType
    _sum?: PessoaSumAggregateInputType
    _min?: PessoaMinAggregateInputType
    _max?: PessoaMaxAggregateInputType
  }

  export type PessoaGroupByOutputType = {
    codPessoa: number
    codEndereco: number | null
    codNacionalidade: number | null
    codContacto: number | null
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro: string | null
    dataNascimento: string
    codBi: number
    senha: string
    _count: PessoaCountAggregateOutputType | null
    _avg: PessoaAvgAggregateOutputType | null
    _sum: PessoaSumAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  type GetPessoaGroupByPayload<T extends pessoaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PessoaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PessoaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PessoaGroupByOutputType[P]>
            : GetScalarType<T[P], PessoaGroupByOutputType[P]>
        }
      >
    >


  export type pessoaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codPessoa?: boolean
    codEndereco?: boolean
    codNacionalidade?: boolean
    codContacto?: boolean
    nome?: boolean
    genero?: boolean
    estadoCivil?: boolean
    dataCadastro?: boolean
    dataNascimento?: boolean
    codBi?: boolean
    senha?: boolean
    automobilista?: boolean | pessoa$automobilistaArgs<ExtArgs>
    funcionario?: boolean | pessoa$funcionarioArgs<ExtArgs>
    contacto?: boolean | pessoa$contactoArgs<ExtArgs>
    endereco?: boolean | pessoa$enderecoArgs<ExtArgs>
    pais?: boolean | pessoa$paisArgs<ExtArgs>
    bi?: boolean | biDefaultArgs<ExtArgs>
    titulopropriedade?: boolean | pessoa$titulopropriedadeArgs<ExtArgs>
    _count?: boolean | PessoaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoa"]>


  export type pessoaSelectScalar = {
    codPessoa?: boolean
    codEndereco?: boolean
    codNacionalidade?: boolean
    codContacto?: boolean
    nome?: boolean
    genero?: boolean
    estadoCivil?: boolean
    dataCadastro?: boolean
    dataNascimento?: boolean
    codBi?: boolean
    senha?: boolean
  }

  export type pessoaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    automobilista?: boolean | pessoa$automobilistaArgs<ExtArgs>
    funcionario?: boolean | pessoa$funcionarioArgs<ExtArgs>
    contacto?: boolean | pessoa$contactoArgs<ExtArgs>
    endereco?: boolean | pessoa$enderecoArgs<ExtArgs>
    pais?: boolean | pessoa$paisArgs<ExtArgs>
    bi?: boolean | biDefaultArgs<ExtArgs>
    titulopropriedade?: boolean | pessoa$titulopropriedadeArgs<ExtArgs>
    _count?: boolean | PessoaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $pessoaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pessoa"
    objects: {
      automobilista: Prisma.$automobilistaPayload<ExtArgs>[]
      funcionario: Prisma.$funcionarioPayload<ExtArgs>[]
      contacto: Prisma.$contactoPayload<ExtArgs> | null
      endereco: Prisma.$enderecoPayload<ExtArgs> | null
      pais: Prisma.$paisPayload<ExtArgs> | null
      bi: Prisma.$biPayload<ExtArgs>
      titulopropriedade: Prisma.$titulopropriedadePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      codPessoa: number
      codEndereco: number | null
      codNacionalidade: number | null
      codContacto: number | null
      nome: string
      genero: $Enums.pessoa_genero
      estadoCivil: $Enums.pessoa_estadoCivil
      dataCadastro: string | null
      dataNascimento: string
      codBi: number
      senha: string
    }, ExtArgs["result"]["pessoa"]>
    composites: {}
  }

  type pessoaGetPayload<S extends boolean | null | undefined | pessoaDefaultArgs> = $Result.GetResult<Prisma.$pessoaPayload, S>

  type pessoaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pessoaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PessoaCountAggregateInputType | true
    }

  export interface pessoaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pessoa'], meta: { name: 'pessoa' } }
    /**
     * Find zero or one Pessoa that matches the filter.
     * @param {pessoaFindUniqueArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pessoaFindUniqueArgs>(args: SelectSubset<T, pessoaFindUniqueArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pessoa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pessoaFindUniqueOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pessoaFindUniqueOrThrowArgs>(args: SelectSubset<T, pessoaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pessoa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaFindFirstArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pessoaFindFirstArgs>(args?: SelectSubset<T, pessoaFindFirstArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pessoa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaFindFirstOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pessoaFindFirstOrThrowArgs>(args?: SelectSubset<T, pessoaFindFirstOrThrowArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pessoas
     * const pessoas = await prisma.pessoa.findMany()
     * 
     * // Get first 10 Pessoas
     * const pessoas = await prisma.pessoa.findMany({ take: 10 })
     * 
     * // Only select the `codPessoa`
     * const pessoaWithCodPessoaOnly = await prisma.pessoa.findMany({ select: { codPessoa: true } })
     * 
     */
    findMany<T extends pessoaFindManyArgs>(args?: SelectSubset<T, pessoaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pessoa.
     * @param {pessoaCreateArgs} args - Arguments to create a Pessoa.
     * @example
     * // Create one Pessoa
     * const Pessoa = await prisma.pessoa.create({
     *   data: {
     *     // ... data to create a Pessoa
     *   }
     * })
     * 
     */
    create<T extends pessoaCreateArgs>(args: SelectSubset<T, pessoaCreateArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pessoas.
     * @param {pessoaCreateManyArgs} args - Arguments to create many Pessoas.
     * @example
     * // Create many Pessoas
     * const pessoa = await prisma.pessoa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pessoaCreateManyArgs>(args?: SelectSubset<T, pessoaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pessoa.
     * @param {pessoaDeleteArgs} args - Arguments to delete one Pessoa.
     * @example
     * // Delete one Pessoa
     * const Pessoa = await prisma.pessoa.delete({
     *   where: {
     *     // ... filter to delete one Pessoa
     *   }
     * })
     * 
     */
    delete<T extends pessoaDeleteArgs>(args: SelectSubset<T, pessoaDeleteArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pessoa.
     * @param {pessoaUpdateArgs} args - Arguments to update one Pessoa.
     * @example
     * // Update one Pessoa
     * const pessoa = await prisma.pessoa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pessoaUpdateArgs>(args: SelectSubset<T, pessoaUpdateArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pessoas.
     * @param {pessoaDeleteManyArgs} args - Arguments to filter Pessoas to delete.
     * @example
     * // Delete a few Pessoas
     * const { count } = await prisma.pessoa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pessoaDeleteManyArgs>(args?: SelectSubset<T, pessoaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pessoas
     * const pessoa = await prisma.pessoa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pessoaUpdateManyArgs>(args: SelectSubset<T, pessoaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pessoa.
     * @param {pessoaUpsertArgs} args - Arguments to update or create a Pessoa.
     * @example
     * // Update or create a Pessoa
     * const pessoa = await prisma.pessoa.upsert({
     *   create: {
     *     // ... data to create a Pessoa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pessoa we want to update
     *   }
     * })
     */
    upsert<T extends pessoaUpsertArgs>(args: SelectSubset<T, pessoaUpsertArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaCountArgs} args - Arguments to filter Pessoas to count.
     * @example
     * // Count the number of Pessoas
     * const count = await prisma.pessoa.count({
     *   where: {
     *     // ... the filter for the Pessoas we want to count
     *   }
     * })
    **/
    count<T extends pessoaCountArgs>(
      args?: Subset<T, pessoaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PessoaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PessoaAggregateArgs>(args: Subset<T, PessoaAggregateArgs>): Prisma.PrismaPromise<GetPessoaAggregateType<T>>

    /**
     * Group by Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pessoaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pessoaGroupByArgs['orderBy'] }
        : { orderBy?: pessoaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pessoaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPessoaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pessoa model
   */
  readonly fields: pessoaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pessoa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pessoaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    automobilista<T extends pessoa$automobilistaArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$automobilistaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$automobilistaPayload<ExtArgs>, T, "findMany"> | Null>
    funcionario<T extends pessoa$funcionarioArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$funcionarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$funcionarioPayload<ExtArgs>, T, "findMany"> | Null>
    contacto<T extends pessoa$contactoArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$contactoArgs<ExtArgs>>): Prisma__contactoClient<$Result.GetResult<Prisma.$contactoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    endereco<T extends pessoa$enderecoArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$enderecoArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    pais<T extends pessoa$paisArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$paisArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    bi<T extends biDefaultArgs<ExtArgs> = {}>(args?: Subset<T, biDefaultArgs<ExtArgs>>): Prisma__biClient<$Result.GetResult<Prisma.$biPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    titulopropriedade<T extends pessoa$titulopropriedadeArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$titulopropriedadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$titulopropriedadePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pessoa model
   */ 
  interface pessoaFieldRefs {
    readonly codPessoa: FieldRef<"pessoa", 'Int'>
    readonly codEndereco: FieldRef<"pessoa", 'Int'>
    readonly codNacionalidade: FieldRef<"pessoa", 'Int'>
    readonly codContacto: FieldRef<"pessoa", 'Int'>
    readonly nome: FieldRef<"pessoa", 'String'>
    readonly genero: FieldRef<"pessoa", 'pessoa_genero'>
    readonly estadoCivil: FieldRef<"pessoa", 'pessoa_estadoCivil'>
    readonly dataCadastro: FieldRef<"pessoa", 'String'>
    readonly dataNascimento: FieldRef<"pessoa", 'String'>
    readonly codBi: FieldRef<"pessoa", 'Int'>
    readonly senha: FieldRef<"pessoa", 'String'>
  }
    

  // Custom InputTypes
  /**
   * pessoa findUnique
   */
  export type pessoaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter, which pessoa to fetch.
     */
    where: pessoaWhereUniqueInput
  }

  /**
   * pessoa findUniqueOrThrow
   */
  export type pessoaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter, which pessoa to fetch.
     */
    where: pessoaWhereUniqueInput
  }

  /**
   * pessoa findFirst
   */
  export type pessoaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter, which pessoa to fetch.
     */
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     */
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pessoas.
     */
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pessoas.
     */
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * pessoa findFirstOrThrow
   */
  export type pessoaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter, which pessoa to fetch.
     */
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     */
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pessoas.
     */
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pessoas.
     */
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * pessoa findMany
   */
  export type pessoaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter, which pessoas to fetch.
     */
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     */
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pessoas.
     */
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     */
    skip?: number
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * pessoa create
   */
  export type pessoaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * The data needed to create a pessoa.
     */
    data: XOR<pessoaCreateInput, pessoaUncheckedCreateInput>
  }

  /**
   * pessoa createMany
   */
  export type pessoaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pessoas.
     */
    data: pessoaCreateManyInput | pessoaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pessoa update
   */
  export type pessoaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * The data needed to update a pessoa.
     */
    data: XOR<pessoaUpdateInput, pessoaUncheckedUpdateInput>
    /**
     * Choose, which pessoa to update.
     */
    where: pessoaWhereUniqueInput
  }

  /**
   * pessoa updateMany
   */
  export type pessoaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pessoas.
     */
    data: XOR<pessoaUpdateManyMutationInput, pessoaUncheckedUpdateManyInput>
    /**
     * Filter which pessoas to update
     */
    where?: pessoaWhereInput
  }

  /**
   * pessoa upsert
   */
  export type pessoaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * The filter to search for the pessoa to update in case it exists.
     */
    where: pessoaWhereUniqueInput
    /**
     * In case the pessoa found by the `where` argument doesn't exist, create a new pessoa with this data.
     */
    create: XOR<pessoaCreateInput, pessoaUncheckedCreateInput>
    /**
     * In case the pessoa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pessoaUpdateInput, pessoaUncheckedUpdateInput>
  }

  /**
   * pessoa delete
   */
  export type pessoaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter which pessoa to delete.
     */
    where: pessoaWhereUniqueInput
  }

  /**
   * pessoa deleteMany
   */
  export type pessoaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pessoas to delete
     */
    where?: pessoaWhereInput
  }

  /**
   * pessoa.automobilista
   */
  export type pessoa$automobilistaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the automobilista
     */
    select?: automobilistaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: automobilistaInclude<ExtArgs> | null
    where?: automobilistaWhereInput
    orderBy?: automobilistaOrderByWithRelationInput | automobilistaOrderByWithRelationInput[]
    cursor?: automobilistaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomobilistaScalarFieldEnum | AutomobilistaScalarFieldEnum[]
  }

  /**
   * pessoa.funcionario
   */
  export type pessoa$funcionarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the funcionario
     */
    select?: funcionarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: funcionarioInclude<ExtArgs> | null
    where?: funcionarioWhereInput
    orderBy?: funcionarioOrderByWithRelationInput | funcionarioOrderByWithRelationInput[]
    cursor?: funcionarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FuncionarioScalarFieldEnum | FuncionarioScalarFieldEnum[]
  }

  /**
   * pessoa.contacto
   */
  export type pessoa$contactoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacto
     */
    select?: contactoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactoInclude<ExtArgs> | null
    where?: contactoWhereInput
  }

  /**
   * pessoa.endereco
   */
  export type pessoa$enderecoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    where?: enderecoWhereInput
  }

  /**
   * pessoa.pais
   */
  export type pessoa$paisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    where?: paisWhereInput
  }

  /**
   * pessoa.titulopropriedade
   */
  export type pessoa$titulopropriedadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the titulopropriedade
     */
    select?: titulopropriedadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: titulopropriedadeInclude<ExtArgs> | null
    where?: titulopropriedadeWhereInput
    orderBy?: titulopropriedadeOrderByWithRelationInput | titulopropriedadeOrderByWithRelationInput[]
    cursor?: titulopropriedadeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TitulopropriedadeScalarFieldEnum | TitulopropriedadeScalarFieldEnum[]
  }

  /**
   * pessoa without action
   */
  export type pessoaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
  }


  /**
   * Model provincia
   */

  export type AggregateProvincia = {
    _count: ProvinciaCountAggregateOutputType | null
    _avg: ProvinciaAvgAggregateOutputType | null
    _sum: ProvinciaSumAggregateOutputType | null
    _min: ProvinciaMinAggregateOutputType | null
    _max: ProvinciaMaxAggregateOutputType | null
  }

  export type ProvinciaAvgAggregateOutputType = {
    idProvincia: number | null
  }

  export type ProvinciaSumAggregateOutputType = {
    idProvincia: number | null
  }

  export type ProvinciaMinAggregateOutputType = {
    idProvincia: number | null
    provincia: string | null
  }

  export type ProvinciaMaxAggregateOutputType = {
    idProvincia: number | null
    provincia: string | null
  }

  export type ProvinciaCountAggregateOutputType = {
    idProvincia: number
    provincia: number
    _all: number
  }


  export type ProvinciaAvgAggregateInputType = {
    idProvincia?: true
  }

  export type ProvinciaSumAggregateInputType = {
    idProvincia?: true
  }

  export type ProvinciaMinAggregateInputType = {
    idProvincia?: true
    provincia?: true
  }

  export type ProvinciaMaxAggregateInputType = {
    idProvincia?: true
    provincia?: true
  }

  export type ProvinciaCountAggregateInputType = {
    idProvincia?: true
    provincia?: true
    _all?: true
  }

  export type ProvinciaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which provincia to aggregate.
     */
    where?: provinciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provincias to fetch.
     */
    orderBy?: provinciaOrderByWithRelationInput | provinciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: provinciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provincias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provincias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned provincias
    **/
    _count?: true | ProvinciaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvinciaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvinciaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvinciaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvinciaMaxAggregateInputType
  }

  export type GetProvinciaAggregateType<T extends ProvinciaAggregateArgs> = {
        [P in keyof T & keyof AggregateProvincia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvincia[P]>
      : GetScalarType<T[P], AggregateProvincia[P]>
  }




  export type provinciaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provinciaWhereInput
    orderBy?: provinciaOrderByWithAggregationInput | provinciaOrderByWithAggregationInput[]
    by: ProvinciaScalarFieldEnum[] | ProvinciaScalarFieldEnum
    having?: provinciaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvinciaCountAggregateInputType | true
    _avg?: ProvinciaAvgAggregateInputType
    _sum?: ProvinciaSumAggregateInputType
    _min?: ProvinciaMinAggregateInputType
    _max?: ProvinciaMaxAggregateInputType
  }

  export type ProvinciaGroupByOutputType = {
    idProvincia: number
    provincia: string
    _count: ProvinciaCountAggregateOutputType | null
    _avg: ProvinciaAvgAggregateOutputType | null
    _sum: ProvinciaSumAggregateOutputType | null
    _min: ProvinciaMinAggregateOutputType | null
    _max: ProvinciaMaxAggregateOutputType | null
  }

  type GetProvinciaGroupByPayload<T extends provinciaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvinciaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvinciaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvinciaGroupByOutputType[P]>
            : GetScalarType<T[P], ProvinciaGroupByOutputType[P]>
        }
      >
    >


  export type provinciaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idProvincia?: boolean
    provincia?: boolean
    municipio?: boolean | provincia$municipioArgs<ExtArgs>
    _count?: boolean | ProvinciaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provincia"]>


  export type provinciaSelectScalar = {
    idProvincia?: boolean
    provincia?: boolean
  }

  export type provinciaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    municipio?: boolean | provincia$municipioArgs<ExtArgs>
    _count?: boolean | ProvinciaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $provinciaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "provincia"
    objects: {
      municipio: Prisma.$municipioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idProvincia: number
      provincia: string
    }, ExtArgs["result"]["provincia"]>
    composites: {}
  }

  type provinciaGetPayload<S extends boolean | null | undefined | provinciaDefaultArgs> = $Result.GetResult<Prisma.$provinciaPayload, S>

  type provinciaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<provinciaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProvinciaCountAggregateInputType | true
    }

  export interface provinciaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['provincia'], meta: { name: 'provincia' } }
    /**
     * Find zero or one Provincia that matches the filter.
     * @param {provinciaFindUniqueArgs} args - Arguments to find a Provincia
     * @example
     * // Get one Provincia
     * const provincia = await prisma.provincia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends provinciaFindUniqueArgs>(args: SelectSubset<T, provinciaFindUniqueArgs<ExtArgs>>): Prisma__provinciaClient<$Result.GetResult<Prisma.$provinciaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Provincia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {provinciaFindUniqueOrThrowArgs} args - Arguments to find a Provincia
     * @example
     * // Get one Provincia
     * const provincia = await prisma.provincia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends provinciaFindUniqueOrThrowArgs>(args: SelectSubset<T, provinciaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__provinciaClient<$Result.GetResult<Prisma.$provinciaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Provincia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provinciaFindFirstArgs} args - Arguments to find a Provincia
     * @example
     * // Get one Provincia
     * const provincia = await prisma.provincia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends provinciaFindFirstArgs>(args?: SelectSubset<T, provinciaFindFirstArgs<ExtArgs>>): Prisma__provinciaClient<$Result.GetResult<Prisma.$provinciaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Provincia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provinciaFindFirstOrThrowArgs} args - Arguments to find a Provincia
     * @example
     * // Get one Provincia
     * const provincia = await prisma.provincia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends provinciaFindFirstOrThrowArgs>(args?: SelectSubset<T, provinciaFindFirstOrThrowArgs<ExtArgs>>): Prisma__provinciaClient<$Result.GetResult<Prisma.$provinciaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Provincias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provinciaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provincias
     * const provincias = await prisma.provincia.findMany()
     * 
     * // Get first 10 Provincias
     * const provincias = await prisma.provincia.findMany({ take: 10 })
     * 
     * // Only select the `idProvincia`
     * const provinciaWithIdProvinciaOnly = await prisma.provincia.findMany({ select: { idProvincia: true } })
     * 
     */
    findMany<T extends provinciaFindManyArgs>(args?: SelectSubset<T, provinciaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provinciaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Provincia.
     * @param {provinciaCreateArgs} args - Arguments to create a Provincia.
     * @example
     * // Create one Provincia
     * const Provincia = await prisma.provincia.create({
     *   data: {
     *     // ... data to create a Provincia
     *   }
     * })
     * 
     */
    create<T extends provinciaCreateArgs>(args: SelectSubset<T, provinciaCreateArgs<ExtArgs>>): Prisma__provinciaClient<$Result.GetResult<Prisma.$provinciaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Provincias.
     * @param {provinciaCreateManyArgs} args - Arguments to create many Provincias.
     * @example
     * // Create many Provincias
     * const provincia = await prisma.provincia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends provinciaCreateManyArgs>(args?: SelectSubset<T, provinciaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Provincia.
     * @param {provinciaDeleteArgs} args - Arguments to delete one Provincia.
     * @example
     * // Delete one Provincia
     * const Provincia = await prisma.provincia.delete({
     *   where: {
     *     // ... filter to delete one Provincia
     *   }
     * })
     * 
     */
    delete<T extends provinciaDeleteArgs>(args: SelectSubset<T, provinciaDeleteArgs<ExtArgs>>): Prisma__provinciaClient<$Result.GetResult<Prisma.$provinciaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Provincia.
     * @param {provinciaUpdateArgs} args - Arguments to update one Provincia.
     * @example
     * // Update one Provincia
     * const provincia = await prisma.provincia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends provinciaUpdateArgs>(args: SelectSubset<T, provinciaUpdateArgs<ExtArgs>>): Prisma__provinciaClient<$Result.GetResult<Prisma.$provinciaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Provincias.
     * @param {provinciaDeleteManyArgs} args - Arguments to filter Provincias to delete.
     * @example
     * // Delete a few Provincias
     * const { count } = await prisma.provincia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends provinciaDeleteManyArgs>(args?: SelectSubset<T, provinciaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provincias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provinciaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provincias
     * const provincia = await prisma.provincia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends provinciaUpdateManyArgs>(args: SelectSubset<T, provinciaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Provincia.
     * @param {provinciaUpsertArgs} args - Arguments to update or create a Provincia.
     * @example
     * // Update or create a Provincia
     * const provincia = await prisma.provincia.upsert({
     *   create: {
     *     // ... data to create a Provincia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provincia we want to update
     *   }
     * })
     */
    upsert<T extends provinciaUpsertArgs>(args: SelectSubset<T, provinciaUpsertArgs<ExtArgs>>): Prisma__provinciaClient<$Result.GetResult<Prisma.$provinciaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Provincias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provinciaCountArgs} args - Arguments to filter Provincias to count.
     * @example
     * // Count the number of Provincias
     * const count = await prisma.provincia.count({
     *   where: {
     *     // ... the filter for the Provincias we want to count
     *   }
     * })
    **/
    count<T extends provinciaCountArgs>(
      args?: Subset<T, provinciaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvinciaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provincia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvinciaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvinciaAggregateArgs>(args: Subset<T, ProvinciaAggregateArgs>): Prisma.PrismaPromise<GetProvinciaAggregateType<T>>

    /**
     * Group by Provincia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provinciaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends provinciaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: provinciaGroupByArgs['orderBy'] }
        : { orderBy?: provinciaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, provinciaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvinciaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the provincia model
   */
  readonly fields: provinciaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for provincia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__provinciaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    municipio<T extends provincia$municipioArgs<ExtArgs> = {}>(args?: Subset<T, provincia$municipioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$municipioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the provincia model
   */ 
  interface provinciaFieldRefs {
    readonly idProvincia: FieldRef<"provincia", 'Int'>
    readonly provincia: FieldRef<"provincia", 'String'>
  }
    

  // Custom InputTypes
  /**
   * provincia findUnique
   */
  export type provinciaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provincia
     */
    select?: provinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinciaInclude<ExtArgs> | null
    /**
     * Filter, which provincia to fetch.
     */
    where: provinciaWhereUniqueInput
  }

  /**
   * provincia findUniqueOrThrow
   */
  export type provinciaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provincia
     */
    select?: provinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinciaInclude<ExtArgs> | null
    /**
     * Filter, which provincia to fetch.
     */
    where: provinciaWhereUniqueInput
  }

  /**
   * provincia findFirst
   */
  export type provinciaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provincia
     */
    select?: provinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinciaInclude<ExtArgs> | null
    /**
     * Filter, which provincia to fetch.
     */
    where?: provinciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provincias to fetch.
     */
    orderBy?: provinciaOrderByWithRelationInput | provinciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provincias.
     */
    cursor?: provinciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provincias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provincias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provincias.
     */
    distinct?: ProvinciaScalarFieldEnum | ProvinciaScalarFieldEnum[]
  }

  /**
   * provincia findFirstOrThrow
   */
  export type provinciaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provincia
     */
    select?: provinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinciaInclude<ExtArgs> | null
    /**
     * Filter, which provincia to fetch.
     */
    where?: provinciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provincias to fetch.
     */
    orderBy?: provinciaOrderByWithRelationInput | provinciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provincias.
     */
    cursor?: provinciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provincias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provincias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provincias.
     */
    distinct?: ProvinciaScalarFieldEnum | ProvinciaScalarFieldEnum[]
  }

  /**
   * provincia findMany
   */
  export type provinciaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provincia
     */
    select?: provinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinciaInclude<ExtArgs> | null
    /**
     * Filter, which provincias to fetch.
     */
    where?: provinciaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provincias to fetch.
     */
    orderBy?: provinciaOrderByWithRelationInput | provinciaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing provincias.
     */
    cursor?: provinciaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provincias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provincias.
     */
    skip?: number
    distinct?: ProvinciaScalarFieldEnum | ProvinciaScalarFieldEnum[]
  }

  /**
   * provincia create
   */
  export type provinciaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provincia
     */
    select?: provinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinciaInclude<ExtArgs> | null
    /**
     * The data needed to create a provincia.
     */
    data: XOR<provinciaCreateInput, provinciaUncheckedCreateInput>
  }

  /**
   * provincia createMany
   */
  export type provinciaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many provincias.
     */
    data: provinciaCreateManyInput | provinciaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * provincia update
   */
  export type provinciaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provincia
     */
    select?: provinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinciaInclude<ExtArgs> | null
    /**
     * The data needed to update a provincia.
     */
    data: XOR<provinciaUpdateInput, provinciaUncheckedUpdateInput>
    /**
     * Choose, which provincia to update.
     */
    where: provinciaWhereUniqueInput
  }

  /**
   * provincia updateMany
   */
  export type provinciaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update provincias.
     */
    data: XOR<provinciaUpdateManyMutationInput, provinciaUncheckedUpdateManyInput>
    /**
     * Filter which provincias to update
     */
    where?: provinciaWhereInput
  }

  /**
   * provincia upsert
   */
  export type provinciaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provincia
     */
    select?: provinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinciaInclude<ExtArgs> | null
    /**
     * The filter to search for the provincia to update in case it exists.
     */
    where: provinciaWhereUniqueInput
    /**
     * In case the provincia found by the `where` argument doesn't exist, create a new provincia with this data.
     */
    create: XOR<provinciaCreateInput, provinciaUncheckedCreateInput>
    /**
     * In case the provincia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<provinciaUpdateInput, provinciaUncheckedUpdateInput>
  }

  /**
   * provincia delete
   */
  export type provinciaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provincia
     */
    select?: provinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinciaInclude<ExtArgs> | null
    /**
     * Filter which provincia to delete.
     */
    where: provinciaWhereUniqueInput
  }

  /**
   * provincia deleteMany
   */
  export type provinciaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which provincias to delete
     */
    where?: provinciaWhereInput
  }

  /**
   * provincia.municipio
   */
  export type provincia$municipioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the municipio
     */
    select?: municipioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: municipioInclude<ExtArgs> | null
    where?: municipioWhereInput
    orderBy?: municipioOrderByWithRelationInput | municipioOrderByWithRelationInput[]
    cursor?: municipioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MunicipioScalarFieldEnum | MunicipioScalarFieldEnum[]
  }

  /**
   * provincia without action
   */
  export type provinciaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provincia
     */
    select?: provinciaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provinciaInclude<ExtArgs> | null
  }


  /**
   * Model serivicoviatura
   */

  export type AggregateSerivicoviatura = {
    _count: SerivicoviaturaCountAggregateOutputType | null
    _avg: SerivicoviaturaAvgAggregateOutputType | null
    _sum: SerivicoviaturaSumAggregateOutputType | null
    _min: SerivicoviaturaMinAggregateOutputType | null
    _max: SerivicoviaturaMaxAggregateOutputType | null
  }

  export type SerivicoviaturaAvgAggregateOutputType = {
    codServicoViatura: number | null
  }

  export type SerivicoviaturaSumAggregateOutputType = {
    codServicoViatura: number | null
  }

  export type SerivicoviaturaMinAggregateOutputType = {
    codServicoViatura: number | null
    descServico: string | null
  }

  export type SerivicoviaturaMaxAggregateOutputType = {
    codServicoViatura: number | null
    descServico: string | null
  }

  export type SerivicoviaturaCountAggregateOutputType = {
    codServicoViatura: number
    descServico: number
    _all: number
  }


  export type SerivicoviaturaAvgAggregateInputType = {
    codServicoViatura?: true
  }

  export type SerivicoviaturaSumAggregateInputType = {
    codServicoViatura?: true
  }

  export type SerivicoviaturaMinAggregateInputType = {
    codServicoViatura?: true
    descServico?: true
  }

  export type SerivicoviaturaMaxAggregateInputType = {
    codServicoViatura?: true
    descServico?: true
  }

  export type SerivicoviaturaCountAggregateInputType = {
    codServicoViatura?: true
    descServico?: true
    _all?: true
  }

  export type SerivicoviaturaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serivicoviatura to aggregate.
     */
    where?: serivicoviaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serivicoviaturas to fetch.
     */
    orderBy?: serivicoviaturaOrderByWithRelationInput | serivicoviaturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serivicoviaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serivicoviaturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serivicoviaturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned serivicoviaturas
    **/
    _count?: true | SerivicoviaturaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SerivicoviaturaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SerivicoviaturaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SerivicoviaturaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SerivicoviaturaMaxAggregateInputType
  }

  export type GetSerivicoviaturaAggregateType<T extends SerivicoviaturaAggregateArgs> = {
        [P in keyof T & keyof AggregateSerivicoviatura]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSerivicoviatura[P]>
      : GetScalarType<T[P], AggregateSerivicoviatura[P]>
  }




  export type serivicoviaturaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serivicoviaturaWhereInput
    orderBy?: serivicoviaturaOrderByWithAggregationInput | serivicoviaturaOrderByWithAggregationInput[]
    by: SerivicoviaturaScalarFieldEnum[] | SerivicoviaturaScalarFieldEnum
    having?: serivicoviaturaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SerivicoviaturaCountAggregateInputType | true
    _avg?: SerivicoviaturaAvgAggregateInputType
    _sum?: SerivicoviaturaSumAggregateInputType
    _min?: SerivicoviaturaMinAggregateInputType
    _max?: SerivicoviaturaMaxAggregateInputType
  }

  export type SerivicoviaturaGroupByOutputType = {
    codServicoViatura: number
    descServico: string
    _count: SerivicoviaturaCountAggregateOutputType | null
    _avg: SerivicoviaturaAvgAggregateOutputType | null
    _sum: SerivicoviaturaSumAggregateOutputType | null
    _min: SerivicoviaturaMinAggregateOutputType | null
    _max: SerivicoviaturaMaxAggregateOutputType | null
  }

  type GetSerivicoviaturaGroupByPayload<T extends serivicoviaturaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SerivicoviaturaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SerivicoviaturaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SerivicoviaturaGroupByOutputType[P]>
            : GetScalarType<T[P], SerivicoviaturaGroupByOutputType[P]>
        }
      >
    >


  export type serivicoviaturaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codServicoViatura?: boolean
    descServico?: boolean
    livrete?: boolean | serivicoviatura$livreteArgs<ExtArgs>
    _count?: boolean | SerivicoviaturaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serivicoviatura"]>


  export type serivicoviaturaSelectScalar = {
    codServicoViatura?: boolean
    descServico?: boolean
  }

  export type serivicoviaturaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    livrete?: boolean | serivicoviatura$livreteArgs<ExtArgs>
    _count?: boolean | SerivicoviaturaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $serivicoviaturaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "serivicoviatura"
    objects: {
      livrete: Prisma.$livretePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      codServicoViatura: number
      descServico: string
    }, ExtArgs["result"]["serivicoviatura"]>
    composites: {}
  }

  type serivicoviaturaGetPayload<S extends boolean | null | undefined | serivicoviaturaDefaultArgs> = $Result.GetResult<Prisma.$serivicoviaturaPayload, S>

  type serivicoviaturaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<serivicoviaturaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SerivicoviaturaCountAggregateInputType | true
    }

  export interface serivicoviaturaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['serivicoviatura'], meta: { name: 'serivicoviatura' } }
    /**
     * Find zero or one Serivicoviatura that matches the filter.
     * @param {serivicoviaturaFindUniqueArgs} args - Arguments to find a Serivicoviatura
     * @example
     * // Get one Serivicoviatura
     * const serivicoviatura = await prisma.serivicoviatura.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends serivicoviaturaFindUniqueArgs>(args: SelectSubset<T, serivicoviaturaFindUniqueArgs<ExtArgs>>): Prisma__serivicoviaturaClient<$Result.GetResult<Prisma.$serivicoviaturaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Serivicoviatura that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {serivicoviaturaFindUniqueOrThrowArgs} args - Arguments to find a Serivicoviatura
     * @example
     * // Get one Serivicoviatura
     * const serivicoviatura = await prisma.serivicoviatura.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends serivicoviaturaFindUniqueOrThrowArgs>(args: SelectSubset<T, serivicoviaturaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__serivicoviaturaClient<$Result.GetResult<Prisma.$serivicoviaturaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Serivicoviatura that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serivicoviaturaFindFirstArgs} args - Arguments to find a Serivicoviatura
     * @example
     * // Get one Serivicoviatura
     * const serivicoviatura = await prisma.serivicoviatura.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends serivicoviaturaFindFirstArgs>(args?: SelectSubset<T, serivicoviaturaFindFirstArgs<ExtArgs>>): Prisma__serivicoviaturaClient<$Result.GetResult<Prisma.$serivicoviaturaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Serivicoviatura that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serivicoviaturaFindFirstOrThrowArgs} args - Arguments to find a Serivicoviatura
     * @example
     * // Get one Serivicoviatura
     * const serivicoviatura = await prisma.serivicoviatura.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends serivicoviaturaFindFirstOrThrowArgs>(args?: SelectSubset<T, serivicoviaturaFindFirstOrThrowArgs<ExtArgs>>): Prisma__serivicoviaturaClient<$Result.GetResult<Prisma.$serivicoviaturaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Serivicoviaturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serivicoviaturaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Serivicoviaturas
     * const serivicoviaturas = await prisma.serivicoviatura.findMany()
     * 
     * // Get first 10 Serivicoviaturas
     * const serivicoviaturas = await prisma.serivicoviatura.findMany({ take: 10 })
     * 
     * // Only select the `codServicoViatura`
     * const serivicoviaturaWithCodServicoViaturaOnly = await prisma.serivicoviatura.findMany({ select: { codServicoViatura: true } })
     * 
     */
    findMany<T extends serivicoviaturaFindManyArgs>(args?: SelectSubset<T, serivicoviaturaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serivicoviaturaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Serivicoviatura.
     * @param {serivicoviaturaCreateArgs} args - Arguments to create a Serivicoviatura.
     * @example
     * // Create one Serivicoviatura
     * const Serivicoviatura = await prisma.serivicoviatura.create({
     *   data: {
     *     // ... data to create a Serivicoviatura
     *   }
     * })
     * 
     */
    create<T extends serivicoviaturaCreateArgs>(args: SelectSubset<T, serivicoviaturaCreateArgs<ExtArgs>>): Prisma__serivicoviaturaClient<$Result.GetResult<Prisma.$serivicoviaturaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Serivicoviaturas.
     * @param {serivicoviaturaCreateManyArgs} args - Arguments to create many Serivicoviaturas.
     * @example
     * // Create many Serivicoviaturas
     * const serivicoviatura = await prisma.serivicoviatura.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends serivicoviaturaCreateManyArgs>(args?: SelectSubset<T, serivicoviaturaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Serivicoviatura.
     * @param {serivicoviaturaDeleteArgs} args - Arguments to delete one Serivicoviatura.
     * @example
     * // Delete one Serivicoviatura
     * const Serivicoviatura = await prisma.serivicoviatura.delete({
     *   where: {
     *     // ... filter to delete one Serivicoviatura
     *   }
     * })
     * 
     */
    delete<T extends serivicoviaturaDeleteArgs>(args: SelectSubset<T, serivicoviaturaDeleteArgs<ExtArgs>>): Prisma__serivicoviaturaClient<$Result.GetResult<Prisma.$serivicoviaturaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Serivicoviatura.
     * @param {serivicoviaturaUpdateArgs} args - Arguments to update one Serivicoviatura.
     * @example
     * // Update one Serivicoviatura
     * const serivicoviatura = await prisma.serivicoviatura.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends serivicoviaturaUpdateArgs>(args: SelectSubset<T, serivicoviaturaUpdateArgs<ExtArgs>>): Prisma__serivicoviaturaClient<$Result.GetResult<Prisma.$serivicoviaturaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Serivicoviaturas.
     * @param {serivicoviaturaDeleteManyArgs} args - Arguments to filter Serivicoviaturas to delete.
     * @example
     * // Delete a few Serivicoviaturas
     * const { count } = await prisma.serivicoviatura.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends serivicoviaturaDeleteManyArgs>(args?: SelectSubset<T, serivicoviaturaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Serivicoviaturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serivicoviaturaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Serivicoviaturas
     * const serivicoviatura = await prisma.serivicoviatura.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends serivicoviaturaUpdateManyArgs>(args: SelectSubset<T, serivicoviaturaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Serivicoviatura.
     * @param {serivicoviaturaUpsertArgs} args - Arguments to update or create a Serivicoviatura.
     * @example
     * // Update or create a Serivicoviatura
     * const serivicoviatura = await prisma.serivicoviatura.upsert({
     *   create: {
     *     // ... data to create a Serivicoviatura
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Serivicoviatura we want to update
     *   }
     * })
     */
    upsert<T extends serivicoviaturaUpsertArgs>(args: SelectSubset<T, serivicoviaturaUpsertArgs<ExtArgs>>): Prisma__serivicoviaturaClient<$Result.GetResult<Prisma.$serivicoviaturaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Serivicoviaturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serivicoviaturaCountArgs} args - Arguments to filter Serivicoviaturas to count.
     * @example
     * // Count the number of Serivicoviaturas
     * const count = await prisma.serivicoviatura.count({
     *   where: {
     *     // ... the filter for the Serivicoviaturas we want to count
     *   }
     * })
    **/
    count<T extends serivicoviaturaCountArgs>(
      args?: Subset<T, serivicoviaturaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SerivicoviaturaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Serivicoviatura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SerivicoviaturaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SerivicoviaturaAggregateArgs>(args: Subset<T, SerivicoviaturaAggregateArgs>): Prisma.PrismaPromise<GetSerivicoviaturaAggregateType<T>>

    /**
     * Group by Serivicoviatura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serivicoviaturaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serivicoviaturaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serivicoviaturaGroupByArgs['orderBy'] }
        : { orderBy?: serivicoviaturaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serivicoviaturaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSerivicoviaturaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the serivicoviatura model
   */
  readonly fields: serivicoviaturaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for serivicoviatura.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__serivicoviaturaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    livrete<T extends serivicoviatura$livreteArgs<ExtArgs> = {}>(args?: Subset<T, serivicoviatura$livreteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$livretePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the serivicoviatura model
   */ 
  interface serivicoviaturaFieldRefs {
    readonly codServicoViatura: FieldRef<"serivicoviatura", 'Int'>
    readonly descServico: FieldRef<"serivicoviatura", 'String'>
  }
    

  // Custom InputTypes
  /**
   * serivicoviatura findUnique
   */
  export type serivicoviaturaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serivicoviatura
     */
    select?: serivicoviaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serivicoviaturaInclude<ExtArgs> | null
    /**
     * Filter, which serivicoviatura to fetch.
     */
    where: serivicoviaturaWhereUniqueInput
  }

  /**
   * serivicoviatura findUniqueOrThrow
   */
  export type serivicoviaturaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serivicoviatura
     */
    select?: serivicoviaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serivicoviaturaInclude<ExtArgs> | null
    /**
     * Filter, which serivicoviatura to fetch.
     */
    where: serivicoviaturaWhereUniqueInput
  }

  /**
   * serivicoviatura findFirst
   */
  export type serivicoviaturaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serivicoviatura
     */
    select?: serivicoviaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serivicoviaturaInclude<ExtArgs> | null
    /**
     * Filter, which serivicoviatura to fetch.
     */
    where?: serivicoviaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serivicoviaturas to fetch.
     */
    orderBy?: serivicoviaturaOrderByWithRelationInput | serivicoviaturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serivicoviaturas.
     */
    cursor?: serivicoviaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serivicoviaturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serivicoviaturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serivicoviaturas.
     */
    distinct?: SerivicoviaturaScalarFieldEnum | SerivicoviaturaScalarFieldEnum[]
  }

  /**
   * serivicoviatura findFirstOrThrow
   */
  export type serivicoviaturaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serivicoviatura
     */
    select?: serivicoviaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serivicoviaturaInclude<ExtArgs> | null
    /**
     * Filter, which serivicoviatura to fetch.
     */
    where?: serivicoviaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serivicoviaturas to fetch.
     */
    orderBy?: serivicoviaturaOrderByWithRelationInput | serivicoviaturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serivicoviaturas.
     */
    cursor?: serivicoviaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serivicoviaturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serivicoviaturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serivicoviaturas.
     */
    distinct?: SerivicoviaturaScalarFieldEnum | SerivicoviaturaScalarFieldEnum[]
  }

  /**
   * serivicoviatura findMany
   */
  export type serivicoviaturaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serivicoviatura
     */
    select?: serivicoviaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serivicoviaturaInclude<ExtArgs> | null
    /**
     * Filter, which serivicoviaturas to fetch.
     */
    where?: serivicoviaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serivicoviaturas to fetch.
     */
    orderBy?: serivicoviaturaOrderByWithRelationInput | serivicoviaturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing serivicoviaturas.
     */
    cursor?: serivicoviaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serivicoviaturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serivicoviaturas.
     */
    skip?: number
    distinct?: SerivicoviaturaScalarFieldEnum | SerivicoviaturaScalarFieldEnum[]
  }

  /**
   * serivicoviatura create
   */
  export type serivicoviaturaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serivicoviatura
     */
    select?: serivicoviaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serivicoviaturaInclude<ExtArgs> | null
    /**
     * The data needed to create a serivicoviatura.
     */
    data: XOR<serivicoviaturaCreateInput, serivicoviaturaUncheckedCreateInput>
  }

  /**
   * serivicoviatura createMany
   */
  export type serivicoviaturaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many serivicoviaturas.
     */
    data: serivicoviaturaCreateManyInput | serivicoviaturaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * serivicoviatura update
   */
  export type serivicoviaturaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serivicoviatura
     */
    select?: serivicoviaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serivicoviaturaInclude<ExtArgs> | null
    /**
     * The data needed to update a serivicoviatura.
     */
    data: XOR<serivicoviaturaUpdateInput, serivicoviaturaUncheckedUpdateInput>
    /**
     * Choose, which serivicoviatura to update.
     */
    where: serivicoviaturaWhereUniqueInput
  }

  /**
   * serivicoviatura updateMany
   */
  export type serivicoviaturaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update serivicoviaturas.
     */
    data: XOR<serivicoviaturaUpdateManyMutationInput, serivicoviaturaUncheckedUpdateManyInput>
    /**
     * Filter which serivicoviaturas to update
     */
    where?: serivicoviaturaWhereInput
  }

  /**
   * serivicoviatura upsert
   */
  export type serivicoviaturaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serivicoviatura
     */
    select?: serivicoviaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serivicoviaturaInclude<ExtArgs> | null
    /**
     * The filter to search for the serivicoviatura to update in case it exists.
     */
    where: serivicoviaturaWhereUniqueInput
    /**
     * In case the serivicoviatura found by the `where` argument doesn't exist, create a new serivicoviatura with this data.
     */
    create: XOR<serivicoviaturaCreateInput, serivicoviaturaUncheckedCreateInput>
    /**
     * In case the serivicoviatura was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serivicoviaturaUpdateInput, serivicoviaturaUncheckedUpdateInput>
  }

  /**
   * serivicoviatura delete
   */
  export type serivicoviaturaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serivicoviatura
     */
    select?: serivicoviaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serivicoviaturaInclude<ExtArgs> | null
    /**
     * Filter which serivicoviatura to delete.
     */
    where: serivicoviaturaWhereUniqueInput
  }

  /**
   * serivicoviatura deleteMany
   */
  export type serivicoviaturaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serivicoviaturas to delete
     */
    where?: serivicoviaturaWhereInput
  }

  /**
   * serivicoviatura.livrete
   */
  export type serivicoviatura$livreteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the livrete
     */
    select?: livreteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: livreteInclude<ExtArgs> | null
    where?: livreteWhereInput
    orderBy?: livreteOrderByWithRelationInput | livreteOrderByWithRelationInput[]
    cursor?: livreteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LivreteScalarFieldEnum | LivreteScalarFieldEnum[]
  }

  /**
   * serivicoviatura without action
   */
  export type serivicoviaturaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serivicoviatura
     */
    select?: serivicoviaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: serivicoviaturaInclude<ExtArgs> | null
  }


  /**
   * Model tipoinfracao
   */

  export type AggregateTipoinfracao = {
    _count: TipoinfracaoCountAggregateOutputType | null
    _avg: TipoinfracaoAvgAggregateOutputType | null
    _sum: TipoinfracaoSumAggregateOutputType | null
    _min: TipoinfracaoMinAggregateOutputType | null
    _max: TipoinfracaoMaxAggregateOutputType | null
  }

  export type TipoinfracaoAvgAggregateOutputType = {
    codTipoInfracao: number | null
  }

  export type TipoinfracaoSumAggregateOutputType = {
    codTipoInfracao: number | null
  }

  export type TipoinfracaoMinAggregateOutputType = {
    codTipoInfracao: number | null
    descTipoInfracao: string | null
    valorInfracao: string | null
  }

  export type TipoinfracaoMaxAggregateOutputType = {
    codTipoInfracao: number | null
    descTipoInfracao: string | null
    valorInfracao: string | null
  }

  export type TipoinfracaoCountAggregateOutputType = {
    codTipoInfracao: number
    descTipoInfracao: number
    valorInfracao: number
    _all: number
  }


  export type TipoinfracaoAvgAggregateInputType = {
    codTipoInfracao?: true
  }

  export type TipoinfracaoSumAggregateInputType = {
    codTipoInfracao?: true
  }

  export type TipoinfracaoMinAggregateInputType = {
    codTipoInfracao?: true
    descTipoInfracao?: true
    valorInfracao?: true
  }

  export type TipoinfracaoMaxAggregateInputType = {
    codTipoInfracao?: true
    descTipoInfracao?: true
    valorInfracao?: true
  }

  export type TipoinfracaoCountAggregateInputType = {
    codTipoInfracao?: true
    descTipoInfracao?: true
    valorInfracao?: true
    _all?: true
  }

  export type TipoinfracaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipoinfracao to aggregate.
     */
    where?: tipoinfracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoinfracaos to fetch.
     */
    orderBy?: tipoinfracaoOrderByWithRelationInput | tipoinfracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipoinfracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoinfracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoinfracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipoinfracaos
    **/
    _count?: true | TipoinfracaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoinfracaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoinfracaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoinfracaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoinfracaoMaxAggregateInputType
  }

  export type GetTipoinfracaoAggregateType<T extends TipoinfracaoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoinfracao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoinfracao[P]>
      : GetScalarType<T[P], AggregateTipoinfracao[P]>
  }




  export type tipoinfracaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tipoinfracaoWhereInput
    orderBy?: tipoinfracaoOrderByWithAggregationInput | tipoinfracaoOrderByWithAggregationInput[]
    by: TipoinfracaoScalarFieldEnum[] | TipoinfracaoScalarFieldEnum
    having?: tipoinfracaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoinfracaoCountAggregateInputType | true
    _avg?: TipoinfracaoAvgAggregateInputType
    _sum?: TipoinfracaoSumAggregateInputType
    _min?: TipoinfracaoMinAggregateInputType
    _max?: TipoinfracaoMaxAggregateInputType
  }

  export type TipoinfracaoGroupByOutputType = {
    codTipoInfracao: number
    descTipoInfracao: string
    valorInfracao: string
    _count: TipoinfracaoCountAggregateOutputType | null
    _avg: TipoinfracaoAvgAggregateOutputType | null
    _sum: TipoinfracaoSumAggregateOutputType | null
    _min: TipoinfracaoMinAggregateOutputType | null
    _max: TipoinfracaoMaxAggregateOutputType | null
  }

  type GetTipoinfracaoGroupByPayload<T extends tipoinfracaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoinfracaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoinfracaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoinfracaoGroupByOutputType[P]>
            : GetScalarType<T[P], TipoinfracaoGroupByOutputType[P]>
        }
      >
    >


  export type tipoinfracaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codTipoInfracao?: boolean
    descTipoInfracao?: boolean
    valorInfracao?: boolean
    infracao?: boolean | tipoinfracao$infracaoArgs<ExtArgs>
    _count?: boolean | TipoinfracaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoinfracao"]>


  export type tipoinfracaoSelectScalar = {
    codTipoInfracao?: boolean
    descTipoInfracao?: boolean
    valorInfracao?: boolean
  }

  export type tipoinfracaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    infracao?: boolean | tipoinfracao$infracaoArgs<ExtArgs>
    _count?: boolean | TipoinfracaoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $tipoinfracaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tipoinfracao"
    objects: {
      infracao: Prisma.$infracaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      codTipoInfracao: number
      descTipoInfracao: string
      valorInfracao: string
    }, ExtArgs["result"]["tipoinfracao"]>
    composites: {}
  }

  type tipoinfracaoGetPayload<S extends boolean | null | undefined | tipoinfracaoDefaultArgs> = $Result.GetResult<Prisma.$tipoinfracaoPayload, S>

  type tipoinfracaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tipoinfracaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TipoinfracaoCountAggregateInputType | true
    }

  export interface tipoinfracaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tipoinfracao'], meta: { name: 'tipoinfracao' } }
    /**
     * Find zero or one Tipoinfracao that matches the filter.
     * @param {tipoinfracaoFindUniqueArgs} args - Arguments to find a Tipoinfracao
     * @example
     * // Get one Tipoinfracao
     * const tipoinfracao = await prisma.tipoinfracao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tipoinfracaoFindUniqueArgs>(args: SelectSubset<T, tipoinfracaoFindUniqueArgs<ExtArgs>>): Prisma__tipoinfracaoClient<$Result.GetResult<Prisma.$tipoinfracaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tipoinfracao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tipoinfracaoFindUniqueOrThrowArgs} args - Arguments to find a Tipoinfracao
     * @example
     * // Get one Tipoinfracao
     * const tipoinfracao = await prisma.tipoinfracao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tipoinfracaoFindUniqueOrThrowArgs>(args: SelectSubset<T, tipoinfracaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tipoinfracaoClient<$Result.GetResult<Prisma.$tipoinfracaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tipoinfracao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoinfracaoFindFirstArgs} args - Arguments to find a Tipoinfracao
     * @example
     * // Get one Tipoinfracao
     * const tipoinfracao = await prisma.tipoinfracao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tipoinfracaoFindFirstArgs>(args?: SelectSubset<T, tipoinfracaoFindFirstArgs<ExtArgs>>): Prisma__tipoinfracaoClient<$Result.GetResult<Prisma.$tipoinfracaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tipoinfracao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoinfracaoFindFirstOrThrowArgs} args - Arguments to find a Tipoinfracao
     * @example
     * // Get one Tipoinfracao
     * const tipoinfracao = await prisma.tipoinfracao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tipoinfracaoFindFirstOrThrowArgs>(args?: SelectSubset<T, tipoinfracaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__tipoinfracaoClient<$Result.GetResult<Prisma.$tipoinfracaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tipoinfracaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoinfracaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tipoinfracaos
     * const tipoinfracaos = await prisma.tipoinfracao.findMany()
     * 
     * // Get first 10 Tipoinfracaos
     * const tipoinfracaos = await prisma.tipoinfracao.findMany({ take: 10 })
     * 
     * // Only select the `codTipoInfracao`
     * const tipoinfracaoWithCodTipoInfracaoOnly = await prisma.tipoinfracao.findMany({ select: { codTipoInfracao: true } })
     * 
     */
    findMany<T extends tipoinfracaoFindManyArgs>(args?: SelectSubset<T, tipoinfracaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoinfracaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tipoinfracao.
     * @param {tipoinfracaoCreateArgs} args - Arguments to create a Tipoinfracao.
     * @example
     * // Create one Tipoinfracao
     * const Tipoinfracao = await prisma.tipoinfracao.create({
     *   data: {
     *     // ... data to create a Tipoinfracao
     *   }
     * })
     * 
     */
    create<T extends tipoinfracaoCreateArgs>(args: SelectSubset<T, tipoinfracaoCreateArgs<ExtArgs>>): Prisma__tipoinfracaoClient<$Result.GetResult<Prisma.$tipoinfracaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tipoinfracaos.
     * @param {tipoinfracaoCreateManyArgs} args - Arguments to create many Tipoinfracaos.
     * @example
     * // Create many Tipoinfracaos
     * const tipoinfracao = await prisma.tipoinfracao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tipoinfracaoCreateManyArgs>(args?: SelectSubset<T, tipoinfracaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tipoinfracao.
     * @param {tipoinfracaoDeleteArgs} args - Arguments to delete one Tipoinfracao.
     * @example
     * // Delete one Tipoinfracao
     * const Tipoinfracao = await prisma.tipoinfracao.delete({
     *   where: {
     *     // ... filter to delete one Tipoinfracao
     *   }
     * })
     * 
     */
    delete<T extends tipoinfracaoDeleteArgs>(args: SelectSubset<T, tipoinfracaoDeleteArgs<ExtArgs>>): Prisma__tipoinfracaoClient<$Result.GetResult<Prisma.$tipoinfracaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tipoinfracao.
     * @param {tipoinfracaoUpdateArgs} args - Arguments to update one Tipoinfracao.
     * @example
     * // Update one Tipoinfracao
     * const tipoinfracao = await prisma.tipoinfracao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tipoinfracaoUpdateArgs>(args: SelectSubset<T, tipoinfracaoUpdateArgs<ExtArgs>>): Prisma__tipoinfracaoClient<$Result.GetResult<Prisma.$tipoinfracaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tipoinfracaos.
     * @param {tipoinfracaoDeleteManyArgs} args - Arguments to filter Tipoinfracaos to delete.
     * @example
     * // Delete a few Tipoinfracaos
     * const { count } = await prisma.tipoinfracao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tipoinfracaoDeleteManyArgs>(args?: SelectSubset<T, tipoinfracaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tipoinfracaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoinfracaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tipoinfracaos
     * const tipoinfracao = await prisma.tipoinfracao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tipoinfracaoUpdateManyArgs>(args: SelectSubset<T, tipoinfracaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tipoinfracao.
     * @param {tipoinfracaoUpsertArgs} args - Arguments to update or create a Tipoinfracao.
     * @example
     * // Update or create a Tipoinfracao
     * const tipoinfracao = await prisma.tipoinfracao.upsert({
     *   create: {
     *     // ... data to create a Tipoinfracao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tipoinfracao we want to update
     *   }
     * })
     */
    upsert<T extends tipoinfracaoUpsertArgs>(args: SelectSubset<T, tipoinfracaoUpsertArgs<ExtArgs>>): Prisma__tipoinfracaoClient<$Result.GetResult<Prisma.$tipoinfracaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tipoinfracaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoinfracaoCountArgs} args - Arguments to filter Tipoinfracaos to count.
     * @example
     * // Count the number of Tipoinfracaos
     * const count = await prisma.tipoinfracao.count({
     *   where: {
     *     // ... the filter for the Tipoinfracaos we want to count
     *   }
     * })
    **/
    count<T extends tipoinfracaoCountArgs>(
      args?: Subset<T, tipoinfracaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoinfracaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tipoinfracao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoinfracaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoinfracaoAggregateArgs>(args: Subset<T, TipoinfracaoAggregateArgs>): Prisma.PrismaPromise<GetTipoinfracaoAggregateType<T>>

    /**
     * Group by Tipoinfracao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoinfracaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tipoinfracaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipoinfracaoGroupByArgs['orderBy'] }
        : { orderBy?: tipoinfracaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tipoinfracaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoinfracaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tipoinfracao model
   */
  readonly fields: tipoinfracaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tipoinfracao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tipoinfracaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    infracao<T extends tipoinfracao$infracaoArgs<ExtArgs> = {}>(args?: Subset<T, tipoinfracao$infracaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$infracaoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tipoinfracao model
   */ 
  interface tipoinfracaoFieldRefs {
    readonly codTipoInfracao: FieldRef<"tipoinfracao", 'Int'>
    readonly descTipoInfracao: FieldRef<"tipoinfracao", 'String'>
    readonly valorInfracao: FieldRef<"tipoinfracao", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tipoinfracao findUnique
   */
  export type tipoinfracaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoinfracao
     */
    select?: tipoinfracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoinfracaoInclude<ExtArgs> | null
    /**
     * Filter, which tipoinfracao to fetch.
     */
    where: tipoinfracaoWhereUniqueInput
  }

  /**
   * tipoinfracao findUniqueOrThrow
   */
  export type tipoinfracaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoinfracao
     */
    select?: tipoinfracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoinfracaoInclude<ExtArgs> | null
    /**
     * Filter, which tipoinfracao to fetch.
     */
    where: tipoinfracaoWhereUniqueInput
  }

  /**
   * tipoinfracao findFirst
   */
  export type tipoinfracaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoinfracao
     */
    select?: tipoinfracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoinfracaoInclude<ExtArgs> | null
    /**
     * Filter, which tipoinfracao to fetch.
     */
    where?: tipoinfracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoinfracaos to fetch.
     */
    orderBy?: tipoinfracaoOrderByWithRelationInput | tipoinfracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipoinfracaos.
     */
    cursor?: tipoinfracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoinfracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoinfracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipoinfracaos.
     */
    distinct?: TipoinfracaoScalarFieldEnum | TipoinfracaoScalarFieldEnum[]
  }

  /**
   * tipoinfracao findFirstOrThrow
   */
  export type tipoinfracaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoinfracao
     */
    select?: tipoinfracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoinfracaoInclude<ExtArgs> | null
    /**
     * Filter, which tipoinfracao to fetch.
     */
    where?: tipoinfracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoinfracaos to fetch.
     */
    orderBy?: tipoinfracaoOrderByWithRelationInput | tipoinfracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipoinfracaos.
     */
    cursor?: tipoinfracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoinfracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoinfracaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipoinfracaos.
     */
    distinct?: TipoinfracaoScalarFieldEnum | TipoinfracaoScalarFieldEnum[]
  }

  /**
   * tipoinfracao findMany
   */
  export type tipoinfracaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoinfracao
     */
    select?: tipoinfracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoinfracaoInclude<ExtArgs> | null
    /**
     * Filter, which tipoinfracaos to fetch.
     */
    where?: tipoinfracaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoinfracaos to fetch.
     */
    orderBy?: tipoinfracaoOrderByWithRelationInput | tipoinfracaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipoinfracaos.
     */
    cursor?: tipoinfracaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoinfracaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoinfracaos.
     */
    skip?: number
    distinct?: TipoinfracaoScalarFieldEnum | TipoinfracaoScalarFieldEnum[]
  }

  /**
   * tipoinfracao create
   */
  export type tipoinfracaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoinfracao
     */
    select?: tipoinfracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoinfracaoInclude<ExtArgs> | null
    /**
     * The data needed to create a tipoinfracao.
     */
    data: XOR<tipoinfracaoCreateInput, tipoinfracaoUncheckedCreateInput>
  }

  /**
   * tipoinfracao createMany
   */
  export type tipoinfracaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tipoinfracaos.
     */
    data: tipoinfracaoCreateManyInput | tipoinfracaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tipoinfracao update
   */
  export type tipoinfracaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoinfracao
     */
    select?: tipoinfracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoinfracaoInclude<ExtArgs> | null
    /**
     * The data needed to update a tipoinfracao.
     */
    data: XOR<tipoinfracaoUpdateInput, tipoinfracaoUncheckedUpdateInput>
    /**
     * Choose, which tipoinfracao to update.
     */
    where: tipoinfracaoWhereUniqueInput
  }

  /**
   * tipoinfracao updateMany
   */
  export type tipoinfracaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tipoinfracaos.
     */
    data: XOR<tipoinfracaoUpdateManyMutationInput, tipoinfracaoUncheckedUpdateManyInput>
    /**
     * Filter which tipoinfracaos to update
     */
    where?: tipoinfracaoWhereInput
  }

  /**
   * tipoinfracao upsert
   */
  export type tipoinfracaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoinfracao
     */
    select?: tipoinfracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoinfracaoInclude<ExtArgs> | null
    /**
     * The filter to search for the tipoinfracao to update in case it exists.
     */
    where: tipoinfracaoWhereUniqueInput
    /**
     * In case the tipoinfracao found by the `where` argument doesn't exist, create a new tipoinfracao with this data.
     */
    create: XOR<tipoinfracaoCreateInput, tipoinfracaoUncheckedCreateInput>
    /**
     * In case the tipoinfracao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipoinfracaoUpdateInput, tipoinfracaoUncheckedUpdateInput>
  }

  /**
   * tipoinfracao delete
   */
  export type tipoinfracaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoinfracao
     */
    select?: tipoinfracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoinfracaoInclude<ExtArgs> | null
    /**
     * Filter which tipoinfracao to delete.
     */
    where: tipoinfracaoWhereUniqueInput
  }

  /**
   * tipoinfracao deleteMany
   */
  export type tipoinfracaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipoinfracaos to delete
     */
    where?: tipoinfracaoWhereInput
  }

  /**
   * tipoinfracao.infracao
   */
  export type tipoinfracao$infracaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the infracao
     */
    select?: infracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: infracaoInclude<ExtArgs> | null
    where?: infracaoWhereInput
    orderBy?: infracaoOrderByWithRelationInput | infracaoOrderByWithRelationInput[]
    cursor?: infracaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InfracaoScalarFieldEnum | InfracaoScalarFieldEnum[]
  }

  /**
   * tipoinfracao without action
   */
  export type tipoinfracaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoinfracao
     */
    select?: tipoinfracaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoinfracaoInclude<ExtArgs> | null
  }


  /**
   * Model tiporoubo
   */

  export type AggregateTiporoubo = {
    _count: TiporouboCountAggregateOutputType | null
    _avg: TiporouboAvgAggregateOutputType | null
    _sum: TiporouboSumAggregateOutputType | null
    _min: TiporouboMinAggregateOutputType | null
    _max: TiporouboMaxAggregateOutputType | null
  }

  export type TiporouboAvgAggregateOutputType = {
    codTipoRoubo: number | null
  }

  export type TiporouboSumAggregateOutputType = {
    codTipoRoubo: number | null
  }

  export type TiporouboMinAggregateOutputType = {
    codTipoRoubo: number | null
    descTipoRoubo: string | null
  }

  export type TiporouboMaxAggregateOutputType = {
    codTipoRoubo: number | null
    descTipoRoubo: string | null
  }

  export type TiporouboCountAggregateOutputType = {
    codTipoRoubo: number
    descTipoRoubo: number
    _all: number
  }


  export type TiporouboAvgAggregateInputType = {
    codTipoRoubo?: true
  }

  export type TiporouboSumAggregateInputType = {
    codTipoRoubo?: true
  }

  export type TiporouboMinAggregateInputType = {
    codTipoRoubo?: true
    descTipoRoubo?: true
  }

  export type TiporouboMaxAggregateInputType = {
    codTipoRoubo?: true
    descTipoRoubo?: true
  }

  export type TiporouboCountAggregateInputType = {
    codTipoRoubo?: true
    descTipoRoubo?: true
    _all?: true
  }

  export type TiporouboAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tiporoubo to aggregate.
     */
    where?: tiporouboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tiporoubos to fetch.
     */
    orderBy?: tiporouboOrderByWithRelationInput | tiporouboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tiporouboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tiporoubos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tiporoubos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tiporoubos
    **/
    _count?: true | TiporouboCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TiporouboAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TiporouboSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TiporouboMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TiporouboMaxAggregateInputType
  }

  export type GetTiporouboAggregateType<T extends TiporouboAggregateArgs> = {
        [P in keyof T & keyof AggregateTiporoubo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTiporoubo[P]>
      : GetScalarType<T[P], AggregateTiporoubo[P]>
  }




  export type tiporouboGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tiporouboWhereInput
    orderBy?: tiporouboOrderByWithAggregationInput | tiporouboOrderByWithAggregationInput[]
    by: TiporouboScalarFieldEnum[] | TiporouboScalarFieldEnum
    having?: tiporouboScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TiporouboCountAggregateInputType | true
    _avg?: TiporouboAvgAggregateInputType
    _sum?: TiporouboSumAggregateInputType
    _min?: TiporouboMinAggregateInputType
    _max?: TiporouboMaxAggregateInputType
  }

  export type TiporouboGroupByOutputType = {
    codTipoRoubo: number
    descTipoRoubo: string
    _count: TiporouboCountAggregateOutputType | null
    _avg: TiporouboAvgAggregateOutputType | null
    _sum: TiporouboSumAggregateOutputType | null
    _min: TiporouboMinAggregateOutputType | null
    _max: TiporouboMaxAggregateOutputType | null
  }

  type GetTiporouboGroupByPayload<T extends tiporouboGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TiporouboGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TiporouboGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TiporouboGroupByOutputType[P]>
            : GetScalarType<T[P], TiporouboGroupByOutputType[P]>
        }
      >
    >


  export type tiporouboSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codTipoRoubo?: boolean
    descTipoRoubo?: boolean
    alertaroubo?: boolean | tiporoubo$alertarouboArgs<ExtArgs>
    _count?: boolean | TiporouboCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tiporoubo"]>


  export type tiporouboSelectScalar = {
    codTipoRoubo?: boolean
    descTipoRoubo?: boolean
  }

  export type tiporouboInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alertaroubo?: boolean | tiporoubo$alertarouboArgs<ExtArgs>
    _count?: boolean | TiporouboCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $tiporouboPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tiporoubo"
    objects: {
      alertaroubo: Prisma.$alertarouboPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      codTipoRoubo: number
      descTipoRoubo: string
    }, ExtArgs["result"]["tiporoubo"]>
    composites: {}
  }

  type tiporouboGetPayload<S extends boolean | null | undefined | tiporouboDefaultArgs> = $Result.GetResult<Prisma.$tiporouboPayload, S>

  type tiporouboCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tiporouboFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TiporouboCountAggregateInputType | true
    }

  export interface tiporouboDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tiporoubo'], meta: { name: 'tiporoubo' } }
    /**
     * Find zero or one Tiporoubo that matches the filter.
     * @param {tiporouboFindUniqueArgs} args - Arguments to find a Tiporoubo
     * @example
     * // Get one Tiporoubo
     * const tiporoubo = await prisma.tiporoubo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tiporouboFindUniqueArgs>(args: SelectSubset<T, tiporouboFindUniqueArgs<ExtArgs>>): Prisma__tiporouboClient<$Result.GetResult<Prisma.$tiporouboPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tiporoubo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tiporouboFindUniqueOrThrowArgs} args - Arguments to find a Tiporoubo
     * @example
     * // Get one Tiporoubo
     * const tiporoubo = await prisma.tiporoubo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tiporouboFindUniqueOrThrowArgs>(args: SelectSubset<T, tiporouboFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tiporouboClient<$Result.GetResult<Prisma.$tiporouboPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tiporoubo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tiporouboFindFirstArgs} args - Arguments to find a Tiporoubo
     * @example
     * // Get one Tiporoubo
     * const tiporoubo = await prisma.tiporoubo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tiporouboFindFirstArgs>(args?: SelectSubset<T, tiporouboFindFirstArgs<ExtArgs>>): Prisma__tiporouboClient<$Result.GetResult<Prisma.$tiporouboPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tiporoubo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tiporouboFindFirstOrThrowArgs} args - Arguments to find a Tiporoubo
     * @example
     * // Get one Tiporoubo
     * const tiporoubo = await prisma.tiporoubo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tiporouboFindFirstOrThrowArgs>(args?: SelectSubset<T, tiporouboFindFirstOrThrowArgs<ExtArgs>>): Prisma__tiporouboClient<$Result.GetResult<Prisma.$tiporouboPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tiporoubos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tiporouboFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tiporoubos
     * const tiporoubos = await prisma.tiporoubo.findMany()
     * 
     * // Get first 10 Tiporoubos
     * const tiporoubos = await prisma.tiporoubo.findMany({ take: 10 })
     * 
     * // Only select the `codTipoRoubo`
     * const tiporouboWithCodTipoRouboOnly = await prisma.tiporoubo.findMany({ select: { codTipoRoubo: true } })
     * 
     */
    findMany<T extends tiporouboFindManyArgs>(args?: SelectSubset<T, tiporouboFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tiporouboPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tiporoubo.
     * @param {tiporouboCreateArgs} args - Arguments to create a Tiporoubo.
     * @example
     * // Create one Tiporoubo
     * const Tiporoubo = await prisma.tiporoubo.create({
     *   data: {
     *     // ... data to create a Tiporoubo
     *   }
     * })
     * 
     */
    create<T extends tiporouboCreateArgs>(args: SelectSubset<T, tiporouboCreateArgs<ExtArgs>>): Prisma__tiporouboClient<$Result.GetResult<Prisma.$tiporouboPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tiporoubos.
     * @param {tiporouboCreateManyArgs} args - Arguments to create many Tiporoubos.
     * @example
     * // Create many Tiporoubos
     * const tiporoubo = await prisma.tiporoubo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tiporouboCreateManyArgs>(args?: SelectSubset<T, tiporouboCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tiporoubo.
     * @param {tiporouboDeleteArgs} args - Arguments to delete one Tiporoubo.
     * @example
     * // Delete one Tiporoubo
     * const Tiporoubo = await prisma.tiporoubo.delete({
     *   where: {
     *     // ... filter to delete one Tiporoubo
     *   }
     * })
     * 
     */
    delete<T extends tiporouboDeleteArgs>(args: SelectSubset<T, tiporouboDeleteArgs<ExtArgs>>): Prisma__tiporouboClient<$Result.GetResult<Prisma.$tiporouboPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tiporoubo.
     * @param {tiporouboUpdateArgs} args - Arguments to update one Tiporoubo.
     * @example
     * // Update one Tiporoubo
     * const tiporoubo = await prisma.tiporoubo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tiporouboUpdateArgs>(args: SelectSubset<T, tiporouboUpdateArgs<ExtArgs>>): Prisma__tiporouboClient<$Result.GetResult<Prisma.$tiporouboPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tiporoubos.
     * @param {tiporouboDeleteManyArgs} args - Arguments to filter Tiporoubos to delete.
     * @example
     * // Delete a few Tiporoubos
     * const { count } = await prisma.tiporoubo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tiporouboDeleteManyArgs>(args?: SelectSubset<T, tiporouboDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tiporoubos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tiporouboUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tiporoubos
     * const tiporoubo = await prisma.tiporoubo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tiporouboUpdateManyArgs>(args: SelectSubset<T, tiporouboUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tiporoubo.
     * @param {tiporouboUpsertArgs} args - Arguments to update or create a Tiporoubo.
     * @example
     * // Update or create a Tiporoubo
     * const tiporoubo = await prisma.tiporoubo.upsert({
     *   create: {
     *     // ... data to create a Tiporoubo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tiporoubo we want to update
     *   }
     * })
     */
    upsert<T extends tiporouboUpsertArgs>(args: SelectSubset<T, tiporouboUpsertArgs<ExtArgs>>): Prisma__tiporouboClient<$Result.GetResult<Prisma.$tiporouboPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tiporoubos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tiporouboCountArgs} args - Arguments to filter Tiporoubos to count.
     * @example
     * // Count the number of Tiporoubos
     * const count = await prisma.tiporoubo.count({
     *   where: {
     *     // ... the filter for the Tiporoubos we want to count
     *   }
     * })
    **/
    count<T extends tiporouboCountArgs>(
      args?: Subset<T, tiporouboCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TiporouboCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tiporoubo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiporouboAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TiporouboAggregateArgs>(args: Subset<T, TiporouboAggregateArgs>): Prisma.PrismaPromise<GetTiporouboAggregateType<T>>

    /**
     * Group by Tiporoubo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tiporouboGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tiporouboGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tiporouboGroupByArgs['orderBy'] }
        : { orderBy?: tiporouboGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tiporouboGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTiporouboGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tiporoubo model
   */
  readonly fields: tiporouboFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tiporoubo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tiporouboClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alertaroubo<T extends tiporoubo$alertarouboArgs<ExtArgs> = {}>(args?: Subset<T, tiporoubo$alertarouboArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alertarouboPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tiporoubo model
   */ 
  interface tiporouboFieldRefs {
    readonly codTipoRoubo: FieldRef<"tiporoubo", 'Int'>
    readonly descTipoRoubo: FieldRef<"tiporoubo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tiporoubo findUnique
   */
  export type tiporouboFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiporoubo
     */
    select?: tiporouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tiporouboInclude<ExtArgs> | null
    /**
     * Filter, which tiporoubo to fetch.
     */
    where: tiporouboWhereUniqueInput
  }

  /**
   * tiporoubo findUniqueOrThrow
   */
  export type tiporouboFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiporoubo
     */
    select?: tiporouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tiporouboInclude<ExtArgs> | null
    /**
     * Filter, which tiporoubo to fetch.
     */
    where: tiporouboWhereUniqueInput
  }

  /**
   * tiporoubo findFirst
   */
  export type tiporouboFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiporoubo
     */
    select?: tiporouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tiporouboInclude<ExtArgs> | null
    /**
     * Filter, which tiporoubo to fetch.
     */
    where?: tiporouboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tiporoubos to fetch.
     */
    orderBy?: tiporouboOrderByWithRelationInput | tiporouboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tiporoubos.
     */
    cursor?: tiporouboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tiporoubos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tiporoubos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tiporoubos.
     */
    distinct?: TiporouboScalarFieldEnum | TiporouboScalarFieldEnum[]
  }

  /**
   * tiporoubo findFirstOrThrow
   */
  export type tiporouboFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiporoubo
     */
    select?: tiporouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tiporouboInclude<ExtArgs> | null
    /**
     * Filter, which tiporoubo to fetch.
     */
    where?: tiporouboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tiporoubos to fetch.
     */
    orderBy?: tiporouboOrderByWithRelationInput | tiporouboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tiporoubos.
     */
    cursor?: tiporouboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tiporoubos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tiporoubos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tiporoubos.
     */
    distinct?: TiporouboScalarFieldEnum | TiporouboScalarFieldEnum[]
  }

  /**
   * tiporoubo findMany
   */
  export type tiporouboFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiporoubo
     */
    select?: tiporouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tiporouboInclude<ExtArgs> | null
    /**
     * Filter, which tiporoubos to fetch.
     */
    where?: tiporouboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tiporoubos to fetch.
     */
    orderBy?: tiporouboOrderByWithRelationInput | tiporouboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tiporoubos.
     */
    cursor?: tiporouboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tiporoubos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tiporoubos.
     */
    skip?: number
    distinct?: TiporouboScalarFieldEnum | TiporouboScalarFieldEnum[]
  }

  /**
   * tiporoubo create
   */
  export type tiporouboCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiporoubo
     */
    select?: tiporouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tiporouboInclude<ExtArgs> | null
    /**
     * The data needed to create a tiporoubo.
     */
    data: XOR<tiporouboCreateInput, tiporouboUncheckedCreateInput>
  }

  /**
   * tiporoubo createMany
   */
  export type tiporouboCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tiporoubos.
     */
    data: tiporouboCreateManyInput | tiporouboCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tiporoubo update
   */
  export type tiporouboUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiporoubo
     */
    select?: tiporouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tiporouboInclude<ExtArgs> | null
    /**
     * The data needed to update a tiporoubo.
     */
    data: XOR<tiporouboUpdateInput, tiporouboUncheckedUpdateInput>
    /**
     * Choose, which tiporoubo to update.
     */
    where: tiporouboWhereUniqueInput
  }

  /**
   * tiporoubo updateMany
   */
  export type tiporouboUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tiporoubos.
     */
    data: XOR<tiporouboUpdateManyMutationInput, tiporouboUncheckedUpdateManyInput>
    /**
     * Filter which tiporoubos to update
     */
    where?: tiporouboWhereInput
  }

  /**
   * tiporoubo upsert
   */
  export type tiporouboUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiporoubo
     */
    select?: tiporouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tiporouboInclude<ExtArgs> | null
    /**
     * The filter to search for the tiporoubo to update in case it exists.
     */
    where: tiporouboWhereUniqueInput
    /**
     * In case the tiporoubo found by the `where` argument doesn't exist, create a new tiporoubo with this data.
     */
    create: XOR<tiporouboCreateInput, tiporouboUncheckedCreateInput>
    /**
     * In case the tiporoubo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tiporouboUpdateInput, tiporouboUncheckedUpdateInput>
  }

  /**
   * tiporoubo delete
   */
  export type tiporouboDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiporoubo
     */
    select?: tiporouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tiporouboInclude<ExtArgs> | null
    /**
     * Filter which tiporoubo to delete.
     */
    where: tiporouboWhereUniqueInput
  }

  /**
   * tiporoubo deleteMany
   */
  export type tiporouboDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tiporoubos to delete
     */
    where?: tiporouboWhereInput
  }

  /**
   * tiporoubo.alertaroubo
   */
  export type tiporoubo$alertarouboArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertaroubo
     */
    select?: alertarouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertarouboInclude<ExtArgs> | null
    where?: alertarouboWhereInput
    orderBy?: alertarouboOrderByWithRelationInput | alertarouboOrderByWithRelationInput[]
    cursor?: alertarouboWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertarouboScalarFieldEnum | AlertarouboScalarFieldEnum[]
  }

  /**
   * tiporoubo without action
   */
  export type tiporouboDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tiporoubo
     */
    select?: tiporouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tiporouboInclude<ExtArgs> | null
  }


  /**
   * Model titulopropriedade
   */

  export type AggregateTitulopropriedade = {
    _count: TitulopropriedadeCountAggregateOutputType | null
    _avg: TitulopropriedadeAvgAggregateOutputType | null
    _sum: TitulopropriedadeSumAggregateOutputType | null
    _min: TitulopropriedadeMinAggregateOutputType | null
    _max: TitulopropriedadeMaxAggregateOutputType | null
  }

  export type TitulopropriedadeAvgAggregateOutputType = {
    codTituloPropriedade: number | null
    codPessoa: number | null
    codViatura: number | null
    codFicheiroTituloPropriedade: number | null
  }

  export type TitulopropriedadeSumAggregateOutputType = {
    codTituloPropriedade: number | null
    codPessoa: number | null
    codViatura: number | null
    codFicheiroTituloPropriedade: number | null
  }

  export type TitulopropriedadeMinAggregateOutputType = {
    codTituloPropriedade: number | null
    codPessoa: number | null
    dataEmissao: Date | null
    dataPrimeiroRegistro: Date | null
    numeroEmissao: string | null
    codViatura: number | null
    codFicheiroTituloPropriedade: number | null
  }

  export type TitulopropriedadeMaxAggregateOutputType = {
    codTituloPropriedade: number | null
    codPessoa: number | null
    dataEmissao: Date | null
    dataPrimeiroRegistro: Date | null
    numeroEmissao: string | null
    codViatura: number | null
    codFicheiroTituloPropriedade: number | null
  }

  export type TitulopropriedadeCountAggregateOutputType = {
    codTituloPropriedade: number
    codPessoa: number
    dataEmissao: number
    dataPrimeiroRegistro: number
    numeroEmissao: number
    codViatura: number
    codFicheiroTituloPropriedade: number
    _all: number
  }


  export type TitulopropriedadeAvgAggregateInputType = {
    codTituloPropriedade?: true
    codPessoa?: true
    codViatura?: true
    codFicheiroTituloPropriedade?: true
  }

  export type TitulopropriedadeSumAggregateInputType = {
    codTituloPropriedade?: true
    codPessoa?: true
    codViatura?: true
    codFicheiroTituloPropriedade?: true
  }

  export type TitulopropriedadeMinAggregateInputType = {
    codTituloPropriedade?: true
    codPessoa?: true
    dataEmissao?: true
    dataPrimeiroRegistro?: true
    numeroEmissao?: true
    codViatura?: true
    codFicheiroTituloPropriedade?: true
  }

  export type TitulopropriedadeMaxAggregateInputType = {
    codTituloPropriedade?: true
    codPessoa?: true
    dataEmissao?: true
    dataPrimeiroRegistro?: true
    numeroEmissao?: true
    codViatura?: true
    codFicheiroTituloPropriedade?: true
  }

  export type TitulopropriedadeCountAggregateInputType = {
    codTituloPropriedade?: true
    codPessoa?: true
    dataEmissao?: true
    dataPrimeiroRegistro?: true
    numeroEmissao?: true
    codViatura?: true
    codFicheiroTituloPropriedade?: true
    _all?: true
  }

  export type TitulopropriedadeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which titulopropriedade to aggregate.
     */
    where?: titulopropriedadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulopropriedades to fetch.
     */
    orderBy?: titulopropriedadeOrderByWithRelationInput | titulopropriedadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: titulopropriedadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulopropriedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulopropriedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned titulopropriedades
    **/
    _count?: true | TitulopropriedadeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TitulopropriedadeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TitulopropriedadeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TitulopropriedadeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TitulopropriedadeMaxAggregateInputType
  }

  export type GetTitulopropriedadeAggregateType<T extends TitulopropriedadeAggregateArgs> = {
        [P in keyof T & keyof AggregateTitulopropriedade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTitulopropriedade[P]>
      : GetScalarType<T[P], AggregateTitulopropriedade[P]>
  }




  export type titulopropriedadeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: titulopropriedadeWhereInput
    orderBy?: titulopropriedadeOrderByWithAggregationInput | titulopropriedadeOrderByWithAggregationInput[]
    by: TitulopropriedadeScalarFieldEnum[] | TitulopropriedadeScalarFieldEnum
    having?: titulopropriedadeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TitulopropriedadeCountAggregateInputType | true
    _avg?: TitulopropriedadeAvgAggregateInputType
    _sum?: TitulopropriedadeSumAggregateInputType
    _min?: TitulopropriedadeMinAggregateInputType
    _max?: TitulopropriedadeMaxAggregateInputType
  }

  export type TitulopropriedadeGroupByOutputType = {
    codTituloPropriedade: number
    codPessoa: number
    dataEmissao: Date
    dataPrimeiroRegistro: Date
    numeroEmissao: string
    codViatura: number
    codFicheiroTituloPropriedade: number
    _count: TitulopropriedadeCountAggregateOutputType | null
    _avg: TitulopropriedadeAvgAggregateOutputType | null
    _sum: TitulopropriedadeSumAggregateOutputType | null
    _min: TitulopropriedadeMinAggregateOutputType | null
    _max: TitulopropriedadeMaxAggregateOutputType | null
  }

  type GetTitulopropriedadeGroupByPayload<T extends titulopropriedadeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TitulopropriedadeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TitulopropriedadeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TitulopropriedadeGroupByOutputType[P]>
            : GetScalarType<T[P], TitulopropriedadeGroupByOutputType[P]>
        }
      >
    >


  export type titulopropriedadeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codTituloPropriedade?: boolean
    codPessoa?: boolean
    dataEmissao?: boolean
    dataPrimeiroRegistro?: boolean
    numeroEmissao?: boolean
    codViatura?: boolean
    codFicheiroTituloPropriedade?: boolean
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    viatura?: boolean | viaturaDefaultArgs<ExtArgs>
    ficheiro?: boolean | ficheiroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["titulopropriedade"]>


  export type titulopropriedadeSelectScalar = {
    codTituloPropriedade?: boolean
    codPessoa?: boolean
    dataEmissao?: boolean
    dataPrimeiroRegistro?: boolean
    numeroEmissao?: boolean
    codViatura?: boolean
    codFicheiroTituloPropriedade?: boolean
  }

  export type titulopropriedadeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    viatura?: boolean | viaturaDefaultArgs<ExtArgs>
    ficheiro?: boolean | ficheiroDefaultArgs<ExtArgs>
  }

  export type $titulopropriedadePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "titulopropriedade"
    objects: {
      pessoa: Prisma.$pessoaPayload<ExtArgs>
      viatura: Prisma.$viaturaPayload<ExtArgs>
      ficheiro: Prisma.$ficheiroPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      codTituloPropriedade: number
      codPessoa: number
      dataEmissao: Date
      dataPrimeiroRegistro: Date
      numeroEmissao: string
      codViatura: number
      codFicheiroTituloPropriedade: number
    }, ExtArgs["result"]["titulopropriedade"]>
    composites: {}
  }

  type titulopropriedadeGetPayload<S extends boolean | null | undefined | titulopropriedadeDefaultArgs> = $Result.GetResult<Prisma.$titulopropriedadePayload, S>

  type titulopropriedadeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<titulopropriedadeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TitulopropriedadeCountAggregateInputType | true
    }

  export interface titulopropriedadeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['titulopropriedade'], meta: { name: 'titulopropriedade' } }
    /**
     * Find zero or one Titulopropriedade that matches the filter.
     * @param {titulopropriedadeFindUniqueArgs} args - Arguments to find a Titulopropriedade
     * @example
     * // Get one Titulopropriedade
     * const titulopropriedade = await prisma.titulopropriedade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends titulopropriedadeFindUniqueArgs>(args: SelectSubset<T, titulopropriedadeFindUniqueArgs<ExtArgs>>): Prisma__titulopropriedadeClient<$Result.GetResult<Prisma.$titulopropriedadePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Titulopropriedade that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {titulopropriedadeFindUniqueOrThrowArgs} args - Arguments to find a Titulopropriedade
     * @example
     * // Get one Titulopropriedade
     * const titulopropriedade = await prisma.titulopropriedade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends titulopropriedadeFindUniqueOrThrowArgs>(args: SelectSubset<T, titulopropriedadeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__titulopropriedadeClient<$Result.GetResult<Prisma.$titulopropriedadePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Titulopropriedade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulopropriedadeFindFirstArgs} args - Arguments to find a Titulopropriedade
     * @example
     * // Get one Titulopropriedade
     * const titulopropriedade = await prisma.titulopropriedade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends titulopropriedadeFindFirstArgs>(args?: SelectSubset<T, titulopropriedadeFindFirstArgs<ExtArgs>>): Prisma__titulopropriedadeClient<$Result.GetResult<Prisma.$titulopropriedadePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Titulopropriedade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulopropriedadeFindFirstOrThrowArgs} args - Arguments to find a Titulopropriedade
     * @example
     * // Get one Titulopropriedade
     * const titulopropriedade = await prisma.titulopropriedade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends titulopropriedadeFindFirstOrThrowArgs>(args?: SelectSubset<T, titulopropriedadeFindFirstOrThrowArgs<ExtArgs>>): Prisma__titulopropriedadeClient<$Result.GetResult<Prisma.$titulopropriedadePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Titulopropriedades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulopropriedadeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Titulopropriedades
     * const titulopropriedades = await prisma.titulopropriedade.findMany()
     * 
     * // Get first 10 Titulopropriedades
     * const titulopropriedades = await prisma.titulopropriedade.findMany({ take: 10 })
     * 
     * // Only select the `codTituloPropriedade`
     * const titulopropriedadeWithCodTituloPropriedadeOnly = await prisma.titulopropriedade.findMany({ select: { codTituloPropriedade: true } })
     * 
     */
    findMany<T extends titulopropriedadeFindManyArgs>(args?: SelectSubset<T, titulopropriedadeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$titulopropriedadePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Titulopropriedade.
     * @param {titulopropriedadeCreateArgs} args - Arguments to create a Titulopropriedade.
     * @example
     * // Create one Titulopropriedade
     * const Titulopropriedade = await prisma.titulopropriedade.create({
     *   data: {
     *     // ... data to create a Titulopropriedade
     *   }
     * })
     * 
     */
    create<T extends titulopropriedadeCreateArgs>(args: SelectSubset<T, titulopropriedadeCreateArgs<ExtArgs>>): Prisma__titulopropriedadeClient<$Result.GetResult<Prisma.$titulopropriedadePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Titulopropriedades.
     * @param {titulopropriedadeCreateManyArgs} args - Arguments to create many Titulopropriedades.
     * @example
     * // Create many Titulopropriedades
     * const titulopropriedade = await prisma.titulopropriedade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends titulopropriedadeCreateManyArgs>(args?: SelectSubset<T, titulopropriedadeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Titulopropriedade.
     * @param {titulopropriedadeDeleteArgs} args - Arguments to delete one Titulopropriedade.
     * @example
     * // Delete one Titulopropriedade
     * const Titulopropriedade = await prisma.titulopropriedade.delete({
     *   where: {
     *     // ... filter to delete one Titulopropriedade
     *   }
     * })
     * 
     */
    delete<T extends titulopropriedadeDeleteArgs>(args: SelectSubset<T, titulopropriedadeDeleteArgs<ExtArgs>>): Prisma__titulopropriedadeClient<$Result.GetResult<Prisma.$titulopropriedadePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Titulopropriedade.
     * @param {titulopropriedadeUpdateArgs} args - Arguments to update one Titulopropriedade.
     * @example
     * // Update one Titulopropriedade
     * const titulopropriedade = await prisma.titulopropriedade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends titulopropriedadeUpdateArgs>(args: SelectSubset<T, titulopropriedadeUpdateArgs<ExtArgs>>): Prisma__titulopropriedadeClient<$Result.GetResult<Prisma.$titulopropriedadePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Titulopropriedades.
     * @param {titulopropriedadeDeleteManyArgs} args - Arguments to filter Titulopropriedades to delete.
     * @example
     * // Delete a few Titulopropriedades
     * const { count } = await prisma.titulopropriedade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends titulopropriedadeDeleteManyArgs>(args?: SelectSubset<T, titulopropriedadeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Titulopropriedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulopropriedadeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Titulopropriedades
     * const titulopropriedade = await prisma.titulopropriedade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends titulopropriedadeUpdateManyArgs>(args: SelectSubset<T, titulopropriedadeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Titulopropriedade.
     * @param {titulopropriedadeUpsertArgs} args - Arguments to update or create a Titulopropriedade.
     * @example
     * // Update or create a Titulopropriedade
     * const titulopropriedade = await prisma.titulopropriedade.upsert({
     *   create: {
     *     // ... data to create a Titulopropriedade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Titulopropriedade we want to update
     *   }
     * })
     */
    upsert<T extends titulopropriedadeUpsertArgs>(args: SelectSubset<T, titulopropriedadeUpsertArgs<ExtArgs>>): Prisma__titulopropriedadeClient<$Result.GetResult<Prisma.$titulopropriedadePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Titulopropriedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulopropriedadeCountArgs} args - Arguments to filter Titulopropriedades to count.
     * @example
     * // Count the number of Titulopropriedades
     * const count = await prisma.titulopropriedade.count({
     *   where: {
     *     // ... the filter for the Titulopropriedades we want to count
     *   }
     * })
    **/
    count<T extends titulopropriedadeCountArgs>(
      args?: Subset<T, titulopropriedadeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TitulopropriedadeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Titulopropriedade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TitulopropriedadeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TitulopropriedadeAggregateArgs>(args: Subset<T, TitulopropriedadeAggregateArgs>): Prisma.PrismaPromise<GetTitulopropriedadeAggregateType<T>>

    /**
     * Group by Titulopropriedade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulopropriedadeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends titulopropriedadeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: titulopropriedadeGroupByArgs['orderBy'] }
        : { orderBy?: titulopropriedadeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, titulopropriedadeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTitulopropriedadeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the titulopropriedade model
   */
  readonly fields: titulopropriedadeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for titulopropriedade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__titulopropriedadeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoa<T extends pessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pessoaDefaultArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    viatura<T extends viaturaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, viaturaDefaultArgs<ExtArgs>>): Prisma__viaturaClient<$Result.GetResult<Prisma.$viaturaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ficheiro<T extends ficheiroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ficheiroDefaultArgs<ExtArgs>>): Prisma__ficheiroClient<$Result.GetResult<Prisma.$ficheiroPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the titulopropriedade model
   */ 
  interface titulopropriedadeFieldRefs {
    readonly codTituloPropriedade: FieldRef<"titulopropriedade", 'Int'>
    readonly codPessoa: FieldRef<"titulopropriedade", 'Int'>
    readonly dataEmissao: FieldRef<"titulopropriedade", 'DateTime'>
    readonly dataPrimeiroRegistro: FieldRef<"titulopropriedade", 'DateTime'>
    readonly numeroEmissao: FieldRef<"titulopropriedade", 'String'>
    readonly codViatura: FieldRef<"titulopropriedade", 'Int'>
    readonly codFicheiroTituloPropriedade: FieldRef<"titulopropriedade", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * titulopropriedade findUnique
   */
  export type titulopropriedadeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the titulopropriedade
     */
    select?: titulopropriedadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: titulopropriedadeInclude<ExtArgs> | null
    /**
     * Filter, which titulopropriedade to fetch.
     */
    where: titulopropriedadeWhereUniqueInput
  }

  /**
   * titulopropriedade findUniqueOrThrow
   */
  export type titulopropriedadeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the titulopropriedade
     */
    select?: titulopropriedadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: titulopropriedadeInclude<ExtArgs> | null
    /**
     * Filter, which titulopropriedade to fetch.
     */
    where: titulopropriedadeWhereUniqueInput
  }

  /**
   * titulopropriedade findFirst
   */
  export type titulopropriedadeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the titulopropriedade
     */
    select?: titulopropriedadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: titulopropriedadeInclude<ExtArgs> | null
    /**
     * Filter, which titulopropriedade to fetch.
     */
    where?: titulopropriedadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulopropriedades to fetch.
     */
    orderBy?: titulopropriedadeOrderByWithRelationInput | titulopropriedadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for titulopropriedades.
     */
    cursor?: titulopropriedadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulopropriedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulopropriedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of titulopropriedades.
     */
    distinct?: TitulopropriedadeScalarFieldEnum | TitulopropriedadeScalarFieldEnum[]
  }

  /**
   * titulopropriedade findFirstOrThrow
   */
  export type titulopropriedadeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the titulopropriedade
     */
    select?: titulopropriedadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: titulopropriedadeInclude<ExtArgs> | null
    /**
     * Filter, which titulopropriedade to fetch.
     */
    where?: titulopropriedadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulopropriedades to fetch.
     */
    orderBy?: titulopropriedadeOrderByWithRelationInput | titulopropriedadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for titulopropriedades.
     */
    cursor?: titulopropriedadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulopropriedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulopropriedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of titulopropriedades.
     */
    distinct?: TitulopropriedadeScalarFieldEnum | TitulopropriedadeScalarFieldEnum[]
  }

  /**
   * titulopropriedade findMany
   */
  export type titulopropriedadeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the titulopropriedade
     */
    select?: titulopropriedadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: titulopropriedadeInclude<ExtArgs> | null
    /**
     * Filter, which titulopropriedades to fetch.
     */
    where?: titulopropriedadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulopropriedades to fetch.
     */
    orderBy?: titulopropriedadeOrderByWithRelationInput | titulopropriedadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing titulopropriedades.
     */
    cursor?: titulopropriedadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulopropriedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulopropriedades.
     */
    skip?: number
    distinct?: TitulopropriedadeScalarFieldEnum | TitulopropriedadeScalarFieldEnum[]
  }

  /**
   * titulopropriedade create
   */
  export type titulopropriedadeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the titulopropriedade
     */
    select?: titulopropriedadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: titulopropriedadeInclude<ExtArgs> | null
    /**
     * The data needed to create a titulopropriedade.
     */
    data: XOR<titulopropriedadeCreateInput, titulopropriedadeUncheckedCreateInput>
  }

  /**
   * titulopropriedade createMany
   */
  export type titulopropriedadeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many titulopropriedades.
     */
    data: titulopropriedadeCreateManyInput | titulopropriedadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * titulopropriedade update
   */
  export type titulopropriedadeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the titulopropriedade
     */
    select?: titulopropriedadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: titulopropriedadeInclude<ExtArgs> | null
    /**
     * The data needed to update a titulopropriedade.
     */
    data: XOR<titulopropriedadeUpdateInput, titulopropriedadeUncheckedUpdateInput>
    /**
     * Choose, which titulopropriedade to update.
     */
    where: titulopropriedadeWhereUniqueInput
  }

  /**
   * titulopropriedade updateMany
   */
  export type titulopropriedadeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update titulopropriedades.
     */
    data: XOR<titulopropriedadeUpdateManyMutationInput, titulopropriedadeUncheckedUpdateManyInput>
    /**
     * Filter which titulopropriedades to update
     */
    where?: titulopropriedadeWhereInput
  }

  /**
   * titulopropriedade upsert
   */
  export type titulopropriedadeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the titulopropriedade
     */
    select?: titulopropriedadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: titulopropriedadeInclude<ExtArgs> | null
    /**
     * The filter to search for the titulopropriedade to update in case it exists.
     */
    where: titulopropriedadeWhereUniqueInput
    /**
     * In case the titulopropriedade found by the `where` argument doesn't exist, create a new titulopropriedade with this data.
     */
    create: XOR<titulopropriedadeCreateInput, titulopropriedadeUncheckedCreateInput>
    /**
     * In case the titulopropriedade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<titulopropriedadeUpdateInput, titulopropriedadeUncheckedUpdateInput>
  }

  /**
   * titulopropriedade delete
   */
  export type titulopropriedadeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the titulopropriedade
     */
    select?: titulopropriedadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: titulopropriedadeInclude<ExtArgs> | null
    /**
     * Filter which titulopropriedade to delete.
     */
    where: titulopropriedadeWhereUniqueInput
  }

  /**
   * titulopropriedade deleteMany
   */
  export type titulopropriedadeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which titulopropriedades to delete
     */
    where?: titulopropriedadeWhereInput
  }

  /**
   * titulopropriedade without action
   */
  export type titulopropriedadeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the titulopropriedade
     */
    select?: titulopropriedadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: titulopropriedadeInclude<ExtArgs> | null
  }


  /**
   * Model viatura
   */

  export type AggregateViatura = {
    _count: ViaturaCountAggregateOutputType | null
    _avg: ViaturaAvgAggregateOutputType | null
    _sum: ViaturaSumAggregateOutputType | null
    _min: ViaturaMinAggregateOutputType | null
    _max: ViaturaMaxAggregateOutputType | null
  }

  export type ViaturaAvgAggregateOutputType = {
    codViatura: number | null
  }

  export type ViaturaSumAggregateOutputType = {
    codViatura: number | null
  }

  export type ViaturaMinAggregateOutputType = {
    codViatura: number | null
    numeroMatricula: string | null
  }

  export type ViaturaMaxAggregateOutputType = {
    codViatura: number | null
    numeroMatricula: string | null
  }

  export type ViaturaCountAggregateOutputType = {
    codViatura: number
    numeroMatricula: number
    _all: number
  }


  export type ViaturaAvgAggregateInputType = {
    codViatura?: true
  }

  export type ViaturaSumAggregateInputType = {
    codViatura?: true
  }

  export type ViaturaMinAggregateInputType = {
    codViatura?: true
    numeroMatricula?: true
  }

  export type ViaturaMaxAggregateInputType = {
    codViatura?: true
    numeroMatricula?: true
  }

  export type ViaturaCountAggregateInputType = {
    codViatura?: true
    numeroMatricula?: true
    _all?: true
  }

  export type ViaturaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which viatura to aggregate.
     */
    where?: viaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viaturas to fetch.
     */
    orderBy?: viaturaOrderByWithRelationInput | viaturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: viaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viaturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viaturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned viaturas
    **/
    _count?: true | ViaturaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViaturaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViaturaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViaturaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViaturaMaxAggregateInputType
  }

  export type GetViaturaAggregateType<T extends ViaturaAggregateArgs> = {
        [P in keyof T & keyof AggregateViatura]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViatura[P]>
      : GetScalarType<T[P], AggregateViatura[P]>
  }




  export type viaturaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: viaturaWhereInput
    orderBy?: viaturaOrderByWithAggregationInput | viaturaOrderByWithAggregationInput[]
    by: ViaturaScalarFieldEnum[] | ViaturaScalarFieldEnum
    having?: viaturaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViaturaCountAggregateInputType | true
    _avg?: ViaturaAvgAggregateInputType
    _sum?: ViaturaSumAggregateInputType
    _min?: ViaturaMinAggregateInputType
    _max?: ViaturaMaxAggregateInputType
  }

  export type ViaturaGroupByOutputType = {
    codViatura: number
    numeroMatricula: string
    _count: ViaturaCountAggregateOutputType | null
    _avg: ViaturaAvgAggregateOutputType | null
    _sum: ViaturaSumAggregateOutputType | null
    _min: ViaturaMinAggregateOutputType | null
    _max: ViaturaMaxAggregateOutputType | null
  }

  type GetViaturaGroupByPayload<T extends viaturaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViaturaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViaturaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViaturaGroupByOutputType[P]>
            : GetScalarType<T[P], ViaturaGroupByOutputType[P]>
        }
      >
    >


  export type viaturaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    codViatura?: boolean
    numeroMatricula?: boolean
    alertaroubo?: boolean | viatura$alertarouboArgs<ExtArgs>
    livrete?: boolean | viatura$livreteArgs<ExtArgs>
    multa?: boolean | viatura$multaArgs<ExtArgs>
    titulopropriedade?: boolean | viatura$titulopropriedadeArgs<ExtArgs>
    _count?: boolean | ViaturaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viatura"]>


  export type viaturaSelectScalar = {
    codViatura?: boolean
    numeroMatricula?: boolean
  }

  export type viaturaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alertaroubo?: boolean | viatura$alertarouboArgs<ExtArgs>
    livrete?: boolean | viatura$livreteArgs<ExtArgs>
    multa?: boolean | viatura$multaArgs<ExtArgs>
    titulopropriedade?: boolean | viatura$titulopropriedadeArgs<ExtArgs>
    _count?: boolean | ViaturaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $viaturaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "viatura"
    objects: {
      alertaroubo: Prisma.$alertarouboPayload<ExtArgs>[]
      livrete: Prisma.$livretePayload<ExtArgs>[]
      multa: Prisma.$multaPayload<ExtArgs>[]
      titulopropriedade: Prisma.$titulopropriedadePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      codViatura: number
      numeroMatricula: string
    }, ExtArgs["result"]["viatura"]>
    composites: {}
  }

  type viaturaGetPayload<S extends boolean | null | undefined | viaturaDefaultArgs> = $Result.GetResult<Prisma.$viaturaPayload, S>

  type viaturaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<viaturaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ViaturaCountAggregateInputType | true
    }

  export interface viaturaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['viatura'], meta: { name: 'viatura' } }
    /**
     * Find zero or one Viatura that matches the filter.
     * @param {viaturaFindUniqueArgs} args - Arguments to find a Viatura
     * @example
     * // Get one Viatura
     * const viatura = await prisma.viatura.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends viaturaFindUniqueArgs>(args: SelectSubset<T, viaturaFindUniqueArgs<ExtArgs>>): Prisma__viaturaClient<$Result.GetResult<Prisma.$viaturaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Viatura that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {viaturaFindUniqueOrThrowArgs} args - Arguments to find a Viatura
     * @example
     * // Get one Viatura
     * const viatura = await prisma.viatura.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends viaturaFindUniqueOrThrowArgs>(args: SelectSubset<T, viaturaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__viaturaClient<$Result.GetResult<Prisma.$viaturaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Viatura that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viaturaFindFirstArgs} args - Arguments to find a Viatura
     * @example
     * // Get one Viatura
     * const viatura = await prisma.viatura.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends viaturaFindFirstArgs>(args?: SelectSubset<T, viaturaFindFirstArgs<ExtArgs>>): Prisma__viaturaClient<$Result.GetResult<Prisma.$viaturaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Viatura that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viaturaFindFirstOrThrowArgs} args - Arguments to find a Viatura
     * @example
     * // Get one Viatura
     * const viatura = await prisma.viatura.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends viaturaFindFirstOrThrowArgs>(args?: SelectSubset<T, viaturaFindFirstOrThrowArgs<ExtArgs>>): Prisma__viaturaClient<$Result.GetResult<Prisma.$viaturaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Viaturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viaturaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Viaturas
     * const viaturas = await prisma.viatura.findMany()
     * 
     * // Get first 10 Viaturas
     * const viaturas = await prisma.viatura.findMany({ take: 10 })
     * 
     * // Only select the `codViatura`
     * const viaturaWithCodViaturaOnly = await prisma.viatura.findMany({ select: { codViatura: true } })
     * 
     */
    findMany<T extends viaturaFindManyArgs>(args?: SelectSubset<T, viaturaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$viaturaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Viatura.
     * @param {viaturaCreateArgs} args - Arguments to create a Viatura.
     * @example
     * // Create one Viatura
     * const Viatura = await prisma.viatura.create({
     *   data: {
     *     // ... data to create a Viatura
     *   }
     * })
     * 
     */
    create<T extends viaturaCreateArgs>(args: SelectSubset<T, viaturaCreateArgs<ExtArgs>>): Prisma__viaturaClient<$Result.GetResult<Prisma.$viaturaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Viaturas.
     * @param {viaturaCreateManyArgs} args - Arguments to create many Viaturas.
     * @example
     * // Create many Viaturas
     * const viatura = await prisma.viatura.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends viaturaCreateManyArgs>(args?: SelectSubset<T, viaturaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Viatura.
     * @param {viaturaDeleteArgs} args - Arguments to delete one Viatura.
     * @example
     * // Delete one Viatura
     * const Viatura = await prisma.viatura.delete({
     *   where: {
     *     // ... filter to delete one Viatura
     *   }
     * })
     * 
     */
    delete<T extends viaturaDeleteArgs>(args: SelectSubset<T, viaturaDeleteArgs<ExtArgs>>): Prisma__viaturaClient<$Result.GetResult<Prisma.$viaturaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Viatura.
     * @param {viaturaUpdateArgs} args - Arguments to update one Viatura.
     * @example
     * // Update one Viatura
     * const viatura = await prisma.viatura.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends viaturaUpdateArgs>(args: SelectSubset<T, viaturaUpdateArgs<ExtArgs>>): Prisma__viaturaClient<$Result.GetResult<Prisma.$viaturaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Viaturas.
     * @param {viaturaDeleteManyArgs} args - Arguments to filter Viaturas to delete.
     * @example
     * // Delete a few Viaturas
     * const { count } = await prisma.viatura.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends viaturaDeleteManyArgs>(args?: SelectSubset<T, viaturaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Viaturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viaturaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Viaturas
     * const viatura = await prisma.viatura.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends viaturaUpdateManyArgs>(args: SelectSubset<T, viaturaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Viatura.
     * @param {viaturaUpsertArgs} args - Arguments to update or create a Viatura.
     * @example
     * // Update or create a Viatura
     * const viatura = await prisma.viatura.upsert({
     *   create: {
     *     // ... data to create a Viatura
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Viatura we want to update
     *   }
     * })
     */
    upsert<T extends viaturaUpsertArgs>(args: SelectSubset<T, viaturaUpsertArgs<ExtArgs>>): Prisma__viaturaClient<$Result.GetResult<Prisma.$viaturaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Viaturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viaturaCountArgs} args - Arguments to filter Viaturas to count.
     * @example
     * // Count the number of Viaturas
     * const count = await prisma.viatura.count({
     *   where: {
     *     // ... the filter for the Viaturas we want to count
     *   }
     * })
    **/
    count<T extends viaturaCountArgs>(
      args?: Subset<T, viaturaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViaturaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Viatura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViaturaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViaturaAggregateArgs>(args: Subset<T, ViaturaAggregateArgs>): Prisma.PrismaPromise<GetViaturaAggregateType<T>>

    /**
     * Group by Viatura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {viaturaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends viaturaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: viaturaGroupByArgs['orderBy'] }
        : { orderBy?: viaturaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, viaturaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViaturaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the viatura model
   */
  readonly fields: viaturaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for viatura.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__viaturaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alertaroubo<T extends viatura$alertarouboArgs<ExtArgs> = {}>(args?: Subset<T, viatura$alertarouboArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alertarouboPayload<ExtArgs>, T, "findMany"> | Null>
    livrete<T extends viatura$livreteArgs<ExtArgs> = {}>(args?: Subset<T, viatura$livreteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$livretePayload<ExtArgs>, T, "findMany"> | Null>
    multa<T extends viatura$multaArgs<ExtArgs> = {}>(args?: Subset<T, viatura$multaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$multaPayload<ExtArgs>, T, "findMany"> | Null>
    titulopropriedade<T extends viatura$titulopropriedadeArgs<ExtArgs> = {}>(args?: Subset<T, viatura$titulopropriedadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$titulopropriedadePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the viatura model
   */ 
  interface viaturaFieldRefs {
    readonly codViatura: FieldRef<"viatura", 'Int'>
    readonly numeroMatricula: FieldRef<"viatura", 'String'>
  }
    

  // Custom InputTypes
  /**
   * viatura findUnique
   */
  export type viaturaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viatura
     */
    select?: viaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viaturaInclude<ExtArgs> | null
    /**
     * Filter, which viatura to fetch.
     */
    where: viaturaWhereUniqueInput
  }

  /**
   * viatura findUniqueOrThrow
   */
  export type viaturaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viatura
     */
    select?: viaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viaturaInclude<ExtArgs> | null
    /**
     * Filter, which viatura to fetch.
     */
    where: viaturaWhereUniqueInput
  }

  /**
   * viatura findFirst
   */
  export type viaturaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viatura
     */
    select?: viaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viaturaInclude<ExtArgs> | null
    /**
     * Filter, which viatura to fetch.
     */
    where?: viaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viaturas to fetch.
     */
    orderBy?: viaturaOrderByWithRelationInput | viaturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for viaturas.
     */
    cursor?: viaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viaturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viaturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of viaturas.
     */
    distinct?: ViaturaScalarFieldEnum | ViaturaScalarFieldEnum[]
  }

  /**
   * viatura findFirstOrThrow
   */
  export type viaturaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viatura
     */
    select?: viaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viaturaInclude<ExtArgs> | null
    /**
     * Filter, which viatura to fetch.
     */
    where?: viaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viaturas to fetch.
     */
    orderBy?: viaturaOrderByWithRelationInput | viaturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for viaturas.
     */
    cursor?: viaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viaturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viaturas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of viaturas.
     */
    distinct?: ViaturaScalarFieldEnum | ViaturaScalarFieldEnum[]
  }

  /**
   * viatura findMany
   */
  export type viaturaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viatura
     */
    select?: viaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viaturaInclude<ExtArgs> | null
    /**
     * Filter, which viaturas to fetch.
     */
    where?: viaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of viaturas to fetch.
     */
    orderBy?: viaturaOrderByWithRelationInput | viaturaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing viaturas.
     */
    cursor?: viaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` viaturas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` viaturas.
     */
    skip?: number
    distinct?: ViaturaScalarFieldEnum | ViaturaScalarFieldEnum[]
  }

  /**
   * viatura create
   */
  export type viaturaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viatura
     */
    select?: viaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viaturaInclude<ExtArgs> | null
    /**
     * The data needed to create a viatura.
     */
    data: XOR<viaturaCreateInput, viaturaUncheckedCreateInput>
  }

  /**
   * viatura createMany
   */
  export type viaturaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many viaturas.
     */
    data: viaturaCreateManyInput | viaturaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * viatura update
   */
  export type viaturaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viatura
     */
    select?: viaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viaturaInclude<ExtArgs> | null
    /**
     * The data needed to update a viatura.
     */
    data: XOR<viaturaUpdateInput, viaturaUncheckedUpdateInput>
    /**
     * Choose, which viatura to update.
     */
    where: viaturaWhereUniqueInput
  }

  /**
   * viatura updateMany
   */
  export type viaturaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update viaturas.
     */
    data: XOR<viaturaUpdateManyMutationInput, viaturaUncheckedUpdateManyInput>
    /**
     * Filter which viaturas to update
     */
    where?: viaturaWhereInput
  }

  /**
   * viatura upsert
   */
  export type viaturaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viatura
     */
    select?: viaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viaturaInclude<ExtArgs> | null
    /**
     * The filter to search for the viatura to update in case it exists.
     */
    where: viaturaWhereUniqueInput
    /**
     * In case the viatura found by the `where` argument doesn't exist, create a new viatura with this data.
     */
    create: XOR<viaturaCreateInput, viaturaUncheckedCreateInput>
    /**
     * In case the viatura was found with the provided `where` argument, update it with this data.
     */
    update: XOR<viaturaUpdateInput, viaturaUncheckedUpdateInput>
  }

  /**
   * viatura delete
   */
  export type viaturaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viatura
     */
    select?: viaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viaturaInclude<ExtArgs> | null
    /**
     * Filter which viatura to delete.
     */
    where: viaturaWhereUniqueInput
  }

  /**
   * viatura deleteMany
   */
  export type viaturaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which viaturas to delete
     */
    where?: viaturaWhereInput
  }

  /**
   * viatura.alertaroubo
   */
  export type viatura$alertarouboArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alertaroubo
     */
    select?: alertarouboSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertarouboInclude<ExtArgs> | null
    where?: alertarouboWhereInput
    orderBy?: alertarouboOrderByWithRelationInput | alertarouboOrderByWithRelationInput[]
    cursor?: alertarouboWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertarouboScalarFieldEnum | AlertarouboScalarFieldEnum[]
  }

  /**
   * viatura.livrete
   */
  export type viatura$livreteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the livrete
     */
    select?: livreteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: livreteInclude<ExtArgs> | null
    where?: livreteWhereInput
    orderBy?: livreteOrderByWithRelationInput | livreteOrderByWithRelationInput[]
    cursor?: livreteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LivreteScalarFieldEnum | LivreteScalarFieldEnum[]
  }

  /**
   * viatura.multa
   */
  export type viatura$multaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the multa
     */
    select?: multaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: multaInclude<ExtArgs> | null
    where?: multaWhereInput
    orderBy?: multaOrderByWithRelationInput | multaOrderByWithRelationInput[]
    cursor?: multaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MultaScalarFieldEnum | MultaScalarFieldEnum[]
  }

  /**
   * viatura.titulopropriedade
   */
  export type viatura$titulopropriedadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the titulopropriedade
     */
    select?: titulopropriedadeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: titulopropriedadeInclude<ExtArgs> | null
    where?: titulopropriedadeWhereInput
    orderBy?: titulopropriedadeOrderByWithRelationInput | titulopropriedadeOrderByWithRelationInput[]
    cursor?: titulopropriedadeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TitulopropriedadeScalarFieldEnum | TitulopropriedadeScalarFieldEnum[]
  }

  /**
   * viatura without action
   */
  export type viaturaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the viatura
     */
    select?: viaturaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: viaturaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AlertarouboScalarFieldEnum: {
    codAlertaRoubo: 'codAlertaRoubo',
    codAutomobilista: 'codAutomobilista',
    codViatura: 'codViatura',
    dataRoubo: 'dataRoubo',
    enderecoRoubo: 'enderecoRoubo',
    codTipoRoubo: 'codTipoRoubo',
    descRoubo: 'descRoubo'
  };

  export type AlertarouboScalarFieldEnum = (typeof AlertarouboScalarFieldEnum)[keyof typeof AlertarouboScalarFieldEnum]


  export const AutomobilistaScalarFieldEnum: {
    codAutomobilista: 'codAutomobilista',
    codCartaConducao: 'codCartaConducao',
    codPessoa: 'codPessoa'
  };

  export type AutomobilistaScalarFieldEnum = (typeof AutomobilistaScalarFieldEnum)[keyof typeof AutomobilistaScalarFieldEnum]


  export const BiScalarFieldEnum: {
    idBi: 'idBi',
    dataEmicaoBi: 'dataEmicaoBi',
    dataValidacaoBi: 'dataValidacaoBi',
    numeroBI: 'numeroBI',
    codFicheiroBi: 'codFicheiroBi'
  };

  export type BiScalarFieldEnum = (typeof BiScalarFieldEnum)[keyof typeof BiScalarFieldEnum]


  export const CartaconducaoScalarFieldEnum: {
    codCartaConducao: 'codCartaConducao',
    dataEmissao: 'dataEmissao',
    dataValidade: 'dataValidade',
    numeroVia: 'numeroVia',
    codCategoriaCarta: 'codCategoriaCarta',
    numeroCarta: 'numeroCarta',
    dataPrimeiraEmissao: 'dataPrimeiraEmissao',
    localEmissao: 'localEmissao',
    codFicheiroCartaConducao: 'codFicheiroCartaConducao'
  };

  export type CartaconducaoScalarFieldEnum = (typeof CartaconducaoScalarFieldEnum)[keyof typeof CartaconducaoScalarFieldEnum]


  export const CategoriacartaScalarFieldEnum: {
    codCategoriaCarta: 'codCategoriaCarta',
    descCategoriaCarta: 'descCategoriaCarta',
    sigla: 'sigla'
  };

  export type CategoriacartaScalarFieldEnum = (typeof CategoriacartaScalarFieldEnum)[keyof typeof CategoriacartaScalarFieldEnum]


  export const ContactoScalarFieldEnum: {
    idContacto: 'idContacto',
    contacto1: 'contacto1',
    contacto2: 'contacto2',
    email1: 'email1',
    email2: 'email2'
  };

  export type ContactoScalarFieldEnum = (typeof ContactoScalarFieldEnum)[keyof typeof ContactoScalarFieldEnum]


  export const EnderecoScalarFieldEnum: {
    idEndereco: 'idEndereco',
    idMunicipio: 'idMunicipio',
    descricaoEndereco: 'descricaoEndereco'
  };

  export type EnderecoScalarFieldEnum = (typeof EnderecoScalarFieldEnum)[keyof typeof EnderecoScalarFieldEnum]


  export const FicheiroScalarFieldEnum: {
    idFicheiro: 'idFicheiro',
    nomeFicheiro: 'nomeFicheiro',
    dataEntrada: 'dataEntrada',
    dataValidacao: 'dataValidacao',
    estadoValidacao: 'estadoValidacao'
  };

  export type FicheiroScalarFieldEnum = (typeof FicheiroScalarFieldEnum)[keyof typeof FicheiroScalarFieldEnum]


  export const FuncionarioScalarFieldEnum: {
    codFuncionario: 'codFuncionario',
    codPessoa: 'codPessoa',
    codficheiroFotoPerfil: 'codficheiroFotoPerfil',
    codficheiroFotoPendente: 'codficheiroFotoPendente',
    numeroAgente: 'numeroAgente',
    senha: 'senha'
  };

  export type FuncionarioScalarFieldEnum = (typeof FuncionarioScalarFieldEnum)[keyof typeof FuncionarioScalarFieldEnum]


  export const InfracaoScalarFieldEnum: {
    codInfracao: 'codInfracao',
    codMulta: 'codMulta',
    codTipoInfracao: 'codTipoInfracao'
  };

  export type InfracaoScalarFieldEnum = (typeof InfracaoScalarFieldEnum)[keyof typeof InfracaoScalarFieldEnum]


  export const LivreteScalarFieldEnum: {
    codLivrete: 'codLivrete',
    codViatura: 'codViatura',
    numeroQuadro: 'numeroQuadro',
    corViatura: 'corViatura',
    MedidasPneumaticos: 'MedidasPneumaticos',
    codServico: 'codServico',
    dataEmissao: 'dataEmissao',
    dataPrimeiroRegistro: 'dataPrimeiroRegistro',
    lotacao: 'lotacao',
    cilindrada: 'cilindrada',
    numeroCilindro: 'numeroCilindro',
    conbustivel: 'conbustivel',
    peso: 'peso',
    tara: 'tara',
    tipoCaixa: 'tipoCaixa',
    distanciaEixo: 'distanciaEixo',
    modelo: 'modelo',
    codMarca: 'codMarca'
  };

  export type LivreteScalarFieldEnum = (typeof LivreteScalarFieldEnum)[keyof typeof LivreteScalarFieldEnum]


  export const MarcaScalarFieldEnum: {
    codMarca: 'codMarca',
    descMarca: 'descMarca'
  };

  export type MarcaScalarFieldEnum = (typeof MarcaScalarFieldEnum)[keyof typeof MarcaScalarFieldEnum]


  export const MultaScalarFieldEnum: {
    codMulta: 'codMulta',
    codAutomobilista: 'codAutomobilista',
    CodViatura: 'CodViatura',
    codInfracao: 'codInfracao',
    valorMulta: 'valorMulta',
    estadoMulta: 'estadoMulta'
  };

  export type MultaScalarFieldEnum = (typeof MultaScalarFieldEnum)[keyof typeof MultaScalarFieldEnum]


  export const MunicipioScalarFieldEnum: {
    idMunicipio: 'idMunicipio',
    idProvincia: 'idProvincia',
    municipio: 'municipio'
  };

  export type MunicipioScalarFieldEnum = (typeof MunicipioScalarFieldEnum)[keyof typeof MunicipioScalarFieldEnum]


  export const PagamentomultaScalarFieldEnum: {
    codPagamentoMulta: 'codPagamentoMulta',
    codMulta: 'codMulta',
    dataPagamento: 'dataPagamento',
    valorPago: 'valorPago',
    descCodigoDeposito: 'descCodigoDeposito',
    codFicheiroPagamento: 'codFicheiroPagamento'
  };

  export type PagamentomultaScalarFieldEnum = (typeof PagamentomultaScalarFieldEnum)[keyof typeof PagamentomultaScalarFieldEnum]


  export const PaisScalarFieldEnum: {
    idPais: 'idPais',
    pais: 'pais'
  };

  export type PaisScalarFieldEnum = (typeof PaisScalarFieldEnum)[keyof typeof PaisScalarFieldEnum]


  export const PessoaScalarFieldEnum: {
    codPessoa: 'codPessoa',
    codEndereco: 'codEndereco',
    codNacionalidade: 'codNacionalidade',
    codContacto: 'codContacto',
    nome: 'nome',
    genero: 'genero',
    estadoCivil: 'estadoCivil',
    dataCadastro: 'dataCadastro',
    dataNascimento: 'dataNascimento',
    codBi: 'codBi',
    senha: 'senha'
  };

  export type PessoaScalarFieldEnum = (typeof PessoaScalarFieldEnum)[keyof typeof PessoaScalarFieldEnum]


  export const ProvinciaScalarFieldEnum: {
    idProvincia: 'idProvincia',
    provincia: 'provincia'
  };

  export type ProvinciaScalarFieldEnum = (typeof ProvinciaScalarFieldEnum)[keyof typeof ProvinciaScalarFieldEnum]


  export const SerivicoviaturaScalarFieldEnum: {
    codServicoViatura: 'codServicoViatura',
    descServico: 'descServico'
  };

  export type SerivicoviaturaScalarFieldEnum = (typeof SerivicoviaturaScalarFieldEnum)[keyof typeof SerivicoviaturaScalarFieldEnum]


  export const TipoinfracaoScalarFieldEnum: {
    codTipoInfracao: 'codTipoInfracao',
    descTipoInfracao: 'descTipoInfracao',
    valorInfracao: 'valorInfracao'
  };

  export type TipoinfracaoScalarFieldEnum = (typeof TipoinfracaoScalarFieldEnum)[keyof typeof TipoinfracaoScalarFieldEnum]


  export const TiporouboScalarFieldEnum: {
    codTipoRoubo: 'codTipoRoubo',
    descTipoRoubo: 'descTipoRoubo'
  };

  export type TiporouboScalarFieldEnum = (typeof TiporouboScalarFieldEnum)[keyof typeof TiporouboScalarFieldEnum]


  export const TitulopropriedadeScalarFieldEnum: {
    codTituloPropriedade: 'codTituloPropriedade',
    codPessoa: 'codPessoa',
    dataEmissao: 'dataEmissao',
    dataPrimeiroRegistro: 'dataPrimeiroRegistro',
    numeroEmissao: 'numeroEmissao',
    codViatura: 'codViatura',
    codFicheiroTituloPropriedade: 'codFicheiroTituloPropriedade'
  };

  export type TitulopropriedadeScalarFieldEnum = (typeof TitulopropriedadeScalarFieldEnum)[keyof typeof TitulopropriedadeScalarFieldEnum]


  export const ViaturaScalarFieldEnum: {
    codViatura: 'codViatura',
    numeroMatricula: 'numeroMatricula'
  };

  export type ViaturaScalarFieldEnum = (typeof ViaturaScalarFieldEnum)[keyof typeof ViaturaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'ficheiro_estadoValidacao'
   */
  export type Enumficheiro_estadoValidacaoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ficheiro_estadoValidacao'>
    


  /**
   * Reference to a field of type 'multa_estadoMulta'
   */
  export type Enummulta_estadoMultaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'multa_estadoMulta'>
    


  /**
   * Reference to a field of type 'pessoa_genero'
   */
  export type Enumpessoa_generoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'pessoa_genero'>
    


  /**
   * Reference to a field of type 'pessoa_estadoCivil'
   */
  export type Enumpessoa_estadoCivilFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'pessoa_estadoCivil'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type alertarouboWhereInput = {
    AND?: alertarouboWhereInput | alertarouboWhereInput[]
    OR?: alertarouboWhereInput[]
    NOT?: alertarouboWhereInput | alertarouboWhereInput[]
    codAlertaRoubo?: IntFilter<"alertaroubo"> | number
    codAutomobilista?: IntFilter<"alertaroubo"> | number
    codViatura?: IntFilter<"alertaroubo"> | number
    dataRoubo?: DateTimeFilter<"alertaroubo"> | Date | string
    enderecoRoubo?: StringFilter<"alertaroubo"> | string
    codTipoRoubo?: IntFilter<"alertaroubo"> | number
    descRoubo?: StringFilter<"alertaroubo"> | string
    automobilista?: XOR<AutomobilistaRelationFilter, automobilistaWhereInput>
    tiporoubo?: XOR<TiporouboRelationFilter, tiporouboWhereInput>
    viatura?: XOR<ViaturaRelationFilter, viaturaWhereInput>
  }

  export type alertarouboOrderByWithRelationInput = {
    codAlertaRoubo?: SortOrder
    codAutomobilista?: SortOrder
    codViatura?: SortOrder
    dataRoubo?: SortOrder
    enderecoRoubo?: SortOrder
    codTipoRoubo?: SortOrder
    descRoubo?: SortOrder
    automobilista?: automobilistaOrderByWithRelationInput
    tiporoubo?: tiporouboOrderByWithRelationInput
    viatura?: viaturaOrderByWithRelationInput
  }

  export type alertarouboWhereUniqueInput = Prisma.AtLeast<{
    codAlertaRoubo?: number
    AND?: alertarouboWhereInput | alertarouboWhereInput[]
    OR?: alertarouboWhereInput[]
    NOT?: alertarouboWhereInput | alertarouboWhereInput[]
    codAutomobilista?: IntFilter<"alertaroubo"> | number
    codViatura?: IntFilter<"alertaroubo"> | number
    dataRoubo?: DateTimeFilter<"alertaroubo"> | Date | string
    enderecoRoubo?: StringFilter<"alertaroubo"> | string
    codTipoRoubo?: IntFilter<"alertaroubo"> | number
    descRoubo?: StringFilter<"alertaroubo"> | string
    automobilista?: XOR<AutomobilistaRelationFilter, automobilistaWhereInput>
    tiporoubo?: XOR<TiporouboRelationFilter, tiporouboWhereInput>
    viatura?: XOR<ViaturaRelationFilter, viaturaWhereInput>
  }, "codAlertaRoubo">

  export type alertarouboOrderByWithAggregationInput = {
    codAlertaRoubo?: SortOrder
    codAutomobilista?: SortOrder
    codViatura?: SortOrder
    dataRoubo?: SortOrder
    enderecoRoubo?: SortOrder
    codTipoRoubo?: SortOrder
    descRoubo?: SortOrder
    _count?: alertarouboCountOrderByAggregateInput
    _avg?: alertarouboAvgOrderByAggregateInput
    _max?: alertarouboMaxOrderByAggregateInput
    _min?: alertarouboMinOrderByAggregateInput
    _sum?: alertarouboSumOrderByAggregateInput
  }

  export type alertarouboScalarWhereWithAggregatesInput = {
    AND?: alertarouboScalarWhereWithAggregatesInput | alertarouboScalarWhereWithAggregatesInput[]
    OR?: alertarouboScalarWhereWithAggregatesInput[]
    NOT?: alertarouboScalarWhereWithAggregatesInput | alertarouboScalarWhereWithAggregatesInput[]
    codAlertaRoubo?: IntWithAggregatesFilter<"alertaroubo"> | number
    codAutomobilista?: IntWithAggregatesFilter<"alertaroubo"> | number
    codViatura?: IntWithAggregatesFilter<"alertaroubo"> | number
    dataRoubo?: DateTimeWithAggregatesFilter<"alertaroubo"> | Date | string
    enderecoRoubo?: StringWithAggregatesFilter<"alertaroubo"> | string
    codTipoRoubo?: IntWithAggregatesFilter<"alertaroubo"> | number
    descRoubo?: StringWithAggregatesFilter<"alertaroubo"> | string
  }

  export type automobilistaWhereInput = {
    AND?: automobilistaWhereInput | automobilistaWhereInput[]
    OR?: automobilistaWhereInput[]
    NOT?: automobilistaWhereInput | automobilistaWhereInput[]
    codAutomobilista?: IntFilter<"automobilista"> | number
    codCartaConducao?: IntFilter<"automobilista"> | number
    codPessoa?: IntFilter<"automobilista"> | number
    alertaroubo?: AlertarouboListRelationFilter
    cartaconducao?: XOR<CartaconducaoRelationFilter, cartaconducaoWhereInput>
    pessoa?: XOR<PessoaRelationFilter, pessoaWhereInput>
    multa?: MultaListRelationFilter
  }

  export type automobilistaOrderByWithRelationInput = {
    codAutomobilista?: SortOrder
    codCartaConducao?: SortOrder
    codPessoa?: SortOrder
    alertaroubo?: alertarouboOrderByRelationAggregateInput
    cartaconducao?: cartaconducaoOrderByWithRelationInput
    pessoa?: pessoaOrderByWithRelationInput
    multa?: multaOrderByRelationAggregateInput
  }

  export type automobilistaWhereUniqueInput = Prisma.AtLeast<{
    codAutomobilista?: number
    AND?: automobilistaWhereInput | automobilistaWhereInput[]
    OR?: automobilistaWhereInput[]
    NOT?: automobilistaWhereInput | automobilistaWhereInput[]
    codCartaConducao?: IntFilter<"automobilista"> | number
    codPessoa?: IntFilter<"automobilista"> | number
    alertaroubo?: AlertarouboListRelationFilter
    cartaconducao?: XOR<CartaconducaoRelationFilter, cartaconducaoWhereInput>
    pessoa?: XOR<PessoaRelationFilter, pessoaWhereInput>
    multa?: MultaListRelationFilter
  }, "codAutomobilista">

  export type automobilistaOrderByWithAggregationInput = {
    codAutomobilista?: SortOrder
    codCartaConducao?: SortOrder
    codPessoa?: SortOrder
    _count?: automobilistaCountOrderByAggregateInput
    _avg?: automobilistaAvgOrderByAggregateInput
    _max?: automobilistaMaxOrderByAggregateInput
    _min?: automobilistaMinOrderByAggregateInput
    _sum?: automobilistaSumOrderByAggregateInput
  }

  export type automobilistaScalarWhereWithAggregatesInput = {
    AND?: automobilistaScalarWhereWithAggregatesInput | automobilistaScalarWhereWithAggregatesInput[]
    OR?: automobilistaScalarWhereWithAggregatesInput[]
    NOT?: automobilistaScalarWhereWithAggregatesInput | automobilistaScalarWhereWithAggregatesInput[]
    codAutomobilista?: IntWithAggregatesFilter<"automobilista"> | number
    codCartaConducao?: IntWithAggregatesFilter<"automobilista"> | number
    codPessoa?: IntWithAggregatesFilter<"automobilista"> | number
  }

  export type biWhereInput = {
    AND?: biWhereInput | biWhereInput[]
    OR?: biWhereInput[]
    NOT?: biWhereInput | biWhereInput[]
    idBi?: IntFilter<"bi"> | number
    dataEmicaoBi?: DateTimeFilter<"bi"> | Date | string
    dataValidacaoBi?: DateTimeFilter<"bi"> | Date | string
    numeroBI?: StringFilter<"bi"> | string
    codFicheiroBi?: IntFilter<"bi"> | number
    ficheiro?: XOR<FicheiroRelationFilter, ficheiroWhereInput>
    pessoa?: PessoaListRelationFilter
  }

  export type biOrderByWithRelationInput = {
    idBi?: SortOrder
    dataEmicaoBi?: SortOrder
    dataValidacaoBi?: SortOrder
    numeroBI?: SortOrder
    codFicheiroBi?: SortOrder
    ficheiro?: ficheiroOrderByWithRelationInput
    pessoa?: pessoaOrderByRelationAggregateInput
  }

  export type biWhereUniqueInput = Prisma.AtLeast<{
    idBi?: number
    AND?: biWhereInput | biWhereInput[]
    OR?: biWhereInput[]
    NOT?: biWhereInput | biWhereInput[]
    dataEmicaoBi?: DateTimeFilter<"bi"> | Date | string
    dataValidacaoBi?: DateTimeFilter<"bi"> | Date | string
    numeroBI?: StringFilter<"bi"> | string
    codFicheiroBi?: IntFilter<"bi"> | number
    ficheiro?: XOR<FicheiroRelationFilter, ficheiroWhereInput>
    pessoa?: PessoaListRelationFilter
  }, "idBi">

  export type biOrderByWithAggregationInput = {
    idBi?: SortOrder
    dataEmicaoBi?: SortOrder
    dataValidacaoBi?: SortOrder
    numeroBI?: SortOrder
    codFicheiroBi?: SortOrder
    _count?: biCountOrderByAggregateInput
    _avg?: biAvgOrderByAggregateInput
    _max?: biMaxOrderByAggregateInput
    _min?: biMinOrderByAggregateInput
    _sum?: biSumOrderByAggregateInput
  }

  export type biScalarWhereWithAggregatesInput = {
    AND?: biScalarWhereWithAggregatesInput | biScalarWhereWithAggregatesInput[]
    OR?: biScalarWhereWithAggregatesInput[]
    NOT?: biScalarWhereWithAggregatesInput | biScalarWhereWithAggregatesInput[]
    idBi?: IntWithAggregatesFilter<"bi"> | number
    dataEmicaoBi?: DateTimeWithAggregatesFilter<"bi"> | Date | string
    dataValidacaoBi?: DateTimeWithAggregatesFilter<"bi"> | Date | string
    numeroBI?: StringWithAggregatesFilter<"bi"> | string
    codFicheiroBi?: IntWithAggregatesFilter<"bi"> | number
  }

  export type cartaconducaoWhereInput = {
    AND?: cartaconducaoWhereInput | cartaconducaoWhereInput[]
    OR?: cartaconducaoWhereInput[]
    NOT?: cartaconducaoWhereInput | cartaconducaoWhereInput[]
    codCartaConducao?: IntFilter<"cartaconducao"> | number
    dataEmissao?: DateTimeFilter<"cartaconducao"> | Date | string
    dataValidade?: DateTimeFilter<"cartaconducao"> | Date | string
    numeroVia?: StringFilter<"cartaconducao"> | string
    codCategoriaCarta?: IntFilter<"cartaconducao"> | number
    numeroCarta?: IntFilter<"cartaconducao"> | number
    dataPrimeiraEmissao?: DateTimeFilter<"cartaconducao"> | Date | string
    localEmissao?: IntFilter<"cartaconducao"> | number
    codFicheiroCartaConducao?: IntFilter<"cartaconducao"> | number
    automobilista?: AutomobilistaListRelationFilter
    categoriacarta?: XOR<CategoriacartaRelationFilter, categoriacartaWhereInput>
    ficheiro?: XOR<FicheiroRelationFilter, ficheiroWhereInput>
  }

  export type cartaconducaoOrderByWithRelationInput = {
    codCartaConducao?: SortOrder
    dataEmissao?: SortOrder
    dataValidade?: SortOrder
    numeroVia?: SortOrder
    codCategoriaCarta?: SortOrder
    numeroCarta?: SortOrder
    dataPrimeiraEmissao?: SortOrder
    localEmissao?: SortOrder
    codFicheiroCartaConducao?: SortOrder
    automobilista?: automobilistaOrderByRelationAggregateInput
    categoriacarta?: categoriacartaOrderByWithRelationInput
    ficheiro?: ficheiroOrderByWithRelationInput
  }

  export type cartaconducaoWhereUniqueInput = Prisma.AtLeast<{
    codCartaConducao?: number
    AND?: cartaconducaoWhereInput | cartaconducaoWhereInput[]
    OR?: cartaconducaoWhereInput[]
    NOT?: cartaconducaoWhereInput | cartaconducaoWhereInput[]
    dataEmissao?: DateTimeFilter<"cartaconducao"> | Date | string
    dataValidade?: DateTimeFilter<"cartaconducao"> | Date | string
    numeroVia?: StringFilter<"cartaconducao"> | string
    codCategoriaCarta?: IntFilter<"cartaconducao"> | number
    numeroCarta?: IntFilter<"cartaconducao"> | number
    dataPrimeiraEmissao?: DateTimeFilter<"cartaconducao"> | Date | string
    localEmissao?: IntFilter<"cartaconducao"> | number
    codFicheiroCartaConducao?: IntFilter<"cartaconducao"> | number
    automobilista?: AutomobilistaListRelationFilter
    categoriacarta?: XOR<CategoriacartaRelationFilter, categoriacartaWhereInput>
    ficheiro?: XOR<FicheiroRelationFilter, ficheiroWhereInput>
  }, "codCartaConducao">

  export type cartaconducaoOrderByWithAggregationInput = {
    codCartaConducao?: SortOrder
    dataEmissao?: SortOrder
    dataValidade?: SortOrder
    numeroVia?: SortOrder
    codCategoriaCarta?: SortOrder
    numeroCarta?: SortOrder
    dataPrimeiraEmissao?: SortOrder
    localEmissao?: SortOrder
    codFicheiroCartaConducao?: SortOrder
    _count?: cartaconducaoCountOrderByAggregateInput
    _avg?: cartaconducaoAvgOrderByAggregateInput
    _max?: cartaconducaoMaxOrderByAggregateInput
    _min?: cartaconducaoMinOrderByAggregateInput
    _sum?: cartaconducaoSumOrderByAggregateInput
  }

  export type cartaconducaoScalarWhereWithAggregatesInput = {
    AND?: cartaconducaoScalarWhereWithAggregatesInput | cartaconducaoScalarWhereWithAggregatesInput[]
    OR?: cartaconducaoScalarWhereWithAggregatesInput[]
    NOT?: cartaconducaoScalarWhereWithAggregatesInput | cartaconducaoScalarWhereWithAggregatesInput[]
    codCartaConducao?: IntWithAggregatesFilter<"cartaconducao"> | number
    dataEmissao?: DateTimeWithAggregatesFilter<"cartaconducao"> | Date | string
    dataValidade?: DateTimeWithAggregatesFilter<"cartaconducao"> | Date | string
    numeroVia?: StringWithAggregatesFilter<"cartaconducao"> | string
    codCategoriaCarta?: IntWithAggregatesFilter<"cartaconducao"> | number
    numeroCarta?: IntWithAggregatesFilter<"cartaconducao"> | number
    dataPrimeiraEmissao?: DateTimeWithAggregatesFilter<"cartaconducao"> | Date | string
    localEmissao?: IntWithAggregatesFilter<"cartaconducao"> | number
    codFicheiroCartaConducao?: IntWithAggregatesFilter<"cartaconducao"> | number
  }

  export type categoriacartaWhereInput = {
    AND?: categoriacartaWhereInput | categoriacartaWhereInput[]
    OR?: categoriacartaWhereInput[]
    NOT?: categoriacartaWhereInput | categoriacartaWhereInput[]
    codCategoriaCarta?: IntFilter<"categoriacarta"> | number
    descCategoriaCarta?: StringFilter<"categoriacarta"> | string
    sigla?: StringFilter<"categoriacarta"> | string
    cartaconducao?: CartaconducaoListRelationFilter
  }

  export type categoriacartaOrderByWithRelationInput = {
    codCategoriaCarta?: SortOrder
    descCategoriaCarta?: SortOrder
    sigla?: SortOrder
    cartaconducao?: cartaconducaoOrderByRelationAggregateInput
  }

  export type categoriacartaWhereUniqueInput = Prisma.AtLeast<{
    codCategoriaCarta?: number
    AND?: categoriacartaWhereInput | categoriacartaWhereInput[]
    OR?: categoriacartaWhereInput[]
    NOT?: categoriacartaWhereInput | categoriacartaWhereInput[]
    descCategoriaCarta?: StringFilter<"categoriacarta"> | string
    sigla?: StringFilter<"categoriacarta"> | string
    cartaconducao?: CartaconducaoListRelationFilter
  }, "codCategoriaCarta">

  export type categoriacartaOrderByWithAggregationInput = {
    codCategoriaCarta?: SortOrder
    descCategoriaCarta?: SortOrder
    sigla?: SortOrder
    _count?: categoriacartaCountOrderByAggregateInput
    _avg?: categoriacartaAvgOrderByAggregateInput
    _max?: categoriacartaMaxOrderByAggregateInput
    _min?: categoriacartaMinOrderByAggregateInput
    _sum?: categoriacartaSumOrderByAggregateInput
  }

  export type categoriacartaScalarWhereWithAggregatesInput = {
    AND?: categoriacartaScalarWhereWithAggregatesInput | categoriacartaScalarWhereWithAggregatesInput[]
    OR?: categoriacartaScalarWhereWithAggregatesInput[]
    NOT?: categoriacartaScalarWhereWithAggregatesInput | categoriacartaScalarWhereWithAggregatesInput[]
    codCategoriaCarta?: IntWithAggregatesFilter<"categoriacarta"> | number
    descCategoriaCarta?: StringWithAggregatesFilter<"categoriacarta"> | string
    sigla?: StringWithAggregatesFilter<"categoriacarta"> | string
  }

  export type contactoWhereInput = {
    AND?: contactoWhereInput | contactoWhereInput[]
    OR?: contactoWhereInput[]
    NOT?: contactoWhereInput | contactoWhereInput[]
    idContacto?: IntFilter<"contacto"> | number
    contacto1?: StringFilter<"contacto"> | string
    contacto2?: StringNullableFilter<"contacto"> | string | null
    email1?: StringNullableFilter<"contacto"> | string | null
    email2?: StringNullableFilter<"contacto"> | string | null
    pessoa?: PessoaListRelationFilter
  }

  export type contactoOrderByWithRelationInput = {
    idContacto?: SortOrder
    contacto1?: SortOrder
    contacto2?: SortOrderInput | SortOrder
    email1?: SortOrderInput | SortOrder
    email2?: SortOrderInput | SortOrder
    pessoa?: pessoaOrderByRelationAggregateInput
  }

  export type contactoWhereUniqueInput = Prisma.AtLeast<{
    idContacto?: number
    email1?: string
    email2?: string
    AND?: contactoWhereInput | contactoWhereInput[]
    OR?: contactoWhereInput[]
    NOT?: contactoWhereInput | contactoWhereInput[]
    contacto1?: StringFilter<"contacto"> | string
    contacto2?: StringNullableFilter<"contacto"> | string | null
    pessoa?: PessoaListRelationFilter
  }, "idContacto" | "email1" | "email2">

  export type contactoOrderByWithAggregationInput = {
    idContacto?: SortOrder
    contacto1?: SortOrder
    contacto2?: SortOrderInput | SortOrder
    email1?: SortOrderInput | SortOrder
    email2?: SortOrderInput | SortOrder
    _count?: contactoCountOrderByAggregateInput
    _avg?: contactoAvgOrderByAggregateInput
    _max?: contactoMaxOrderByAggregateInput
    _min?: contactoMinOrderByAggregateInput
    _sum?: contactoSumOrderByAggregateInput
  }

  export type contactoScalarWhereWithAggregatesInput = {
    AND?: contactoScalarWhereWithAggregatesInput | contactoScalarWhereWithAggregatesInput[]
    OR?: contactoScalarWhereWithAggregatesInput[]
    NOT?: contactoScalarWhereWithAggregatesInput | contactoScalarWhereWithAggregatesInput[]
    idContacto?: IntWithAggregatesFilter<"contacto"> | number
    contacto1?: StringWithAggregatesFilter<"contacto"> | string
    contacto2?: StringNullableWithAggregatesFilter<"contacto"> | string | null
    email1?: StringNullableWithAggregatesFilter<"contacto"> | string | null
    email2?: StringNullableWithAggregatesFilter<"contacto"> | string | null
  }

  export type enderecoWhereInput = {
    AND?: enderecoWhereInput | enderecoWhereInput[]
    OR?: enderecoWhereInput[]
    NOT?: enderecoWhereInput | enderecoWhereInput[]
    idEndereco?: IntFilter<"endereco"> | number
    idMunicipio?: IntFilter<"endereco"> | number
    descricaoEndereco?: StringFilter<"endereco"> | string
    municipio?: XOR<MunicipioRelationFilter, municipioWhereInput>
    pessoa?: PessoaListRelationFilter
  }

  export type enderecoOrderByWithRelationInput = {
    idEndereco?: SortOrder
    idMunicipio?: SortOrder
    descricaoEndereco?: SortOrder
    municipio?: municipioOrderByWithRelationInput
    pessoa?: pessoaOrderByRelationAggregateInput
  }

  export type enderecoWhereUniqueInput = Prisma.AtLeast<{
    idEndereco?: number
    AND?: enderecoWhereInput | enderecoWhereInput[]
    OR?: enderecoWhereInput[]
    NOT?: enderecoWhereInput | enderecoWhereInput[]
    idMunicipio?: IntFilter<"endereco"> | number
    descricaoEndereco?: StringFilter<"endereco"> | string
    municipio?: XOR<MunicipioRelationFilter, municipioWhereInput>
    pessoa?: PessoaListRelationFilter
  }, "idEndereco">

  export type enderecoOrderByWithAggregationInput = {
    idEndereco?: SortOrder
    idMunicipio?: SortOrder
    descricaoEndereco?: SortOrder
    _count?: enderecoCountOrderByAggregateInput
    _avg?: enderecoAvgOrderByAggregateInput
    _max?: enderecoMaxOrderByAggregateInput
    _min?: enderecoMinOrderByAggregateInput
    _sum?: enderecoSumOrderByAggregateInput
  }

  export type enderecoScalarWhereWithAggregatesInput = {
    AND?: enderecoScalarWhereWithAggregatesInput | enderecoScalarWhereWithAggregatesInput[]
    OR?: enderecoScalarWhereWithAggregatesInput[]
    NOT?: enderecoScalarWhereWithAggregatesInput | enderecoScalarWhereWithAggregatesInput[]
    idEndereco?: IntWithAggregatesFilter<"endereco"> | number
    idMunicipio?: IntWithAggregatesFilter<"endereco"> | number
    descricaoEndereco?: StringWithAggregatesFilter<"endereco"> | string
  }

  export type ficheiroWhereInput = {
    AND?: ficheiroWhereInput | ficheiroWhereInput[]
    OR?: ficheiroWhereInput[]
    NOT?: ficheiroWhereInput | ficheiroWhereInput[]
    idFicheiro?: IntFilter<"ficheiro"> | number
    nomeFicheiro?: StringFilter<"ficheiro"> | string
    dataEntrada?: StringNullableFilter<"ficheiro"> | string | null
    dataValidacao?: StringNullableFilter<"ficheiro"> | string | null
    estadoValidacao?: Enumficheiro_estadoValidacaoNullableFilter<"ficheiro"> | $Enums.ficheiro_estadoValidacao | null
    bi?: BiListRelationFilter
    cartaconducao?: CartaconducaoListRelationFilter
    funcionario?: FuncionarioListRelationFilter
    pagamentomulta?: PagamentomultaListRelationFilter
    titulopropriedade?: TitulopropriedadeListRelationFilter
  }

  export type ficheiroOrderByWithRelationInput = {
    idFicheiro?: SortOrder
    nomeFicheiro?: SortOrder
    dataEntrada?: SortOrderInput | SortOrder
    dataValidacao?: SortOrderInput | SortOrder
    estadoValidacao?: SortOrderInput | SortOrder
    bi?: biOrderByRelationAggregateInput
    cartaconducao?: cartaconducaoOrderByRelationAggregateInput
    funcionario?: funcionarioOrderByRelationAggregateInput
    pagamentomulta?: pagamentomultaOrderByRelationAggregateInput
    titulopropriedade?: titulopropriedadeOrderByRelationAggregateInput
  }

  export type ficheiroWhereUniqueInput = Prisma.AtLeast<{
    idFicheiro?: number
    AND?: ficheiroWhereInput | ficheiroWhereInput[]
    OR?: ficheiroWhereInput[]
    NOT?: ficheiroWhereInput | ficheiroWhereInput[]
    nomeFicheiro?: StringFilter<"ficheiro"> | string
    dataEntrada?: StringNullableFilter<"ficheiro"> | string | null
    dataValidacao?: StringNullableFilter<"ficheiro"> | string | null
    estadoValidacao?: Enumficheiro_estadoValidacaoNullableFilter<"ficheiro"> | $Enums.ficheiro_estadoValidacao | null
    bi?: BiListRelationFilter
    cartaconducao?: CartaconducaoListRelationFilter
    funcionario?: FuncionarioListRelationFilter
    pagamentomulta?: PagamentomultaListRelationFilter
    titulopropriedade?: TitulopropriedadeListRelationFilter
  }, "idFicheiro">

  export type ficheiroOrderByWithAggregationInput = {
    idFicheiro?: SortOrder
    nomeFicheiro?: SortOrder
    dataEntrada?: SortOrderInput | SortOrder
    dataValidacao?: SortOrderInput | SortOrder
    estadoValidacao?: SortOrderInput | SortOrder
    _count?: ficheiroCountOrderByAggregateInput
    _avg?: ficheiroAvgOrderByAggregateInput
    _max?: ficheiroMaxOrderByAggregateInput
    _min?: ficheiroMinOrderByAggregateInput
    _sum?: ficheiroSumOrderByAggregateInput
  }

  export type ficheiroScalarWhereWithAggregatesInput = {
    AND?: ficheiroScalarWhereWithAggregatesInput | ficheiroScalarWhereWithAggregatesInput[]
    OR?: ficheiroScalarWhereWithAggregatesInput[]
    NOT?: ficheiroScalarWhereWithAggregatesInput | ficheiroScalarWhereWithAggregatesInput[]
    idFicheiro?: IntWithAggregatesFilter<"ficheiro"> | number
    nomeFicheiro?: StringWithAggregatesFilter<"ficheiro"> | string
    dataEntrada?: StringNullableWithAggregatesFilter<"ficheiro"> | string | null
    dataValidacao?: StringNullableWithAggregatesFilter<"ficheiro"> | string | null
    estadoValidacao?: Enumficheiro_estadoValidacaoNullableWithAggregatesFilter<"ficheiro"> | $Enums.ficheiro_estadoValidacao | null
  }

  export type funcionarioWhereInput = {
    AND?: funcionarioWhereInput | funcionarioWhereInput[]
    OR?: funcionarioWhereInput[]
    NOT?: funcionarioWhereInput | funcionarioWhereInput[]
    codFuncionario?: IntFilter<"funcionario"> | number
    codPessoa?: IntFilter<"funcionario"> | number
    codficheiroFotoPerfil?: IntFilter<"funcionario"> | number
    codficheiroFotoPendente?: IntNullableFilter<"funcionario"> | number | null
    numeroAgente?: StringNullableFilter<"funcionario"> | string | null
    senha?: IntFilter<"funcionario"> | number
    ficheiro?: XOR<FicheiroRelationFilter, ficheiroWhereInput>
    pessoa?: XOR<PessoaRelationFilter, pessoaWhereInput>
  }

  export type funcionarioOrderByWithRelationInput = {
    codFuncionario?: SortOrder
    codPessoa?: SortOrder
    codficheiroFotoPerfil?: SortOrder
    codficheiroFotoPendente?: SortOrderInput | SortOrder
    numeroAgente?: SortOrderInput | SortOrder
    senha?: SortOrder
    ficheiro?: ficheiroOrderByWithRelationInput
    pessoa?: pessoaOrderByWithRelationInput
  }

  export type funcionarioWhereUniqueInput = Prisma.AtLeast<{
    codFuncionario?: number
    numeroAgente?: string
    AND?: funcionarioWhereInput | funcionarioWhereInput[]
    OR?: funcionarioWhereInput[]
    NOT?: funcionarioWhereInput | funcionarioWhereInput[]
    codPessoa?: IntFilter<"funcionario"> | number
    codficheiroFotoPerfil?: IntFilter<"funcionario"> | number
    codficheiroFotoPendente?: IntNullableFilter<"funcionario"> | number | null
    senha?: IntFilter<"funcionario"> | number
    ficheiro?: XOR<FicheiroRelationFilter, ficheiroWhereInput>
    pessoa?: XOR<PessoaRelationFilter, pessoaWhereInput>
  }, "codFuncionario" | "numeroAgente">

  export type funcionarioOrderByWithAggregationInput = {
    codFuncionario?: SortOrder
    codPessoa?: SortOrder
    codficheiroFotoPerfil?: SortOrder
    codficheiroFotoPendente?: SortOrderInput | SortOrder
    numeroAgente?: SortOrderInput | SortOrder
    senha?: SortOrder
    _count?: funcionarioCountOrderByAggregateInput
    _avg?: funcionarioAvgOrderByAggregateInput
    _max?: funcionarioMaxOrderByAggregateInput
    _min?: funcionarioMinOrderByAggregateInput
    _sum?: funcionarioSumOrderByAggregateInput
  }

  export type funcionarioScalarWhereWithAggregatesInput = {
    AND?: funcionarioScalarWhereWithAggregatesInput | funcionarioScalarWhereWithAggregatesInput[]
    OR?: funcionarioScalarWhereWithAggregatesInput[]
    NOT?: funcionarioScalarWhereWithAggregatesInput | funcionarioScalarWhereWithAggregatesInput[]
    codFuncionario?: IntWithAggregatesFilter<"funcionario"> | number
    codPessoa?: IntWithAggregatesFilter<"funcionario"> | number
    codficheiroFotoPerfil?: IntWithAggregatesFilter<"funcionario"> | number
    codficheiroFotoPendente?: IntNullableWithAggregatesFilter<"funcionario"> | number | null
    numeroAgente?: StringNullableWithAggregatesFilter<"funcionario"> | string | null
    senha?: IntWithAggregatesFilter<"funcionario"> | number
  }

  export type infracaoWhereInput = {
    AND?: infracaoWhereInput | infracaoWhereInput[]
    OR?: infracaoWhereInput[]
    NOT?: infracaoWhereInput | infracaoWhereInput[]
    codInfracao?: IntFilter<"infracao"> | number
    codMulta?: IntFilter<"infracao"> | number
    codTipoInfracao?: IntFilter<"infracao"> | number
    multa_infracao_codMultaTomulta?: XOR<MultaRelationFilter, multaWhereInput>
    tipoinfracao?: XOR<TipoinfracaoRelationFilter, tipoinfracaoWhereInput>
    multa_multa_codInfracaoToinfracao?: MultaListRelationFilter
  }

  export type infracaoOrderByWithRelationInput = {
    codInfracao?: SortOrder
    codMulta?: SortOrder
    codTipoInfracao?: SortOrder
    multa_infracao_codMultaTomulta?: multaOrderByWithRelationInput
    tipoinfracao?: tipoinfracaoOrderByWithRelationInput
    multa_multa_codInfracaoToinfracao?: multaOrderByRelationAggregateInput
  }

  export type infracaoWhereUniqueInput = Prisma.AtLeast<{
    codInfracao?: number
    AND?: infracaoWhereInput | infracaoWhereInput[]
    OR?: infracaoWhereInput[]
    NOT?: infracaoWhereInput | infracaoWhereInput[]
    codMulta?: IntFilter<"infracao"> | number
    codTipoInfracao?: IntFilter<"infracao"> | number
    multa_infracao_codMultaTomulta?: XOR<MultaRelationFilter, multaWhereInput>
    tipoinfracao?: XOR<TipoinfracaoRelationFilter, tipoinfracaoWhereInput>
    multa_multa_codInfracaoToinfracao?: MultaListRelationFilter
  }, "codInfracao">

  export type infracaoOrderByWithAggregationInput = {
    codInfracao?: SortOrder
    codMulta?: SortOrder
    codTipoInfracao?: SortOrder
    _count?: infracaoCountOrderByAggregateInput
    _avg?: infracaoAvgOrderByAggregateInput
    _max?: infracaoMaxOrderByAggregateInput
    _min?: infracaoMinOrderByAggregateInput
    _sum?: infracaoSumOrderByAggregateInput
  }

  export type infracaoScalarWhereWithAggregatesInput = {
    AND?: infracaoScalarWhereWithAggregatesInput | infracaoScalarWhereWithAggregatesInput[]
    OR?: infracaoScalarWhereWithAggregatesInput[]
    NOT?: infracaoScalarWhereWithAggregatesInput | infracaoScalarWhereWithAggregatesInput[]
    codInfracao?: IntWithAggregatesFilter<"infracao"> | number
    codMulta?: IntWithAggregatesFilter<"infracao"> | number
    codTipoInfracao?: IntWithAggregatesFilter<"infracao"> | number
  }

  export type livreteWhereInput = {
    AND?: livreteWhereInput | livreteWhereInput[]
    OR?: livreteWhereInput[]
    NOT?: livreteWhereInput | livreteWhereInput[]
    codLivrete?: IntFilter<"livrete"> | number
    codViatura?: IntFilter<"livrete"> | number
    numeroQuadro?: StringFilter<"livrete"> | string
    corViatura?: StringFilter<"livrete"> | string
    MedidasPneumaticos?: StringFilter<"livrete"> | string
    codServico?: IntFilter<"livrete"> | number
    dataEmissao?: DateTimeFilter<"livrete"> | Date | string
    dataPrimeiroRegistro?: DateTimeFilter<"livrete"> | Date | string
    lotacao?: StringFilter<"livrete"> | string
    cilindrada?: StringFilter<"livrete"> | string
    numeroCilindro?: StringFilter<"livrete"> | string
    conbustivel?: StringFilter<"livrete"> | string
    peso?: StringFilter<"livrete"> | string
    tara?: StringFilter<"livrete"> | string
    tipoCaixa?: StringFilter<"livrete"> | string
    distanciaEixo?: StringFilter<"livrete"> | string
    modelo?: StringFilter<"livrete"> | string
    codMarca?: IntFilter<"livrete"> | number
    marca?: XOR<MarcaRelationFilter, marcaWhereInput>
    viatura?: XOR<ViaturaRelationFilter, viaturaWhereInput>
    serivicoviatura?: XOR<SerivicoviaturaRelationFilter, serivicoviaturaWhereInput>
  }

  export type livreteOrderByWithRelationInput = {
    codLivrete?: SortOrder
    codViatura?: SortOrder
    numeroQuadro?: SortOrder
    corViatura?: SortOrder
    MedidasPneumaticos?: SortOrder
    codServico?: SortOrder
    dataEmissao?: SortOrder
    dataPrimeiroRegistro?: SortOrder
    lotacao?: SortOrder
    cilindrada?: SortOrder
    numeroCilindro?: SortOrder
    conbustivel?: SortOrder
    peso?: SortOrder
    tara?: SortOrder
    tipoCaixa?: SortOrder
    distanciaEixo?: SortOrder
    modelo?: SortOrder
    codMarca?: SortOrder
    marca?: marcaOrderByWithRelationInput
    viatura?: viaturaOrderByWithRelationInput
    serivicoviatura?: serivicoviaturaOrderByWithRelationInput
  }

  export type livreteWhereUniqueInput = Prisma.AtLeast<{
    codLivrete?: number
    AND?: livreteWhereInput | livreteWhereInput[]
    OR?: livreteWhereInput[]
    NOT?: livreteWhereInput | livreteWhereInput[]
    codViatura?: IntFilter<"livrete"> | number
    numeroQuadro?: StringFilter<"livrete"> | string
    corViatura?: StringFilter<"livrete"> | string
    MedidasPneumaticos?: StringFilter<"livrete"> | string
    codServico?: IntFilter<"livrete"> | number
    dataEmissao?: DateTimeFilter<"livrete"> | Date | string
    dataPrimeiroRegistro?: DateTimeFilter<"livrete"> | Date | string
    lotacao?: StringFilter<"livrete"> | string
    cilindrada?: StringFilter<"livrete"> | string
    numeroCilindro?: StringFilter<"livrete"> | string
    conbustivel?: StringFilter<"livrete"> | string
    peso?: StringFilter<"livrete"> | string
    tara?: StringFilter<"livrete"> | string
    tipoCaixa?: StringFilter<"livrete"> | string
    distanciaEixo?: StringFilter<"livrete"> | string
    modelo?: StringFilter<"livrete"> | string
    codMarca?: IntFilter<"livrete"> | number
    marca?: XOR<MarcaRelationFilter, marcaWhereInput>
    viatura?: XOR<ViaturaRelationFilter, viaturaWhereInput>
    serivicoviatura?: XOR<SerivicoviaturaRelationFilter, serivicoviaturaWhereInput>
  }, "codLivrete">

  export type livreteOrderByWithAggregationInput = {
    codLivrete?: SortOrder
    codViatura?: SortOrder
    numeroQuadro?: SortOrder
    corViatura?: SortOrder
    MedidasPneumaticos?: SortOrder
    codServico?: SortOrder
    dataEmissao?: SortOrder
    dataPrimeiroRegistro?: SortOrder
    lotacao?: SortOrder
    cilindrada?: SortOrder
    numeroCilindro?: SortOrder
    conbustivel?: SortOrder
    peso?: SortOrder
    tara?: SortOrder
    tipoCaixa?: SortOrder
    distanciaEixo?: SortOrder
    modelo?: SortOrder
    codMarca?: SortOrder
    _count?: livreteCountOrderByAggregateInput
    _avg?: livreteAvgOrderByAggregateInput
    _max?: livreteMaxOrderByAggregateInput
    _min?: livreteMinOrderByAggregateInput
    _sum?: livreteSumOrderByAggregateInput
  }

  export type livreteScalarWhereWithAggregatesInput = {
    AND?: livreteScalarWhereWithAggregatesInput | livreteScalarWhereWithAggregatesInput[]
    OR?: livreteScalarWhereWithAggregatesInput[]
    NOT?: livreteScalarWhereWithAggregatesInput | livreteScalarWhereWithAggregatesInput[]
    codLivrete?: IntWithAggregatesFilter<"livrete"> | number
    codViatura?: IntWithAggregatesFilter<"livrete"> | number
    numeroQuadro?: StringWithAggregatesFilter<"livrete"> | string
    corViatura?: StringWithAggregatesFilter<"livrete"> | string
    MedidasPneumaticos?: StringWithAggregatesFilter<"livrete"> | string
    codServico?: IntWithAggregatesFilter<"livrete"> | number
    dataEmissao?: DateTimeWithAggregatesFilter<"livrete"> | Date | string
    dataPrimeiroRegistro?: DateTimeWithAggregatesFilter<"livrete"> | Date | string
    lotacao?: StringWithAggregatesFilter<"livrete"> | string
    cilindrada?: StringWithAggregatesFilter<"livrete"> | string
    numeroCilindro?: StringWithAggregatesFilter<"livrete"> | string
    conbustivel?: StringWithAggregatesFilter<"livrete"> | string
    peso?: StringWithAggregatesFilter<"livrete"> | string
    tara?: StringWithAggregatesFilter<"livrete"> | string
    tipoCaixa?: StringWithAggregatesFilter<"livrete"> | string
    distanciaEixo?: StringWithAggregatesFilter<"livrete"> | string
    modelo?: StringWithAggregatesFilter<"livrete"> | string
    codMarca?: IntWithAggregatesFilter<"livrete"> | number
  }

  export type marcaWhereInput = {
    AND?: marcaWhereInput | marcaWhereInput[]
    OR?: marcaWhereInput[]
    NOT?: marcaWhereInput | marcaWhereInput[]
    codMarca?: IntFilter<"marca"> | number
    descMarca?: StringFilter<"marca"> | string
    livrete?: LivreteListRelationFilter
  }

  export type marcaOrderByWithRelationInput = {
    codMarca?: SortOrder
    descMarca?: SortOrder
    livrete?: livreteOrderByRelationAggregateInput
  }

  export type marcaWhereUniqueInput = Prisma.AtLeast<{
    codMarca?: number
    AND?: marcaWhereInput | marcaWhereInput[]
    OR?: marcaWhereInput[]
    NOT?: marcaWhereInput | marcaWhereInput[]
    descMarca?: StringFilter<"marca"> | string
    livrete?: LivreteListRelationFilter
  }, "codMarca">

  export type marcaOrderByWithAggregationInput = {
    codMarca?: SortOrder
    descMarca?: SortOrder
    _count?: marcaCountOrderByAggregateInput
    _avg?: marcaAvgOrderByAggregateInput
    _max?: marcaMaxOrderByAggregateInput
    _min?: marcaMinOrderByAggregateInput
    _sum?: marcaSumOrderByAggregateInput
  }

  export type marcaScalarWhereWithAggregatesInput = {
    AND?: marcaScalarWhereWithAggregatesInput | marcaScalarWhereWithAggregatesInput[]
    OR?: marcaScalarWhereWithAggregatesInput[]
    NOT?: marcaScalarWhereWithAggregatesInput | marcaScalarWhereWithAggregatesInput[]
    codMarca?: IntWithAggregatesFilter<"marca"> | number
    descMarca?: StringWithAggregatesFilter<"marca"> | string
  }

  export type multaWhereInput = {
    AND?: multaWhereInput | multaWhereInput[]
    OR?: multaWhereInput[]
    NOT?: multaWhereInput | multaWhereInput[]
    codMulta?: IntFilter<"multa"> | number
    codAutomobilista?: IntNullableFilter<"multa"> | number | null
    CodViatura?: IntNullableFilter<"multa"> | number | null
    codInfracao?: IntFilter<"multa"> | number
    valorMulta?: StringFilter<"multa"> | string
    estadoMulta?: Enummulta_estadoMultaFilter<"multa"> | $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: InfracaoListRelationFilter
    automobilista?: XOR<AutomobilistaNullableRelationFilter, automobilistaWhereInput> | null
    infracao_multa_codInfracaoToinfracao?: XOR<InfracaoRelationFilter, infracaoWhereInput>
    viatura?: XOR<ViaturaNullableRelationFilter, viaturaWhereInput> | null
    pagamentomulta?: PagamentomultaListRelationFilter
  }

  export type multaOrderByWithRelationInput = {
    codMulta?: SortOrder
    codAutomobilista?: SortOrderInput | SortOrder
    CodViatura?: SortOrderInput | SortOrder
    codInfracao?: SortOrder
    valorMulta?: SortOrder
    estadoMulta?: SortOrder
    infracao_infracao_codMultaTomulta?: infracaoOrderByRelationAggregateInput
    automobilista?: automobilistaOrderByWithRelationInput
    infracao_multa_codInfracaoToinfracao?: infracaoOrderByWithRelationInput
    viatura?: viaturaOrderByWithRelationInput
    pagamentomulta?: pagamentomultaOrderByRelationAggregateInput
  }

  export type multaWhereUniqueInput = Prisma.AtLeast<{
    codMulta?: number
    AND?: multaWhereInput | multaWhereInput[]
    OR?: multaWhereInput[]
    NOT?: multaWhereInput | multaWhereInput[]
    codAutomobilista?: IntNullableFilter<"multa"> | number | null
    CodViatura?: IntNullableFilter<"multa"> | number | null
    codInfracao?: IntFilter<"multa"> | number
    valorMulta?: StringFilter<"multa"> | string
    estadoMulta?: Enummulta_estadoMultaFilter<"multa"> | $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: InfracaoListRelationFilter
    automobilista?: XOR<AutomobilistaNullableRelationFilter, automobilistaWhereInput> | null
    infracao_multa_codInfracaoToinfracao?: XOR<InfracaoRelationFilter, infracaoWhereInput>
    viatura?: XOR<ViaturaNullableRelationFilter, viaturaWhereInput> | null
    pagamentomulta?: PagamentomultaListRelationFilter
  }, "codMulta">

  export type multaOrderByWithAggregationInput = {
    codMulta?: SortOrder
    codAutomobilista?: SortOrderInput | SortOrder
    CodViatura?: SortOrderInput | SortOrder
    codInfracao?: SortOrder
    valorMulta?: SortOrder
    estadoMulta?: SortOrder
    _count?: multaCountOrderByAggregateInput
    _avg?: multaAvgOrderByAggregateInput
    _max?: multaMaxOrderByAggregateInput
    _min?: multaMinOrderByAggregateInput
    _sum?: multaSumOrderByAggregateInput
  }

  export type multaScalarWhereWithAggregatesInput = {
    AND?: multaScalarWhereWithAggregatesInput | multaScalarWhereWithAggregatesInput[]
    OR?: multaScalarWhereWithAggregatesInput[]
    NOT?: multaScalarWhereWithAggregatesInput | multaScalarWhereWithAggregatesInput[]
    codMulta?: IntWithAggregatesFilter<"multa"> | number
    codAutomobilista?: IntNullableWithAggregatesFilter<"multa"> | number | null
    CodViatura?: IntNullableWithAggregatesFilter<"multa"> | number | null
    codInfracao?: IntWithAggregatesFilter<"multa"> | number
    valorMulta?: StringWithAggregatesFilter<"multa"> | string
    estadoMulta?: Enummulta_estadoMultaWithAggregatesFilter<"multa"> | $Enums.multa_estadoMulta
  }

  export type municipioWhereInput = {
    AND?: municipioWhereInput | municipioWhereInput[]
    OR?: municipioWhereInput[]
    NOT?: municipioWhereInput | municipioWhereInput[]
    idMunicipio?: IntFilter<"municipio"> | number
    idProvincia?: IntFilter<"municipio"> | number
    municipio?: StringFilter<"municipio"> | string
    endereco?: EnderecoListRelationFilter
    provincia?: XOR<ProvinciaRelationFilter, provinciaWhereInput>
  }

  export type municipioOrderByWithRelationInput = {
    idMunicipio?: SortOrder
    idProvincia?: SortOrder
    municipio?: SortOrder
    endereco?: enderecoOrderByRelationAggregateInput
    provincia?: provinciaOrderByWithRelationInput
  }

  export type municipioWhereUniqueInput = Prisma.AtLeast<{
    idMunicipio?: number
    AND?: municipioWhereInput | municipioWhereInput[]
    OR?: municipioWhereInput[]
    NOT?: municipioWhereInput | municipioWhereInput[]
    idProvincia?: IntFilter<"municipio"> | number
    municipio?: StringFilter<"municipio"> | string
    endereco?: EnderecoListRelationFilter
    provincia?: XOR<ProvinciaRelationFilter, provinciaWhereInput>
  }, "idMunicipio">

  export type municipioOrderByWithAggregationInput = {
    idMunicipio?: SortOrder
    idProvincia?: SortOrder
    municipio?: SortOrder
    _count?: municipioCountOrderByAggregateInput
    _avg?: municipioAvgOrderByAggregateInput
    _max?: municipioMaxOrderByAggregateInput
    _min?: municipioMinOrderByAggregateInput
    _sum?: municipioSumOrderByAggregateInput
  }

  export type municipioScalarWhereWithAggregatesInput = {
    AND?: municipioScalarWhereWithAggregatesInput | municipioScalarWhereWithAggregatesInput[]
    OR?: municipioScalarWhereWithAggregatesInput[]
    NOT?: municipioScalarWhereWithAggregatesInput | municipioScalarWhereWithAggregatesInput[]
    idMunicipio?: IntWithAggregatesFilter<"municipio"> | number
    idProvincia?: IntWithAggregatesFilter<"municipio"> | number
    municipio?: StringWithAggregatesFilter<"municipio"> | string
  }

  export type pagamentomultaWhereInput = {
    AND?: pagamentomultaWhereInput | pagamentomultaWhereInput[]
    OR?: pagamentomultaWhereInput[]
    NOT?: pagamentomultaWhereInput | pagamentomultaWhereInput[]
    codPagamentoMulta?: IntFilter<"pagamentomulta"> | number
    codMulta?: IntFilter<"pagamentomulta"> | number
    dataPagamento?: DateTimeFilter<"pagamentomulta"> | Date | string
    valorPago?: StringFilter<"pagamentomulta"> | string
    descCodigoDeposito?: StringFilter<"pagamentomulta"> | string
    codFicheiroPagamento?: IntFilter<"pagamentomulta"> | number
    multa?: XOR<MultaRelationFilter, multaWhereInput>
    ficheiro?: XOR<FicheiroRelationFilter, ficheiroWhereInput>
  }

  export type pagamentomultaOrderByWithRelationInput = {
    codPagamentoMulta?: SortOrder
    codMulta?: SortOrder
    dataPagamento?: SortOrder
    valorPago?: SortOrder
    descCodigoDeposito?: SortOrder
    codFicheiroPagamento?: SortOrder
    multa?: multaOrderByWithRelationInput
    ficheiro?: ficheiroOrderByWithRelationInput
  }

  export type pagamentomultaWhereUniqueInput = Prisma.AtLeast<{
    codPagamentoMulta?: number
    AND?: pagamentomultaWhereInput | pagamentomultaWhereInput[]
    OR?: pagamentomultaWhereInput[]
    NOT?: pagamentomultaWhereInput | pagamentomultaWhereInput[]
    codMulta?: IntFilter<"pagamentomulta"> | number
    dataPagamento?: DateTimeFilter<"pagamentomulta"> | Date | string
    valorPago?: StringFilter<"pagamentomulta"> | string
    descCodigoDeposito?: StringFilter<"pagamentomulta"> | string
    codFicheiroPagamento?: IntFilter<"pagamentomulta"> | number
    multa?: XOR<MultaRelationFilter, multaWhereInput>
    ficheiro?: XOR<FicheiroRelationFilter, ficheiroWhereInput>
  }, "codPagamentoMulta">

  export type pagamentomultaOrderByWithAggregationInput = {
    codPagamentoMulta?: SortOrder
    codMulta?: SortOrder
    dataPagamento?: SortOrder
    valorPago?: SortOrder
    descCodigoDeposito?: SortOrder
    codFicheiroPagamento?: SortOrder
    _count?: pagamentomultaCountOrderByAggregateInput
    _avg?: pagamentomultaAvgOrderByAggregateInput
    _max?: pagamentomultaMaxOrderByAggregateInput
    _min?: pagamentomultaMinOrderByAggregateInput
    _sum?: pagamentomultaSumOrderByAggregateInput
  }

  export type pagamentomultaScalarWhereWithAggregatesInput = {
    AND?: pagamentomultaScalarWhereWithAggregatesInput | pagamentomultaScalarWhereWithAggregatesInput[]
    OR?: pagamentomultaScalarWhereWithAggregatesInput[]
    NOT?: pagamentomultaScalarWhereWithAggregatesInput | pagamentomultaScalarWhereWithAggregatesInput[]
    codPagamentoMulta?: IntWithAggregatesFilter<"pagamentomulta"> | number
    codMulta?: IntWithAggregatesFilter<"pagamentomulta"> | number
    dataPagamento?: DateTimeWithAggregatesFilter<"pagamentomulta"> | Date | string
    valorPago?: StringWithAggregatesFilter<"pagamentomulta"> | string
    descCodigoDeposito?: StringWithAggregatesFilter<"pagamentomulta"> | string
    codFicheiroPagamento?: IntWithAggregatesFilter<"pagamentomulta"> | number
  }

  export type paisWhereInput = {
    AND?: paisWhereInput | paisWhereInput[]
    OR?: paisWhereInput[]
    NOT?: paisWhereInput | paisWhereInput[]
    idPais?: IntFilter<"pais"> | number
    pais?: StringFilter<"pais"> | string
    pessoa?: PessoaListRelationFilter
  }

  export type paisOrderByWithRelationInput = {
    idPais?: SortOrder
    pais?: SortOrder
    pessoa?: pessoaOrderByRelationAggregateInput
  }

  export type paisWhereUniqueInput = Prisma.AtLeast<{
    idPais?: number
    pais?: string
    AND?: paisWhereInput | paisWhereInput[]
    OR?: paisWhereInput[]
    NOT?: paisWhereInput | paisWhereInput[]
    pessoa?: PessoaListRelationFilter
  }, "idPais" | "pais">

  export type paisOrderByWithAggregationInput = {
    idPais?: SortOrder
    pais?: SortOrder
    _count?: paisCountOrderByAggregateInput
    _avg?: paisAvgOrderByAggregateInput
    _max?: paisMaxOrderByAggregateInput
    _min?: paisMinOrderByAggregateInput
    _sum?: paisSumOrderByAggregateInput
  }

  export type paisScalarWhereWithAggregatesInput = {
    AND?: paisScalarWhereWithAggregatesInput | paisScalarWhereWithAggregatesInput[]
    OR?: paisScalarWhereWithAggregatesInput[]
    NOT?: paisScalarWhereWithAggregatesInput | paisScalarWhereWithAggregatesInput[]
    idPais?: IntWithAggregatesFilter<"pais"> | number
    pais?: StringWithAggregatesFilter<"pais"> | string
  }

  export type pessoaWhereInput = {
    AND?: pessoaWhereInput | pessoaWhereInput[]
    OR?: pessoaWhereInput[]
    NOT?: pessoaWhereInput | pessoaWhereInput[]
    codPessoa?: IntFilter<"pessoa"> | number
    codEndereco?: IntNullableFilter<"pessoa"> | number | null
    codNacionalidade?: IntNullableFilter<"pessoa"> | number | null
    codContacto?: IntNullableFilter<"pessoa"> | number | null
    nome?: StringFilter<"pessoa"> | string
    genero?: Enumpessoa_generoFilter<"pessoa"> | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFilter<"pessoa"> | $Enums.pessoa_estadoCivil
    dataCadastro?: StringNullableFilter<"pessoa"> | string | null
    dataNascimento?: StringFilter<"pessoa"> | string
    codBi?: IntFilter<"pessoa"> | number
    senha?: StringFilter<"pessoa"> | string
    automobilista?: AutomobilistaListRelationFilter
    funcionario?: FuncionarioListRelationFilter
    contacto?: XOR<ContactoNullableRelationFilter, contactoWhereInput> | null
    endereco?: XOR<EnderecoNullableRelationFilter, enderecoWhereInput> | null
    pais?: XOR<PaisNullableRelationFilter, paisWhereInput> | null
    bi?: XOR<BiRelationFilter, biWhereInput>
    titulopropriedade?: TitulopropriedadeListRelationFilter
  }

  export type pessoaOrderByWithRelationInput = {
    codPessoa?: SortOrder
    codEndereco?: SortOrderInput | SortOrder
    codNacionalidade?: SortOrderInput | SortOrder
    codContacto?: SortOrderInput | SortOrder
    nome?: SortOrder
    genero?: SortOrder
    estadoCivil?: SortOrder
    dataCadastro?: SortOrderInput | SortOrder
    dataNascimento?: SortOrder
    codBi?: SortOrder
    senha?: SortOrder
    automobilista?: automobilistaOrderByRelationAggregateInput
    funcionario?: funcionarioOrderByRelationAggregateInput
    contacto?: contactoOrderByWithRelationInput
    endereco?: enderecoOrderByWithRelationInput
    pais?: paisOrderByWithRelationInput
    bi?: biOrderByWithRelationInput
    titulopropriedade?: titulopropriedadeOrderByRelationAggregateInput
  }

  export type pessoaWhereUniqueInput = Prisma.AtLeast<{
    codPessoa?: number
    AND?: pessoaWhereInput | pessoaWhereInput[]
    OR?: pessoaWhereInput[]
    NOT?: pessoaWhereInput | pessoaWhereInput[]
    codEndereco?: IntNullableFilter<"pessoa"> | number | null
    codNacionalidade?: IntNullableFilter<"pessoa"> | number | null
    codContacto?: IntNullableFilter<"pessoa"> | number | null
    nome?: StringFilter<"pessoa"> | string
    genero?: Enumpessoa_generoFilter<"pessoa"> | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFilter<"pessoa"> | $Enums.pessoa_estadoCivil
    dataCadastro?: StringNullableFilter<"pessoa"> | string | null
    dataNascimento?: StringFilter<"pessoa"> | string
    codBi?: IntFilter<"pessoa"> | number
    senha?: StringFilter<"pessoa"> | string
    automobilista?: AutomobilistaListRelationFilter
    funcionario?: FuncionarioListRelationFilter
    contacto?: XOR<ContactoNullableRelationFilter, contactoWhereInput> | null
    endereco?: XOR<EnderecoNullableRelationFilter, enderecoWhereInput> | null
    pais?: XOR<PaisNullableRelationFilter, paisWhereInput> | null
    bi?: XOR<BiRelationFilter, biWhereInput>
    titulopropriedade?: TitulopropriedadeListRelationFilter
  }, "codPessoa">

  export type pessoaOrderByWithAggregationInput = {
    codPessoa?: SortOrder
    codEndereco?: SortOrderInput | SortOrder
    codNacionalidade?: SortOrderInput | SortOrder
    codContacto?: SortOrderInput | SortOrder
    nome?: SortOrder
    genero?: SortOrder
    estadoCivil?: SortOrder
    dataCadastro?: SortOrderInput | SortOrder
    dataNascimento?: SortOrder
    codBi?: SortOrder
    senha?: SortOrder
    _count?: pessoaCountOrderByAggregateInput
    _avg?: pessoaAvgOrderByAggregateInput
    _max?: pessoaMaxOrderByAggregateInput
    _min?: pessoaMinOrderByAggregateInput
    _sum?: pessoaSumOrderByAggregateInput
  }

  export type pessoaScalarWhereWithAggregatesInput = {
    AND?: pessoaScalarWhereWithAggregatesInput | pessoaScalarWhereWithAggregatesInput[]
    OR?: pessoaScalarWhereWithAggregatesInput[]
    NOT?: pessoaScalarWhereWithAggregatesInput | pessoaScalarWhereWithAggregatesInput[]
    codPessoa?: IntWithAggregatesFilter<"pessoa"> | number
    codEndereco?: IntNullableWithAggregatesFilter<"pessoa"> | number | null
    codNacionalidade?: IntNullableWithAggregatesFilter<"pessoa"> | number | null
    codContacto?: IntNullableWithAggregatesFilter<"pessoa"> | number | null
    nome?: StringWithAggregatesFilter<"pessoa"> | string
    genero?: Enumpessoa_generoWithAggregatesFilter<"pessoa"> | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilWithAggregatesFilter<"pessoa"> | $Enums.pessoa_estadoCivil
    dataCadastro?: StringNullableWithAggregatesFilter<"pessoa"> | string | null
    dataNascimento?: StringWithAggregatesFilter<"pessoa"> | string
    codBi?: IntWithAggregatesFilter<"pessoa"> | number
    senha?: StringWithAggregatesFilter<"pessoa"> | string
  }

  export type provinciaWhereInput = {
    AND?: provinciaWhereInput | provinciaWhereInput[]
    OR?: provinciaWhereInput[]
    NOT?: provinciaWhereInput | provinciaWhereInput[]
    idProvincia?: IntFilter<"provincia"> | number
    provincia?: StringFilter<"provincia"> | string
    municipio?: MunicipioListRelationFilter
  }

  export type provinciaOrderByWithRelationInput = {
    idProvincia?: SortOrder
    provincia?: SortOrder
    municipio?: municipioOrderByRelationAggregateInput
  }

  export type provinciaWhereUniqueInput = Prisma.AtLeast<{
    idProvincia?: number
    AND?: provinciaWhereInput | provinciaWhereInput[]
    OR?: provinciaWhereInput[]
    NOT?: provinciaWhereInput | provinciaWhereInput[]
    provincia?: StringFilter<"provincia"> | string
    municipio?: MunicipioListRelationFilter
  }, "idProvincia">

  export type provinciaOrderByWithAggregationInput = {
    idProvincia?: SortOrder
    provincia?: SortOrder
    _count?: provinciaCountOrderByAggregateInput
    _avg?: provinciaAvgOrderByAggregateInput
    _max?: provinciaMaxOrderByAggregateInput
    _min?: provinciaMinOrderByAggregateInput
    _sum?: provinciaSumOrderByAggregateInput
  }

  export type provinciaScalarWhereWithAggregatesInput = {
    AND?: provinciaScalarWhereWithAggregatesInput | provinciaScalarWhereWithAggregatesInput[]
    OR?: provinciaScalarWhereWithAggregatesInput[]
    NOT?: provinciaScalarWhereWithAggregatesInput | provinciaScalarWhereWithAggregatesInput[]
    idProvincia?: IntWithAggregatesFilter<"provincia"> | number
    provincia?: StringWithAggregatesFilter<"provincia"> | string
  }

  export type serivicoviaturaWhereInput = {
    AND?: serivicoviaturaWhereInput | serivicoviaturaWhereInput[]
    OR?: serivicoviaturaWhereInput[]
    NOT?: serivicoviaturaWhereInput | serivicoviaturaWhereInput[]
    codServicoViatura?: IntFilter<"serivicoviatura"> | number
    descServico?: StringFilter<"serivicoviatura"> | string
    livrete?: LivreteListRelationFilter
  }

  export type serivicoviaturaOrderByWithRelationInput = {
    codServicoViatura?: SortOrder
    descServico?: SortOrder
    livrete?: livreteOrderByRelationAggregateInput
  }

  export type serivicoviaturaWhereUniqueInput = Prisma.AtLeast<{
    codServicoViatura?: number
    AND?: serivicoviaturaWhereInput | serivicoviaturaWhereInput[]
    OR?: serivicoviaturaWhereInput[]
    NOT?: serivicoviaturaWhereInput | serivicoviaturaWhereInput[]
    descServico?: StringFilter<"serivicoviatura"> | string
    livrete?: LivreteListRelationFilter
  }, "codServicoViatura">

  export type serivicoviaturaOrderByWithAggregationInput = {
    codServicoViatura?: SortOrder
    descServico?: SortOrder
    _count?: serivicoviaturaCountOrderByAggregateInput
    _avg?: serivicoviaturaAvgOrderByAggregateInput
    _max?: serivicoviaturaMaxOrderByAggregateInput
    _min?: serivicoviaturaMinOrderByAggregateInput
    _sum?: serivicoviaturaSumOrderByAggregateInput
  }

  export type serivicoviaturaScalarWhereWithAggregatesInput = {
    AND?: serivicoviaturaScalarWhereWithAggregatesInput | serivicoviaturaScalarWhereWithAggregatesInput[]
    OR?: serivicoviaturaScalarWhereWithAggregatesInput[]
    NOT?: serivicoviaturaScalarWhereWithAggregatesInput | serivicoviaturaScalarWhereWithAggregatesInput[]
    codServicoViatura?: IntWithAggregatesFilter<"serivicoviatura"> | number
    descServico?: StringWithAggregatesFilter<"serivicoviatura"> | string
  }

  export type tipoinfracaoWhereInput = {
    AND?: tipoinfracaoWhereInput | tipoinfracaoWhereInput[]
    OR?: tipoinfracaoWhereInput[]
    NOT?: tipoinfracaoWhereInput | tipoinfracaoWhereInput[]
    codTipoInfracao?: IntFilter<"tipoinfracao"> | number
    descTipoInfracao?: StringFilter<"tipoinfracao"> | string
    valorInfracao?: StringFilter<"tipoinfracao"> | string
    infracao?: InfracaoListRelationFilter
  }

  export type tipoinfracaoOrderByWithRelationInput = {
    codTipoInfracao?: SortOrder
    descTipoInfracao?: SortOrder
    valorInfracao?: SortOrder
    infracao?: infracaoOrderByRelationAggregateInput
  }

  export type tipoinfracaoWhereUniqueInput = Prisma.AtLeast<{
    codTipoInfracao?: number
    AND?: tipoinfracaoWhereInput | tipoinfracaoWhereInput[]
    OR?: tipoinfracaoWhereInput[]
    NOT?: tipoinfracaoWhereInput | tipoinfracaoWhereInput[]
    descTipoInfracao?: StringFilter<"tipoinfracao"> | string
    valorInfracao?: StringFilter<"tipoinfracao"> | string
    infracao?: InfracaoListRelationFilter
  }, "codTipoInfracao">

  export type tipoinfracaoOrderByWithAggregationInput = {
    codTipoInfracao?: SortOrder
    descTipoInfracao?: SortOrder
    valorInfracao?: SortOrder
    _count?: tipoinfracaoCountOrderByAggregateInput
    _avg?: tipoinfracaoAvgOrderByAggregateInput
    _max?: tipoinfracaoMaxOrderByAggregateInput
    _min?: tipoinfracaoMinOrderByAggregateInput
    _sum?: tipoinfracaoSumOrderByAggregateInput
  }

  export type tipoinfracaoScalarWhereWithAggregatesInput = {
    AND?: tipoinfracaoScalarWhereWithAggregatesInput | tipoinfracaoScalarWhereWithAggregatesInput[]
    OR?: tipoinfracaoScalarWhereWithAggregatesInput[]
    NOT?: tipoinfracaoScalarWhereWithAggregatesInput | tipoinfracaoScalarWhereWithAggregatesInput[]
    codTipoInfracao?: IntWithAggregatesFilter<"tipoinfracao"> | number
    descTipoInfracao?: StringWithAggregatesFilter<"tipoinfracao"> | string
    valorInfracao?: StringWithAggregatesFilter<"tipoinfracao"> | string
  }

  export type tiporouboWhereInput = {
    AND?: tiporouboWhereInput | tiporouboWhereInput[]
    OR?: tiporouboWhereInput[]
    NOT?: tiporouboWhereInput | tiporouboWhereInput[]
    codTipoRoubo?: IntFilter<"tiporoubo"> | number
    descTipoRoubo?: StringFilter<"tiporoubo"> | string
    alertaroubo?: AlertarouboListRelationFilter
  }

  export type tiporouboOrderByWithRelationInput = {
    codTipoRoubo?: SortOrder
    descTipoRoubo?: SortOrder
    alertaroubo?: alertarouboOrderByRelationAggregateInput
  }

  export type tiporouboWhereUniqueInput = Prisma.AtLeast<{
    codTipoRoubo?: number
    AND?: tiporouboWhereInput | tiporouboWhereInput[]
    OR?: tiporouboWhereInput[]
    NOT?: tiporouboWhereInput | tiporouboWhereInput[]
    descTipoRoubo?: StringFilter<"tiporoubo"> | string
    alertaroubo?: AlertarouboListRelationFilter
  }, "codTipoRoubo">

  export type tiporouboOrderByWithAggregationInput = {
    codTipoRoubo?: SortOrder
    descTipoRoubo?: SortOrder
    _count?: tiporouboCountOrderByAggregateInput
    _avg?: tiporouboAvgOrderByAggregateInput
    _max?: tiporouboMaxOrderByAggregateInput
    _min?: tiporouboMinOrderByAggregateInput
    _sum?: tiporouboSumOrderByAggregateInput
  }

  export type tiporouboScalarWhereWithAggregatesInput = {
    AND?: tiporouboScalarWhereWithAggregatesInput | tiporouboScalarWhereWithAggregatesInput[]
    OR?: tiporouboScalarWhereWithAggregatesInput[]
    NOT?: tiporouboScalarWhereWithAggregatesInput | tiporouboScalarWhereWithAggregatesInput[]
    codTipoRoubo?: IntWithAggregatesFilter<"tiporoubo"> | number
    descTipoRoubo?: StringWithAggregatesFilter<"tiporoubo"> | string
  }

  export type titulopropriedadeWhereInput = {
    AND?: titulopropriedadeWhereInput | titulopropriedadeWhereInput[]
    OR?: titulopropriedadeWhereInput[]
    NOT?: titulopropriedadeWhereInput | titulopropriedadeWhereInput[]
    codTituloPropriedade?: IntFilter<"titulopropriedade"> | number
    codPessoa?: IntFilter<"titulopropriedade"> | number
    dataEmissao?: DateTimeFilter<"titulopropriedade"> | Date | string
    dataPrimeiroRegistro?: DateTimeFilter<"titulopropriedade"> | Date | string
    numeroEmissao?: StringFilter<"titulopropriedade"> | string
    codViatura?: IntFilter<"titulopropriedade"> | number
    codFicheiroTituloPropriedade?: IntFilter<"titulopropriedade"> | number
    pessoa?: XOR<PessoaRelationFilter, pessoaWhereInput>
    viatura?: XOR<ViaturaRelationFilter, viaturaWhereInput>
    ficheiro?: XOR<FicheiroRelationFilter, ficheiroWhereInput>
  }

  export type titulopropriedadeOrderByWithRelationInput = {
    codTituloPropriedade?: SortOrder
    codPessoa?: SortOrder
    dataEmissao?: SortOrder
    dataPrimeiroRegistro?: SortOrder
    numeroEmissao?: SortOrder
    codViatura?: SortOrder
    codFicheiroTituloPropriedade?: SortOrder
    pessoa?: pessoaOrderByWithRelationInput
    viatura?: viaturaOrderByWithRelationInput
    ficheiro?: ficheiroOrderByWithRelationInput
  }

  export type titulopropriedadeWhereUniqueInput = Prisma.AtLeast<{
    codTituloPropriedade?: number
    AND?: titulopropriedadeWhereInput | titulopropriedadeWhereInput[]
    OR?: titulopropriedadeWhereInput[]
    NOT?: titulopropriedadeWhereInput | titulopropriedadeWhereInput[]
    codPessoa?: IntFilter<"titulopropriedade"> | number
    dataEmissao?: DateTimeFilter<"titulopropriedade"> | Date | string
    dataPrimeiroRegistro?: DateTimeFilter<"titulopropriedade"> | Date | string
    numeroEmissao?: StringFilter<"titulopropriedade"> | string
    codViatura?: IntFilter<"titulopropriedade"> | number
    codFicheiroTituloPropriedade?: IntFilter<"titulopropriedade"> | number
    pessoa?: XOR<PessoaRelationFilter, pessoaWhereInput>
    viatura?: XOR<ViaturaRelationFilter, viaturaWhereInput>
    ficheiro?: XOR<FicheiroRelationFilter, ficheiroWhereInput>
  }, "codTituloPropriedade">

  export type titulopropriedadeOrderByWithAggregationInput = {
    codTituloPropriedade?: SortOrder
    codPessoa?: SortOrder
    dataEmissao?: SortOrder
    dataPrimeiroRegistro?: SortOrder
    numeroEmissao?: SortOrder
    codViatura?: SortOrder
    codFicheiroTituloPropriedade?: SortOrder
    _count?: titulopropriedadeCountOrderByAggregateInput
    _avg?: titulopropriedadeAvgOrderByAggregateInput
    _max?: titulopropriedadeMaxOrderByAggregateInput
    _min?: titulopropriedadeMinOrderByAggregateInput
    _sum?: titulopropriedadeSumOrderByAggregateInput
  }

  export type titulopropriedadeScalarWhereWithAggregatesInput = {
    AND?: titulopropriedadeScalarWhereWithAggregatesInput | titulopropriedadeScalarWhereWithAggregatesInput[]
    OR?: titulopropriedadeScalarWhereWithAggregatesInput[]
    NOT?: titulopropriedadeScalarWhereWithAggregatesInput | titulopropriedadeScalarWhereWithAggregatesInput[]
    codTituloPropriedade?: IntWithAggregatesFilter<"titulopropriedade"> | number
    codPessoa?: IntWithAggregatesFilter<"titulopropriedade"> | number
    dataEmissao?: DateTimeWithAggregatesFilter<"titulopropriedade"> | Date | string
    dataPrimeiroRegistro?: DateTimeWithAggregatesFilter<"titulopropriedade"> | Date | string
    numeroEmissao?: StringWithAggregatesFilter<"titulopropriedade"> | string
    codViatura?: IntWithAggregatesFilter<"titulopropriedade"> | number
    codFicheiroTituloPropriedade?: IntWithAggregatesFilter<"titulopropriedade"> | number
  }

  export type viaturaWhereInput = {
    AND?: viaturaWhereInput | viaturaWhereInput[]
    OR?: viaturaWhereInput[]
    NOT?: viaturaWhereInput | viaturaWhereInput[]
    codViatura?: IntFilter<"viatura"> | number
    numeroMatricula?: StringFilter<"viatura"> | string
    alertaroubo?: AlertarouboListRelationFilter
    livrete?: LivreteListRelationFilter
    multa?: MultaListRelationFilter
    titulopropriedade?: TitulopropriedadeListRelationFilter
  }

  export type viaturaOrderByWithRelationInput = {
    codViatura?: SortOrder
    numeroMatricula?: SortOrder
    alertaroubo?: alertarouboOrderByRelationAggregateInput
    livrete?: livreteOrderByRelationAggregateInput
    multa?: multaOrderByRelationAggregateInput
    titulopropriedade?: titulopropriedadeOrderByRelationAggregateInput
  }

  export type viaturaWhereUniqueInput = Prisma.AtLeast<{
    codViatura?: number
    AND?: viaturaWhereInput | viaturaWhereInput[]
    OR?: viaturaWhereInput[]
    NOT?: viaturaWhereInput | viaturaWhereInput[]
    numeroMatricula?: StringFilter<"viatura"> | string
    alertaroubo?: AlertarouboListRelationFilter
    livrete?: LivreteListRelationFilter
    multa?: MultaListRelationFilter
    titulopropriedade?: TitulopropriedadeListRelationFilter
  }, "codViatura">

  export type viaturaOrderByWithAggregationInput = {
    codViatura?: SortOrder
    numeroMatricula?: SortOrder
    _count?: viaturaCountOrderByAggregateInput
    _avg?: viaturaAvgOrderByAggregateInput
    _max?: viaturaMaxOrderByAggregateInput
    _min?: viaturaMinOrderByAggregateInput
    _sum?: viaturaSumOrderByAggregateInput
  }

  export type viaturaScalarWhereWithAggregatesInput = {
    AND?: viaturaScalarWhereWithAggregatesInput | viaturaScalarWhereWithAggregatesInput[]
    OR?: viaturaScalarWhereWithAggregatesInput[]
    NOT?: viaturaScalarWhereWithAggregatesInput | viaturaScalarWhereWithAggregatesInput[]
    codViatura?: IntWithAggregatesFilter<"viatura"> | number
    numeroMatricula?: StringWithAggregatesFilter<"viatura"> | string
  }

  export type alertarouboCreateInput = {
    dataRoubo: Date | string
    enderecoRoubo: string
    descRoubo: string
    automobilista: automobilistaCreateNestedOneWithoutAlertarouboInput
    tiporoubo: tiporouboCreateNestedOneWithoutAlertarouboInput
    viatura: viaturaCreateNestedOneWithoutAlertarouboInput
  }

  export type alertarouboUncheckedCreateInput = {
    codAlertaRoubo?: number
    codAutomobilista: number
    codViatura: number
    dataRoubo: Date | string
    enderecoRoubo: string
    codTipoRoubo: number
    descRoubo: string
  }

  export type alertarouboUpdateInput = {
    dataRoubo?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoRoubo?: StringFieldUpdateOperationsInput | string
    descRoubo?: StringFieldUpdateOperationsInput | string
    automobilista?: automobilistaUpdateOneRequiredWithoutAlertarouboNestedInput
    tiporoubo?: tiporouboUpdateOneRequiredWithoutAlertarouboNestedInput
    viatura?: viaturaUpdateOneRequiredWithoutAlertarouboNestedInput
  }

  export type alertarouboUncheckedUpdateInput = {
    codAlertaRoubo?: IntFieldUpdateOperationsInput | number
    codAutomobilista?: IntFieldUpdateOperationsInput | number
    codViatura?: IntFieldUpdateOperationsInput | number
    dataRoubo?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoRoubo?: StringFieldUpdateOperationsInput | string
    codTipoRoubo?: IntFieldUpdateOperationsInput | number
    descRoubo?: StringFieldUpdateOperationsInput | string
  }

  export type alertarouboCreateManyInput = {
    codAlertaRoubo?: number
    codAutomobilista: number
    codViatura: number
    dataRoubo: Date | string
    enderecoRoubo: string
    codTipoRoubo: number
    descRoubo: string
  }

  export type alertarouboUpdateManyMutationInput = {
    dataRoubo?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoRoubo?: StringFieldUpdateOperationsInput | string
    descRoubo?: StringFieldUpdateOperationsInput | string
  }

  export type alertarouboUncheckedUpdateManyInput = {
    codAlertaRoubo?: IntFieldUpdateOperationsInput | number
    codAutomobilista?: IntFieldUpdateOperationsInput | number
    codViatura?: IntFieldUpdateOperationsInput | number
    dataRoubo?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoRoubo?: StringFieldUpdateOperationsInput | string
    codTipoRoubo?: IntFieldUpdateOperationsInput | number
    descRoubo?: StringFieldUpdateOperationsInput | string
  }

  export type automobilistaCreateInput = {
    alertaroubo?: alertarouboCreateNestedManyWithoutAutomobilistaInput
    cartaconducao: cartaconducaoCreateNestedOneWithoutAutomobilistaInput
    pessoa: pessoaCreateNestedOneWithoutAutomobilistaInput
    multa?: multaCreateNestedManyWithoutAutomobilistaInput
  }

  export type automobilistaUncheckedCreateInput = {
    codAutomobilista?: number
    codCartaConducao: number
    codPessoa: number
    alertaroubo?: alertarouboUncheckedCreateNestedManyWithoutAutomobilistaInput
    multa?: multaUncheckedCreateNestedManyWithoutAutomobilistaInput
  }

  export type automobilistaUpdateInput = {
    alertaroubo?: alertarouboUpdateManyWithoutAutomobilistaNestedInput
    cartaconducao?: cartaconducaoUpdateOneRequiredWithoutAutomobilistaNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutAutomobilistaNestedInput
    multa?: multaUpdateManyWithoutAutomobilistaNestedInput
  }

  export type automobilistaUncheckedUpdateInput = {
    codAutomobilista?: IntFieldUpdateOperationsInput | number
    codCartaConducao?: IntFieldUpdateOperationsInput | number
    codPessoa?: IntFieldUpdateOperationsInput | number
    alertaroubo?: alertarouboUncheckedUpdateManyWithoutAutomobilistaNestedInput
    multa?: multaUncheckedUpdateManyWithoutAutomobilistaNestedInput
  }

  export type automobilistaCreateManyInput = {
    codAutomobilista?: number
    codCartaConducao: number
    codPessoa: number
  }

  export type automobilistaUpdateManyMutationInput = {

  }

  export type automobilistaUncheckedUpdateManyInput = {
    codAutomobilista?: IntFieldUpdateOperationsInput | number
    codCartaConducao?: IntFieldUpdateOperationsInput | number
    codPessoa?: IntFieldUpdateOperationsInput | number
  }

  export type biCreateInput = {
    dataEmicaoBi: Date | string
    dataValidacaoBi: Date | string
    numeroBI: string
    ficheiro: ficheiroCreateNestedOneWithoutBiInput
    pessoa?: pessoaCreateNestedManyWithoutBiInput
  }

  export type biUncheckedCreateInput = {
    idBi?: number
    dataEmicaoBi: Date | string
    dataValidacaoBi: Date | string
    numeroBI: string
    codFicheiroBi: number
    pessoa?: pessoaUncheckedCreateNestedManyWithoutBiInput
  }

  export type biUpdateInput = {
    dataEmicaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidacaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroBI?: StringFieldUpdateOperationsInput | string
    ficheiro?: ficheiroUpdateOneRequiredWithoutBiNestedInput
    pessoa?: pessoaUpdateManyWithoutBiNestedInput
  }

  export type biUncheckedUpdateInput = {
    idBi?: IntFieldUpdateOperationsInput | number
    dataEmicaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidacaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroBI?: StringFieldUpdateOperationsInput | string
    codFicheiroBi?: IntFieldUpdateOperationsInput | number
    pessoa?: pessoaUncheckedUpdateManyWithoutBiNestedInput
  }

  export type biCreateManyInput = {
    idBi?: number
    dataEmicaoBi: Date | string
    dataValidacaoBi: Date | string
    numeroBI: string
    codFicheiroBi: number
  }

  export type biUpdateManyMutationInput = {
    dataEmicaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidacaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroBI?: StringFieldUpdateOperationsInput | string
  }

  export type biUncheckedUpdateManyInput = {
    idBi?: IntFieldUpdateOperationsInput | number
    dataEmicaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidacaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroBI?: StringFieldUpdateOperationsInput | string
    codFicheiroBi?: IntFieldUpdateOperationsInput | number
  }

  export type cartaconducaoCreateInput = {
    dataEmissao: Date | string
    dataValidade: Date | string
    numeroVia: string
    numeroCarta: number
    dataPrimeiraEmissao: Date | string
    localEmissao: number
    automobilista?: automobilistaCreateNestedManyWithoutCartaconducaoInput
    categoriacarta: categoriacartaCreateNestedOneWithoutCartaconducaoInput
    ficheiro: ficheiroCreateNestedOneWithoutCartaconducaoInput
  }

  export type cartaconducaoUncheckedCreateInput = {
    codCartaConducao?: number
    dataEmissao: Date | string
    dataValidade: Date | string
    numeroVia: string
    codCategoriaCarta: number
    numeroCarta: number
    dataPrimeiraEmissao: Date | string
    localEmissao: number
    codFicheiroCartaConducao: number
    automobilista?: automobilistaUncheckedCreateNestedManyWithoutCartaconducaoInput
  }

  export type cartaconducaoUpdateInput = {
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroVia?: StringFieldUpdateOperationsInput | string
    numeroCarta?: IntFieldUpdateOperationsInput | number
    dataPrimeiraEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    localEmissao?: IntFieldUpdateOperationsInput | number
    automobilista?: automobilistaUpdateManyWithoutCartaconducaoNestedInput
    categoriacarta?: categoriacartaUpdateOneRequiredWithoutCartaconducaoNestedInput
    ficheiro?: ficheiroUpdateOneRequiredWithoutCartaconducaoNestedInput
  }

  export type cartaconducaoUncheckedUpdateInput = {
    codCartaConducao?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroVia?: StringFieldUpdateOperationsInput | string
    codCategoriaCarta?: IntFieldUpdateOperationsInput | number
    numeroCarta?: IntFieldUpdateOperationsInput | number
    dataPrimeiraEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    localEmissao?: IntFieldUpdateOperationsInput | number
    codFicheiroCartaConducao?: IntFieldUpdateOperationsInput | number
    automobilista?: automobilistaUncheckedUpdateManyWithoutCartaconducaoNestedInput
  }

  export type cartaconducaoCreateManyInput = {
    codCartaConducao?: number
    dataEmissao: Date | string
    dataValidade: Date | string
    numeroVia: string
    codCategoriaCarta: number
    numeroCarta: number
    dataPrimeiraEmissao: Date | string
    localEmissao: number
    codFicheiroCartaConducao: number
  }

  export type cartaconducaoUpdateManyMutationInput = {
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroVia?: StringFieldUpdateOperationsInput | string
    numeroCarta?: IntFieldUpdateOperationsInput | number
    dataPrimeiraEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    localEmissao?: IntFieldUpdateOperationsInput | number
  }

  export type cartaconducaoUncheckedUpdateManyInput = {
    codCartaConducao?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroVia?: StringFieldUpdateOperationsInput | string
    codCategoriaCarta?: IntFieldUpdateOperationsInput | number
    numeroCarta?: IntFieldUpdateOperationsInput | number
    dataPrimeiraEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    localEmissao?: IntFieldUpdateOperationsInput | number
    codFicheiroCartaConducao?: IntFieldUpdateOperationsInput | number
  }

  export type categoriacartaCreateInput = {
    descCategoriaCarta: string
    sigla: string
    cartaconducao?: cartaconducaoCreateNestedManyWithoutCategoriacartaInput
  }

  export type categoriacartaUncheckedCreateInput = {
    codCategoriaCarta?: number
    descCategoriaCarta: string
    sigla: string
    cartaconducao?: cartaconducaoUncheckedCreateNestedManyWithoutCategoriacartaInput
  }

  export type categoriacartaUpdateInput = {
    descCategoriaCarta?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    cartaconducao?: cartaconducaoUpdateManyWithoutCategoriacartaNestedInput
  }

  export type categoriacartaUncheckedUpdateInput = {
    codCategoriaCarta?: IntFieldUpdateOperationsInput | number
    descCategoriaCarta?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    cartaconducao?: cartaconducaoUncheckedUpdateManyWithoutCategoriacartaNestedInput
  }

  export type categoriacartaCreateManyInput = {
    codCategoriaCarta?: number
    descCategoriaCarta: string
    sigla: string
  }

  export type categoriacartaUpdateManyMutationInput = {
    descCategoriaCarta?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
  }

  export type categoriacartaUncheckedUpdateManyInput = {
    codCategoriaCarta?: IntFieldUpdateOperationsInput | number
    descCategoriaCarta?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
  }

  export type contactoCreateInput = {
    contacto1: string
    contacto2?: string | null
    email1?: string | null
    email2?: string | null
    pessoa?: pessoaCreateNestedManyWithoutContactoInput
  }

  export type contactoUncheckedCreateInput = {
    idContacto?: number
    contacto1: string
    contacto2?: string | null
    email1?: string | null
    email2?: string | null
    pessoa?: pessoaUncheckedCreateNestedManyWithoutContactoInput
  }

  export type contactoUpdateInput = {
    contacto1?: StringFieldUpdateOperationsInput | string
    contacto2?: NullableStringFieldUpdateOperationsInput | string | null
    email1?: NullableStringFieldUpdateOperationsInput | string | null
    email2?: NullableStringFieldUpdateOperationsInput | string | null
    pessoa?: pessoaUpdateManyWithoutContactoNestedInput
  }

  export type contactoUncheckedUpdateInput = {
    idContacto?: IntFieldUpdateOperationsInput | number
    contacto1?: StringFieldUpdateOperationsInput | string
    contacto2?: NullableStringFieldUpdateOperationsInput | string | null
    email1?: NullableStringFieldUpdateOperationsInput | string | null
    email2?: NullableStringFieldUpdateOperationsInput | string | null
    pessoa?: pessoaUncheckedUpdateManyWithoutContactoNestedInput
  }

  export type contactoCreateManyInput = {
    idContacto?: number
    contacto1: string
    contacto2?: string | null
    email1?: string | null
    email2?: string | null
  }

  export type contactoUpdateManyMutationInput = {
    contacto1?: StringFieldUpdateOperationsInput | string
    contacto2?: NullableStringFieldUpdateOperationsInput | string | null
    email1?: NullableStringFieldUpdateOperationsInput | string | null
    email2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contactoUncheckedUpdateManyInput = {
    idContacto?: IntFieldUpdateOperationsInput | number
    contacto1?: StringFieldUpdateOperationsInput | string
    contacto2?: NullableStringFieldUpdateOperationsInput | string | null
    email1?: NullableStringFieldUpdateOperationsInput | string | null
    email2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type enderecoCreateInput = {
    descricaoEndereco: string
    municipio: municipioCreateNestedOneWithoutEnderecoInput
    pessoa?: pessoaCreateNestedManyWithoutEnderecoInput
  }

  export type enderecoUncheckedCreateInput = {
    idEndereco?: number
    idMunicipio: number
    descricaoEndereco: string
    pessoa?: pessoaUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type enderecoUpdateInput = {
    descricaoEndereco?: StringFieldUpdateOperationsInput | string
    municipio?: municipioUpdateOneRequiredWithoutEnderecoNestedInput
    pessoa?: pessoaUpdateManyWithoutEnderecoNestedInput
  }

  export type enderecoUncheckedUpdateInput = {
    idEndereco?: IntFieldUpdateOperationsInput | number
    idMunicipio?: IntFieldUpdateOperationsInput | number
    descricaoEndereco?: StringFieldUpdateOperationsInput | string
    pessoa?: pessoaUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type enderecoCreateManyInput = {
    idEndereco?: number
    idMunicipio: number
    descricaoEndereco: string
  }

  export type enderecoUpdateManyMutationInput = {
    descricaoEndereco?: StringFieldUpdateOperationsInput | string
  }

  export type enderecoUncheckedUpdateManyInput = {
    idEndereco?: IntFieldUpdateOperationsInput | number
    idMunicipio?: IntFieldUpdateOperationsInput | number
    descricaoEndereco?: StringFieldUpdateOperationsInput | string
  }

  export type ficheiroCreateInput = {
    nomeFicheiro: string
    dataEntrada?: string | null
    dataValidacao?: string | null
    estadoValidacao?: $Enums.ficheiro_estadoValidacao | null
    bi?: biCreateNestedManyWithoutFicheiroInput
    cartaconducao?: cartaconducaoCreateNestedManyWithoutFicheiroInput
    funcionario?: funcionarioCreateNestedManyWithoutFicheiroInput
    pagamentomulta?: pagamentomultaCreateNestedManyWithoutFicheiroInput
    titulopropriedade?: titulopropriedadeCreateNestedManyWithoutFicheiroInput
  }

  export type ficheiroUncheckedCreateInput = {
    idFicheiro?: number
    nomeFicheiro: string
    dataEntrada?: string | null
    dataValidacao?: string | null
    estadoValidacao?: $Enums.ficheiro_estadoValidacao | null
    bi?: biUncheckedCreateNestedManyWithoutFicheiroInput
    cartaconducao?: cartaconducaoUncheckedCreateNestedManyWithoutFicheiroInput
    funcionario?: funcionarioUncheckedCreateNestedManyWithoutFicheiroInput
    pagamentomulta?: pagamentomultaUncheckedCreateNestedManyWithoutFicheiroInput
    titulopropriedade?: titulopropriedadeUncheckedCreateNestedManyWithoutFicheiroInput
  }

  export type ficheiroUpdateInput = {
    nomeFicheiro?: StringFieldUpdateOperationsInput | string
    dataEntrada?: NullableStringFieldUpdateOperationsInput | string | null
    dataValidacao?: NullableStringFieldUpdateOperationsInput | string | null
    estadoValidacao?: NullableEnumficheiro_estadoValidacaoFieldUpdateOperationsInput | $Enums.ficheiro_estadoValidacao | null
    bi?: biUpdateManyWithoutFicheiroNestedInput
    cartaconducao?: cartaconducaoUpdateManyWithoutFicheiroNestedInput
    funcionario?: funcionarioUpdateManyWithoutFicheiroNestedInput
    pagamentomulta?: pagamentomultaUpdateManyWithoutFicheiroNestedInput
    titulopropriedade?: titulopropriedadeUpdateManyWithoutFicheiroNestedInput
  }

  export type ficheiroUncheckedUpdateInput = {
    idFicheiro?: IntFieldUpdateOperationsInput | number
    nomeFicheiro?: StringFieldUpdateOperationsInput | string
    dataEntrada?: NullableStringFieldUpdateOperationsInput | string | null
    dataValidacao?: NullableStringFieldUpdateOperationsInput | string | null
    estadoValidacao?: NullableEnumficheiro_estadoValidacaoFieldUpdateOperationsInput | $Enums.ficheiro_estadoValidacao | null
    bi?: biUncheckedUpdateManyWithoutFicheiroNestedInput
    cartaconducao?: cartaconducaoUncheckedUpdateManyWithoutFicheiroNestedInput
    funcionario?: funcionarioUncheckedUpdateManyWithoutFicheiroNestedInput
    pagamentomulta?: pagamentomultaUncheckedUpdateManyWithoutFicheiroNestedInput
    titulopropriedade?: titulopropriedadeUncheckedUpdateManyWithoutFicheiroNestedInput
  }

  export type ficheiroCreateManyInput = {
    idFicheiro?: number
    nomeFicheiro: string
    dataEntrada?: string | null
    dataValidacao?: string | null
    estadoValidacao?: $Enums.ficheiro_estadoValidacao | null
  }

  export type ficheiroUpdateManyMutationInput = {
    nomeFicheiro?: StringFieldUpdateOperationsInput | string
    dataEntrada?: NullableStringFieldUpdateOperationsInput | string | null
    dataValidacao?: NullableStringFieldUpdateOperationsInput | string | null
    estadoValidacao?: NullableEnumficheiro_estadoValidacaoFieldUpdateOperationsInput | $Enums.ficheiro_estadoValidacao | null
  }

  export type ficheiroUncheckedUpdateManyInput = {
    idFicheiro?: IntFieldUpdateOperationsInput | number
    nomeFicheiro?: StringFieldUpdateOperationsInput | string
    dataEntrada?: NullableStringFieldUpdateOperationsInput | string | null
    dataValidacao?: NullableStringFieldUpdateOperationsInput | string | null
    estadoValidacao?: NullableEnumficheiro_estadoValidacaoFieldUpdateOperationsInput | $Enums.ficheiro_estadoValidacao | null
  }

  export type funcionarioCreateInput = {
    codficheiroFotoPendente?: number | null
    numeroAgente?: string | null
    senha?: number
    ficheiro: ficheiroCreateNestedOneWithoutFuncionarioInput
    pessoa: pessoaCreateNestedOneWithoutFuncionarioInput
  }

  export type funcionarioUncheckedCreateInput = {
    codFuncionario?: number
    codPessoa: number
    codficheiroFotoPerfil: number
    codficheiroFotoPendente?: number | null
    numeroAgente?: string | null
    senha?: number
  }

  export type funcionarioUpdateInput = {
    codficheiroFotoPendente?: NullableIntFieldUpdateOperationsInput | number | null
    numeroAgente?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: IntFieldUpdateOperationsInput | number
    ficheiro?: ficheiroUpdateOneRequiredWithoutFuncionarioNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutFuncionarioNestedInput
  }

  export type funcionarioUncheckedUpdateInput = {
    codFuncionario?: IntFieldUpdateOperationsInput | number
    codPessoa?: IntFieldUpdateOperationsInput | number
    codficheiroFotoPerfil?: IntFieldUpdateOperationsInput | number
    codficheiroFotoPendente?: NullableIntFieldUpdateOperationsInput | number | null
    numeroAgente?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: IntFieldUpdateOperationsInput | number
  }

  export type funcionarioCreateManyInput = {
    codFuncionario?: number
    codPessoa: number
    codficheiroFotoPerfil: number
    codficheiroFotoPendente?: number | null
    numeroAgente?: string | null
    senha?: number
  }

  export type funcionarioUpdateManyMutationInput = {
    codficheiroFotoPendente?: NullableIntFieldUpdateOperationsInput | number | null
    numeroAgente?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: IntFieldUpdateOperationsInput | number
  }

  export type funcionarioUncheckedUpdateManyInput = {
    codFuncionario?: IntFieldUpdateOperationsInput | number
    codPessoa?: IntFieldUpdateOperationsInput | number
    codficheiroFotoPerfil?: IntFieldUpdateOperationsInput | number
    codficheiroFotoPendente?: NullableIntFieldUpdateOperationsInput | number | null
    numeroAgente?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: IntFieldUpdateOperationsInput | number
  }

  export type infracaoCreateInput = {
    multa_infracao_codMultaTomulta: multaCreateNestedOneWithoutInfracao_infracao_codMultaTomultaInput
    tipoinfracao: tipoinfracaoCreateNestedOneWithoutInfracaoInput
    multa_multa_codInfracaoToinfracao?: multaCreateNestedManyWithoutInfracao_multa_codInfracaoToinfracaoInput
  }

  export type infracaoUncheckedCreateInput = {
    codInfracao?: number
    codMulta: number
    codTipoInfracao: number
    multa_multa_codInfracaoToinfracao?: multaUncheckedCreateNestedManyWithoutInfracao_multa_codInfracaoToinfracaoInput
  }

  export type infracaoUpdateInput = {
    multa_infracao_codMultaTomulta?: multaUpdateOneRequiredWithoutInfracao_infracao_codMultaTomultaNestedInput
    tipoinfracao?: tipoinfracaoUpdateOneRequiredWithoutInfracaoNestedInput
    multa_multa_codInfracaoToinfracao?: multaUpdateManyWithoutInfracao_multa_codInfracaoToinfracaoNestedInput
  }

  export type infracaoUncheckedUpdateInput = {
    codInfracao?: IntFieldUpdateOperationsInput | number
    codMulta?: IntFieldUpdateOperationsInput | number
    codTipoInfracao?: IntFieldUpdateOperationsInput | number
    multa_multa_codInfracaoToinfracao?: multaUncheckedUpdateManyWithoutInfracao_multa_codInfracaoToinfracaoNestedInput
  }

  export type infracaoCreateManyInput = {
    codInfracao?: number
    codMulta: number
    codTipoInfracao: number
  }

  export type infracaoUpdateManyMutationInput = {

  }

  export type infracaoUncheckedUpdateManyInput = {
    codInfracao?: IntFieldUpdateOperationsInput | number
    codMulta?: IntFieldUpdateOperationsInput | number
    codTipoInfracao?: IntFieldUpdateOperationsInput | number
  }

  export type livreteCreateInput = {
    numeroQuadro: string
    corViatura: string
    MedidasPneumaticos: string
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    lotacao: string
    cilindrada: string
    numeroCilindro: string
    conbustivel: string
    peso: string
    tara: string
    tipoCaixa: string
    distanciaEixo: string
    modelo: string
    marca: marcaCreateNestedOneWithoutLivreteInput
    viatura: viaturaCreateNestedOneWithoutLivreteInput
    serivicoviatura: serivicoviaturaCreateNestedOneWithoutLivreteInput
  }

  export type livreteUncheckedCreateInput = {
    codLivrete?: number
    codViatura: number
    numeroQuadro: string
    corViatura: string
    MedidasPneumaticos: string
    codServico: number
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    lotacao: string
    cilindrada: string
    numeroCilindro: string
    conbustivel: string
    peso: string
    tara: string
    tipoCaixa: string
    distanciaEixo: string
    modelo: string
    codMarca: number
  }

  export type livreteUpdateInput = {
    numeroQuadro?: StringFieldUpdateOperationsInput | string
    corViatura?: StringFieldUpdateOperationsInput | string
    MedidasPneumaticos?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    lotacao?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    numeroCilindro?: StringFieldUpdateOperationsInput | string
    conbustivel?: StringFieldUpdateOperationsInput | string
    peso?: StringFieldUpdateOperationsInput | string
    tara?: StringFieldUpdateOperationsInput | string
    tipoCaixa?: StringFieldUpdateOperationsInput | string
    distanciaEixo?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    marca?: marcaUpdateOneRequiredWithoutLivreteNestedInput
    viatura?: viaturaUpdateOneRequiredWithoutLivreteNestedInput
    serivicoviatura?: serivicoviaturaUpdateOneRequiredWithoutLivreteNestedInput
  }

  export type livreteUncheckedUpdateInput = {
    codLivrete?: IntFieldUpdateOperationsInput | number
    codViatura?: IntFieldUpdateOperationsInput | number
    numeroQuadro?: StringFieldUpdateOperationsInput | string
    corViatura?: StringFieldUpdateOperationsInput | string
    MedidasPneumaticos?: StringFieldUpdateOperationsInput | string
    codServico?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    lotacao?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    numeroCilindro?: StringFieldUpdateOperationsInput | string
    conbustivel?: StringFieldUpdateOperationsInput | string
    peso?: StringFieldUpdateOperationsInput | string
    tara?: StringFieldUpdateOperationsInput | string
    tipoCaixa?: StringFieldUpdateOperationsInput | string
    distanciaEixo?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    codMarca?: IntFieldUpdateOperationsInput | number
  }

  export type livreteCreateManyInput = {
    codLivrete?: number
    codViatura: number
    numeroQuadro: string
    corViatura: string
    MedidasPneumaticos: string
    codServico: number
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    lotacao: string
    cilindrada: string
    numeroCilindro: string
    conbustivel: string
    peso: string
    tara: string
    tipoCaixa: string
    distanciaEixo: string
    modelo: string
    codMarca: number
  }

  export type livreteUpdateManyMutationInput = {
    numeroQuadro?: StringFieldUpdateOperationsInput | string
    corViatura?: StringFieldUpdateOperationsInput | string
    MedidasPneumaticos?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    lotacao?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    numeroCilindro?: StringFieldUpdateOperationsInput | string
    conbustivel?: StringFieldUpdateOperationsInput | string
    peso?: StringFieldUpdateOperationsInput | string
    tara?: StringFieldUpdateOperationsInput | string
    tipoCaixa?: StringFieldUpdateOperationsInput | string
    distanciaEixo?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
  }

  export type livreteUncheckedUpdateManyInput = {
    codLivrete?: IntFieldUpdateOperationsInput | number
    codViatura?: IntFieldUpdateOperationsInput | number
    numeroQuadro?: StringFieldUpdateOperationsInput | string
    corViatura?: StringFieldUpdateOperationsInput | string
    MedidasPneumaticos?: StringFieldUpdateOperationsInput | string
    codServico?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    lotacao?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    numeroCilindro?: StringFieldUpdateOperationsInput | string
    conbustivel?: StringFieldUpdateOperationsInput | string
    peso?: StringFieldUpdateOperationsInput | string
    tara?: StringFieldUpdateOperationsInput | string
    tipoCaixa?: StringFieldUpdateOperationsInput | string
    distanciaEixo?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    codMarca?: IntFieldUpdateOperationsInput | number
  }

  export type marcaCreateInput = {
    descMarca: string
    livrete?: livreteCreateNestedManyWithoutMarcaInput
  }

  export type marcaUncheckedCreateInput = {
    codMarca?: number
    descMarca: string
    livrete?: livreteUncheckedCreateNestedManyWithoutMarcaInput
  }

  export type marcaUpdateInput = {
    descMarca?: StringFieldUpdateOperationsInput | string
    livrete?: livreteUpdateManyWithoutMarcaNestedInput
  }

  export type marcaUncheckedUpdateInput = {
    codMarca?: IntFieldUpdateOperationsInput | number
    descMarca?: StringFieldUpdateOperationsInput | string
    livrete?: livreteUncheckedUpdateManyWithoutMarcaNestedInput
  }

  export type marcaCreateManyInput = {
    codMarca?: number
    descMarca: string
  }

  export type marcaUpdateManyMutationInput = {
    descMarca?: StringFieldUpdateOperationsInput | string
  }

  export type marcaUncheckedUpdateManyInput = {
    codMarca?: IntFieldUpdateOperationsInput | number
    descMarca?: StringFieldUpdateOperationsInput | string
  }

  export type multaCreateInput = {
    valorMulta: string
    estadoMulta: $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoCreateNestedManyWithoutMulta_infracao_codMultaTomultaInput
    automobilista?: automobilistaCreateNestedOneWithoutMultaInput
    infracao_multa_codInfracaoToinfracao: infracaoCreateNestedOneWithoutMulta_multa_codInfracaoToinfracaoInput
    viatura?: viaturaCreateNestedOneWithoutMultaInput
    pagamentomulta?: pagamentomultaCreateNestedManyWithoutMultaInput
  }

  export type multaUncheckedCreateInput = {
    codMulta?: number
    codAutomobilista?: number | null
    CodViatura?: number | null
    codInfracao: number
    valorMulta: string
    estadoMulta: $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoUncheckedCreateNestedManyWithoutMulta_infracao_codMultaTomultaInput
    pagamentomulta?: pagamentomultaUncheckedCreateNestedManyWithoutMultaInput
  }

  export type multaUpdateInput = {
    valorMulta?: StringFieldUpdateOperationsInput | string
    estadoMulta?: Enummulta_estadoMultaFieldUpdateOperationsInput | $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoUpdateManyWithoutMulta_infracao_codMultaTomultaNestedInput
    automobilista?: automobilistaUpdateOneWithoutMultaNestedInput
    infracao_multa_codInfracaoToinfracao?: infracaoUpdateOneRequiredWithoutMulta_multa_codInfracaoToinfracaoNestedInput
    viatura?: viaturaUpdateOneWithoutMultaNestedInput
    pagamentomulta?: pagamentomultaUpdateManyWithoutMultaNestedInput
  }

  export type multaUncheckedUpdateInput = {
    codMulta?: IntFieldUpdateOperationsInput | number
    codAutomobilista?: NullableIntFieldUpdateOperationsInput | number | null
    CodViatura?: NullableIntFieldUpdateOperationsInput | number | null
    codInfracao?: IntFieldUpdateOperationsInput | number
    valorMulta?: StringFieldUpdateOperationsInput | string
    estadoMulta?: Enummulta_estadoMultaFieldUpdateOperationsInput | $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoUncheckedUpdateManyWithoutMulta_infracao_codMultaTomultaNestedInput
    pagamentomulta?: pagamentomultaUncheckedUpdateManyWithoutMultaNestedInput
  }

  export type multaCreateManyInput = {
    codMulta?: number
    codAutomobilista?: number | null
    CodViatura?: number | null
    codInfracao: number
    valorMulta: string
    estadoMulta: $Enums.multa_estadoMulta
  }

  export type multaUpdateManyMutationInput = {
    valorMulta?: StringFieldUpdateOperationsInput | string
    estadoMulta?: Enummulta_estadoMultaFieldUpdateOperationsInput | $Enums.multa_estadoMulta
  }

  export type multaUncheckedUpdateManyInput = {
    codMulta?: IntFieldUpdateOperationsInput | number
    codAutomobilista?: NullableIntFieldUpdateOperationsInput | number | null
    CodViatura?: NullableIntFieldUpdateOperationsInput | number | null
    codInfracao?: IntFieldUpdateOperationsInput | number
    valorMulta?: StringFieldUpdateOperationsInput | string
    estadoMulta?: Enummulta_estadoMultaFieldUpdateOperationsInput | $Enums.multa_estadoMulta
  }

  export type municipioCreateInput = {
    municipio: string
    endereco?: enderecoCreateNestedManyWithoutMunicipioInput
    provincia: provinciaCreateNestedOneWithoutMunicipioInput
  }

  export type municipioUncheckedCreateInput = {
    idMunicipio?: number
    idProvincia: number
    municipio: string
    endereco?: enderecoUncheckedCreateNestedManyWithoutMunicipioInput
  }

  export type municipioUpdateInput = {
    municipio?: StringFieldUpdateOperationsInput | string
    endereco?: enderecoUpdateManyWithoutMunicipioNestedInput
    provincia?: provinciaUpdateOneRequiredWithoutMunicipioNestedInput
  }

  export type municipioUncheckedUpdateInput = {
    idMunicipio?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    municipio?: StringFieldUpdateOperationsInput | string
    endereco?: enderecoUncheckedUpdateManyWithoutMunicipioNestedInput
  }

  export type municipioCreateManyInput = {
    idMunicipio?: number
    idProvincia: number
    municipio: string
  }

  export type municipioUpdateManyMutationInput = {
    municipio?: StringFieldUpdateOperationsInput | string
  }

  export type municipioUncheckedUpdateManyInput = {
    idMunicipio?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    municipio?: StringFieldUpdateOperationsInput | string
  }

  export type pagamentomultaCreateInput = {
    dataPagamento: Date | string
    valorPago: string
    descCodigoDeposito: string
    multa: multaCreateNestedOneWithoutPagamentomultaInput
    ficheiro: ficheiroCreateNestedOneWithoutPagamentomultaInput
  }

  export type pagamentomultaUncheckedCreateInput = {
    codPagamentoMulta?: number
    codMulta: number
    dataPagamento: Date | string
    valorPago: string
    descCodigoDeposito: string
    codFicheiroPagamento: number
  }

  export type pagamentomultaUpdateInput = {
    dataPagamento?: DateTimeFieldUpdateOperationsInput | Date | string
    valorPago?: StringFieldUpdateOperationsInput | string
    descCodigoDeposito?: StringFieldUpdateOperationsInput | string
    multa?: multaUpdateOneRequiredWithoutPagamentomultaNestedInput
    ficheiro?: ficheiroUpdateOneRequiredWithoutPagamentomultaNestedInput
  }

  export type pagamentomultaUncheckedUpdateInput = {
    codPagamentoMulta?: IntFieldUpdateOperationsInput | number
    codMulta?: IntFieldUpdateOperationsInput | number
    dataPagamento?: DateTimeFieldUpdateOperationsInput | Date | string
    valorPago?: StringFieldUpdateOperationsInput | string
    descCodigoDeposito?: StringFieldUpdateOperationsInput | string
    codFicheiroPagamento?: IntFieldUpdateOperationsInput | number
  }

  export type pagamentomultaCreateManyInput = {
    codPagamentoMulta?: number
    codMulta: number
    dataPagamento: Date | string
    valorPago: string
    descCodigoDeposito: string
    codFicheiroPagamento: number
  }

  export type pagamentomultaUpdateManyMutationInput = {
    dataPagamento?: DateTimeFieldUpdateOperationsInput | Date | string
    valorPago?: StringFieldUpdateOperationsInput | string
    descCodigoDeposito?: StringFieldUpdateOperationsInput | string
  }

  export type pagamentomultaUncheckedUpdateManyInput = {
    codPagamentoMulta?: IntFieldUpdateOperationsInput | number
    codMulta?: IntFieldUpdateOperationsInput | number
    dataPagamento?: DateTimeFieldUpdateOperationsInput | Date | string
    valorPago?: StringFieldUpdateOperationsInput | string
    descCodigoDeposito?: StringFieldUpdateOperationsInput | string
    codFicheiroPagamento?: IntFieldUpdateOperationsInput | number
  }

  export type paisCreateInput = {
    pais: string
    pessoa?: pessoaCreateNestedManyWithoutPaisInput
  }

  export type paisUncheckedCreateInput = {
    idPais?: number
    pais: string
    pessoa?: pessoaUncheckedCreateNestedManyWithoutPaisInput
  }

  export type paisUpdateInput = {
    pais?: StringFieldUpdateOperationsInput | string
    pessoa?: pessoaUpdateManyWithoutPaisNestedInput
  }

  export type paisUncheckedUpdateInput = {
    idPais?: IntFieldUpdateOperationsInput | number
    pais?: StringFieldUpdateOperationsInput | string
    pessoa?: pessoaUncheckedUpdateManyWithoutPaisNestedInput
  }

  export type paisCreateManyInput = {
    idPais?: number
    pais: string
  }

  export type paisUpdateManyMutationInput = {
    pais?: StringFieldUpdateOperationsInput | string
  }

  export type paisUncheckedUpdateManyInput = {
    idPais?: IntFieldUpdateOperationsInput | number
    pais?: StringFieldUpdateOperationsInput | string
  }

  export type pessoaCreateInput = {
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    senha: string
    automobilista?: automobilistaCreateNestedManyWithoutPessoaInput
    funcionario?: funcionarioCreateNestedManyWithoutPessoaInput
    contacto?: contactoCreateNestedOneWithoutPessoaInput
    endereco?: enderecoCreateNestedOneWithoutPessoaInput
    pais?: paisCreateNestedOneWithoutPessoaInput
    bi: biCreateNestedOneWithoutPessoaInput
    titulopropriedade?: titulopropriedadeCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateInput = {
    codPessoa?: number
    codEndereco?: number | null
    codNacionalidade?: number | null
    codContacto?: number | null
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    codBi: number
    senha: string
    automobilista?: automobilistaUncheckedCreateNestedManyWithoutPessoaInput
    funcionario?: funcionarioUncheckedCreateNestedManyWithoutPessoaInput
    titulopropriedade?: titulopropriedadeUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    automobilista?: automobilistaUpdateManyWithoutPessoaNestedInput
    funcionario?: funcionarioUpdateManyWithoutPessoaNestedInput
    contacto?: contactoUpdateOneWithoutPessoaNestedInput
    endereco?: enderecoUpdateOneWithoutPessoaNestedInput
    pais?: paisUpdateOneWithoutPessoaNestedInput
    bi?: biUpdateOneRequiredWithoutPessoaNestedInput
    titulopropriedade?: titulopropriedadeUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateInput = {
    codPessoa?: IntFieldUpdateOperationsInput | number
    codEndereco?: NullableIntFieldUpdateOperationsInput | number | null
    codNacionalidade?: NullableIntFieldUpdateOperationsInput | number | null
    codContacto?: NullableIntFieldUpdateOperationsInput | number | null
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    codBi?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    automobilista?: automobilistaUncheckedUpdateManyWithoutPessoaNestedInput
    funcionario?: funcionarioUncheckedUpdateManyWithoutPessoaNestedInput
    titulopropriedade?: titulopropriedadeUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaCreateManyInput = {
    codPessoa?: number
    codEndereco?: number | null
    codNacionalidade?: number | null
    codContacto?: number | null
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    codBi: number
    senha: string
  }

  export type pessoaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
  }

  export type pessoaUncheckedUpdateManyInput = {
    codPessoa?: IntFieldUpdateOperationsInput | number
    codEndereco?: NullableIntFieldUpdateOperationsInput | number | null
    codNacionalidade?: NullableIntFieldUpdateOperationsInput | number | null
    codContacto?: NullableIntFieldUpdateOperationsInput | number | null
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    codBi?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
  }

  export type provinciaCreateInput = {
    provincia: string
    municipio?: municipioCreateNestedManyWithoutProvinciaInput
  }

  export type provinciaUncheckedCreateInput = {
    idProvincia?: number
    provincia: string
    municipio?: municipioUncheckedCreateNestedManyWithoutProvinciaInput
  }

  export type provinciaUpdateInput = {
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: municipioUpdateManyWithoutProvinciaNestedInput
  }

  export type provinciaUncheckedUpdateInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    provincia?: StringFieldUpdateOperationsInput | string
    municipio?: municipioUncheckedUpdateManyWithoutProvinciaNestedInput
  }

  export type provinciaCreateManyInput = {
    idProvincia?: number
    provincia: string
  }

  export type provinciaUpdateManyMutationInput = {
    provincia?: StringFieldUpdateOperationsInput | string
  }

  export type provinciaUncheckedUpdateManyInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    provincia?: StringFieldUpdateOperationsInput | string
  }

  export type serivicoviaturaCreateInput = {
    descServico: string
    livrete?: livreteCreateNestedManyWithoutSerivicoviaturaInput
  }

  export type serivicoviaturaUncheckedCreateInput = {
    codServicoViatura?: number
    descServico: string
    livrete?: livreteUncheckedCreateNestedManyWithoutSerivicoviaturaInput
  }

  export type serivicoviaturaUpdateInput = {
    descServico?: StringFieldUpdateOperationsInput | string
    livrete?: livreteUpdateManyWithoutSerivicoviaturaNestedInput
  }

  export type serivicoviaturaUncheckedUpdateInput = {
    codServicoViatura?: IntFieldUpdateOperationsInput | number
    descServico?: StringFieldUpdateOperationsInput | string
    livrete?: livreteUncheckedUpdateManyWithoutSerivicoviaturaNestedInput
  }

  export type serivicoviaturaCreateManyInput = {
    codServicoViatura?: number
    descServico: string
  }

  export type serivicoviaturaUpdateManyMutationInput = {
    descServico?: StringFieldUpdateOperationsInput | string
  }

  export type serivicoviaturaUncheckedUpdateManyInput = {
    codServicoViatura?: IntFieldUpdateOperationsInput | number
    descServico?: StringFieldUpdateOperationsInput | string
  }

  export type tipoinfracaoCreateInput = {
    descTipoInfracao: string
    valorInfracao: string
    infracao?: infracaoCreateNestedManyWithoutTipoinfracaoInput
  }

  export type tipoinfracaoUncheckedCreateInput = {
    codTipoInfracao?: number
    descTipoInfracao: string
    valorInfracao: string
    infracao?: infracaoUncheckedCreateNestedManyWithoutTipoinfracaoInput
  }

  export type tipoinfracaoUpdateInput = {
    descTipoInfracao?: StringFieldUpdateOperationsInput | string
    valorInfracao?: StringFieldUpdateOperationsInput | string
    infracao?: infracaoUpdateManyWithoutTipoinfracaoNestedInput
  }

  export type tipoinfracaoUncheckedUpdateInput = {
    codTipoInfracao?: IntFieldUpdateOperationsInput | number
    descTipoInfracao?: StringFieldUpdateOperationsInput | string
    valorInfracao?: StringFieldUpdateOperationsInput | string
    infracao?: infracaoUncheckedUpdateManyWithoutTipoinfracaoNestedInput
  }

  export type tipoinfracaoCreateManyInput = {
    codTipoInfracao?: number
    descTipoInfracao: string
    valorInfracao: string
  }

  export type tipoinfracaoUpdateManyMutationInput = {
    descTipoInfracao?: StringFieldUpdateOperationsInput | string
    valorInfracao?: StringFieldUpdateOperationsInput | string
  }

  export type tipoinfracaoUncheckedUpdateManyInput = {
    codTipoInfracao?: IntFieldUpdateOperationsInput | number
    descTipoInfracao?: StringFieldUpdateOperationsInput | string
    valorInfracao?: StringFieldUpdateOperationsInput | string
  }

  export type tiporouboCreateInput = {
    descTipoRoubo: string
    alertaroubo?: alertarouboCreateNestedManyWithoutTiporouboInput
  }

  export type tiporouboUncheckedCreateInput = {
    codTipoRoubo?: number
    descTipoRoubo: string
    alertaroubo?: alertarouboUncheckedCreateNestedManyWithoutTiporouboInput
  }

  export type tiporouboUpdateInput = {
    descTipoRoubo?: StringFieldUpdateOperationsInput | string
    alertaroubo?: alertarouboUpdateManyWithoutTiporouboNestedInput
  }

  export type tiporouboUncheckedUpdateInput = {
    codTipoRoubo?: IntFieldUpdateOperationsInput | number
    descTipoRoubo?: StringFieldUpdateOperationsInput | string
    alertaroubo?: alertarouboUncheckedUpdateManyWithoutTiporouboNestedInput
  }

  export type tiporouboCreateManyInput = {
    codTipoRoubo?: number
    descTipoRoubo: string
  }

  export type tiporouboUpdateManyMutationInput = {
    descTipoRoubo?: StringFieldUpdateOperationsInput | string
  }

  export type tiporouboUncheckedUpdateManyInput = {
    codTipoRoubo?: IntFieldUpdateOperationsInput | number
    descTipoRoubo?: StringFieldUpdateOperationsInput | string
  }

  export type titulopropriedadeCreateInput = {
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    numeroEmissao: string
    pessoa: pessoaCreateNestedOneWithoutTitulopropriedadeInput
    viatura: viaturaCreateNestedOneWithoutTitulopropriedadeInput
    ficheiro: ficheiroCreateNestedOneWithoutTitulopropriedadeInput
  }

  export type titulopropriedadeUncheckedCreateInput = {
    codTituloPropriedade?: number
    codPessoa: number
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    numeroEmissao: string
    codViatura: number
    codFicheiroTituloPropriedade: number
  }

  export type titulopropriedadeUpdateInput = {
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroEmissao?: StringFieldUpdateOperationsInput | string
    pessoa?: pessoaUpdateOneRequiredWithoutTitulopropriedadeNestedInput
    viatura?: viaturaUpdateOneRequiredWithoutTitulopropriedadeNestedInput
    ficheiro?: ficheiroUpdateOneRequiredWithoutTitulopropriedadeNestedInput
  }

  export type titulopropriedadeUncheckedUpdateInput = {
    codTituloPropriedade?: IntFieldUpdateOperationsInput | number
    codPessoa?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroEmissao?: StringFieldUpdateOperationsInput | string
    codViatura?: IntFieldUpdateOperationsInput | number
    codFicheiroTituloPropriedade?: IntFieldUpdateOperationsInput | number
  }

  export type titulopropriedadeCreateManyInput = {
    codTituloPropriedade?: number
    codPessoa: number
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    numeroEmissao: string
    codViatura: number
    codFicheiroTituloPropriedade: number
  }

  export type titulopropriedadeUpdateManyMutationInput = {
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroEmissao?: StringFieldUpdateOperationsInput | string
  }

  export type titulopropriedadeUncheckedUpdateManyInput = {
    codTituloPropriedade?: IntFieldUpdateOperationsInput | number
    codPessoa?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroEmissao?: StringFieldUpdateOperationsInput | string
    codViatura?: IntFieldUpdateOperationsInput | number
    codFicheiroTituloPropriedade?: IntFieldUpdateOperationsInput | number
  }

  export type viaturaCreateInput = {
    numeroMatricula: string
    alertaroubo?: alertarouboCreateNestedManyWithoutViaturaInput
    livrete?: livreteCreateNestedManyWithoutViaturaInput
    multa?: multaCreateNestedManyWithoutViaturaInput
    titulopropriedade?: titulopropriedadeCreateNestedManyWithoutViaturaInput
  }

  export type viaturaUncheckedCreateInput = {
    codViatura?: number
    numeroMatricula: string
    alertaroubo?: alertarouboUncheckedCreateNestedManyWithoutViaturaInput
    livrete?: livreteUncheckedCreateNestedManyWithoutViaturaInput
    multa?: multaUncheckedCreateNestedManyWithoutViaturaInput
    titulopropriedade?: titulopropriedadeUncheckedCreateNestedManyWithoutViaturaInput
  }

  export type viaturaUpdateInput = {
    numeroMatricula?: StringFieldUpdateOperationsInput | string
    alertaroubo?: alertarouboUpdateManyWithoutViaturaNestedInput
    livrete?: livreteUpdateManyWithoutViaturaNestedInput
    multa?: multaUpdateManyWithoutViaturaNestedInput
    titulopropriedade?: titulopropriedadeUpdateManyWithoutViaturaNestedInput
  }

  export type viaturaUncheckedUpdateInput = {
    codViatura?: IntFieldUpdateOperationsInput | number
    numeroMatricula?: StringFieldUpdateOperationsInput | string
    alertaroubo?: alertarouboUncheckedUpdateManyWithoutViaturaNestedInput
    livrete?: livreteUncheckedUpdateManyWithoutViaturaNestedInput
    multa?: multaUncheckedUpdateManyWithoutViaturaNestedInput
    titulopropriedade?: titulopropriedadeUncheckedUpdateManyWithoutViaturaNestedInput
  }

  export type viaturaCreateManyInput = {
    codViatura?: number
    numeroMatricula: string
  }

  export type viaturaUpdateManyMutationInput = {
    numeroMatricula?: StringFieldUpdateOperationsInput | string
  }

  export type viaturaUncheckedUpdateManyInput = {
    codViatura?: IntFieldUpdateOperationsInput | number
    numeroMatricula?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type AutomobilistaRelationFilter = {
    is?: automobilistaWhereInput
    isNot?: automobilistaWhereInput
  }

  export type TiporouboRelationFilter = {
    is?: tiporouboWhereInput
    isNot?: tiporouboWhereInput
  }

  export type ViaturaRelationFilter = {
    is?: viaturaWhereInput
    isNot?: viaturaWhereInput
  }

  export type alertarouboCountOrderByAggregateInput = {
    codAlertaRoubo?: SortOrder
    codAutomobilista?: SortOrder
    codViatura?: SortOrder
    dataRoubo?: SortOrder
    enderecoRoubo?: SortOrder
    codTipoRoubo?: SortOrder
    descRoubo?: SortOrder
  }

  export type alertarouboAvgOrderByAggregateInput = {
    codAlertaRoubo?: SortOrder
    codAutomobilista?: SortOrder
    codViatura?: SortOrder
    codTipoRoubo?: SortOrder
  }

  export type alertarouboMaxOrderByAggregateInput = {
    codAlertaRoubo?: SortOrder
    codAutomobilista?: SortOrder
    codViatura?: SortOrder
    dataRoubo?: SortOrder
    enderecoRoubo?: SortOrder
    codTipoRoubo?: SortOrder
    descRoubo?: SortOrder
  }

  export type alertarouboMinOrderByAggregateInput = {
    codAlertaRoubo?: SortOrder
    codAutomobilista?: SortOrder
    codViatura?: SortOrder
    dataRoubo?: SortOrder
    enderecoRoubo?: SortOrder
    codTipoRoubo?: SortOrder
    descRoubo?: SortOrder
  }

  export type alertarouboSumOrderByAggregateInput = {
    codAlertaRoubo?: SortOrder
    codAutomobilista?: SortOrder
    codViatura?: SortOrder
    codTipoRoubo?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type AlertarouboListRelationFilter = {
    every?: alertarouboWhereInput
    some?: alertarouboWhereInput
    none?: alertarouboWhereInput
  }

  export type CartaconducaoRelationFilter = {
    is?: cartaconducaoWhereInput
    isNot?: cartaconducaoWhereInput
  }

  export type PessoaRelationFilter = {
    is?: pessoaWhereInput
    isNot?: pessoaWhereInput
  }

  export type MultaListRelationFilter = {
    every?: multaWhereInput
    some?: multaWhereInput
    none?: multaWhereInput
  }

  export type alertarouboOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type multaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type automobilistaCountOrderByAggregateInput = {
    codAutomobilista?: SortOrder
    codCartaConducao?: SortOrder
    codPessoa?: SortOrder
  }

  export type automobilistaAvgOrderByAggregateInput = {
    codAutomobilista?: SortOrder
    codCartaConducao?: SortOrder
    codPessoa?: SortOrder
  }

  export type automobilistaMaxOrderByAggregateInput = {
    codAutomobilista?: SortOrder
    codCartaConducao?: SortOrder
    codPessoa?: SortOrder
  }

  export type automobilistaMinOrderByAggregateInput = {
    codAutomobilista?: SortOrder
    codCartaConducao?: SortOrder
    codPessoa?: SortOrder
  }

  export type automobilistaSumOrderByAggregateInput = {
    codAutomobilista?: SortOrder
    codCartaConducao?: SortOrder
    codPessoa?: SortOrder
  }

  export type FicheiroRelationFilter = {
    is?: ficheiroWhereInput
    isNot?: ficheiroWhereInput
  }

  export type PessoaListRelationFilter = {
    every?: pessoaWhereInput
    some?: pessoaWhereInput
    none?: pessoaWhereInput
  }

  export type pessoaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type biCountOrderByAggregateInput = {
    idBi?: SortOrder
    dataEmicaoBi?: SortOrder
    dataValidacaoBi?: SortOrder
    numeroBI?: SortOrder
    codFicheiroBi?: SortOrder
  }

  export type biAvgOrderByAggregateInput = {
    idBi?: SortOrder
    codFicheiroBi?: SortOrder
  }

  export type biMaxOrderByAggregateInput = {
    idBi?: SortOrder
    dataEmicaoBi?: SortOrder
    dataValidacaoBi?: SortOrder
    numeroBI?: SortOrder
    codFicheiroBi?: SortOrder
  }

  export type biMinOrderByAggregateInput = {
    idBi?: SortOrder
    dataEmicaoBi?: SortOrder
    dataValidacaoBi?: SortOrder
    numeroBI?: SortOrder
    codFicheiroBi?: SortOrder
  }

  export type biSumOrderByAggregateInput = {
    idBi?: SortOrder
    codFicheiroBi?: SortOrder
  }

  export type AutomobilistaListRelationFilter = {
    every?: automobilistaWhereInput
    some?: automobilistaWhereInput
    none?: automobilistaWhereInput
  }

  export type CategoriacartaRelationFilter = {
    is?: categoriacartaWhereInput
    isNot?: categoriacartaWhereInput
  }

  export type automobilistaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cartaconducaoCountOrderByAggregateInput = {
    codCartaConducao?: SortOrder
    dataEmissao?: SortOrder
    dataValidade?: SortOrder
    numeroVia?: SortOrder
    codCategoriaCarta?: SortOrder
    numeroCarta?: SortOrder
    dataPrimeiraEmissao?: SortOrder
    localEmissao?: SortOrder
    codFicheiroCartaConducao?: SortOrder
  }

  export type cartaconducaoAvgOrderByAggregateInput = {
    codCartaConducao?: SortOrder
    codCategoriaCarta?: SortOrder
    numeroCarta?: SortOrder
    localEmissao?: SortOrder
    codFicheiroCartaConducao?: SortOrder
  }

  export type cartaconducaoMaxOrderByAggregateInput = {
    codCartaConducao?: SortOrder
    dataEmissao?: SortOrder
    dataValidade?: SortOrder
    numeroVia?: SortOrder
    codCategoriaCarta?: SortOrder
    numeroCarta?: SortOrder
    dataPrimeiraEmissao?: SortOrder
    localEmissao?: SortOrder
    codFicheiroCartaConducao?: SortOrder
  }

  export type cartaconducaoMinOrderByAggregateInput = {
    codCartaConducao?: SortOrder
    dataEmissao?: SortOrder
    dataValidade?: SortOrder
    numeroVia?: SortOrder
    codCategoriaCarta?: SortOrder
    numeroCarta?: SortOrder
    dataPrimeiraEmissao?: SortOrder
    localEmissao?: SortOrder
    codFicheiroCartaConducao?: SortOrder
  }

  export type cartaconducaoSumOrderByAggregateInput = {
    codCartaConducao?: SortOrder
    codCategoriaCarta?: SortOrder
    numeroCarta?: SortOrder
    localEmissao?: SortOrder
    codFicheiroCartaConducao?: SortOrder
  }

  export type CartaconducaoListRelationFilter = {
    every?: cartaconducaoWhereInput
    some?: cartaconducaoWhereInput
    none?: cartaconducaoWhereInput
  }

  export type cartaconducaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoriacartaCountOrderByAggregateInput = {
    codCategoriaCarta?: SortOrder
    descCategoriaCarta?: SortOrder
    sigla?: SortOrder
  }

  export type categoriacartaAvgOrderByAggregateInput = {
    codCategoriaCarta?: SortOrder
  }

  export type categoriacartaMaxOrderByAggregateInput = {
    codCategoriaCarta?: SortOrder
    descCategoriaCarta?: SortOrder
    sigla?: SortOrder
  }

  export type categoriacartaMinOrderByAggregateInput = {
    codCategoriaCarta?: SortOrder
    descCategoriaCarta?: SortOrder
    sigla?: SortOrder
  }

  export type categoriacartaSumOrderByAggregateInput = {
    codCategoriaCarta?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type contactoCountOrderByAggregateInput = {
    idContacto?: SortOrder
    contacto1?: SortOrder
    contacto2?: SortOrder
    email1?: SortOrder
    email2?: SortOrder
  }

  export type contactoAvgOrderByAggregateInput = {
    idContacto?: SortOrder
  }

  export type contactoMaxOrderByAggregateInput = {
    idContacto?: SortOrder
    contacto1?: SortOrder
    contacto2?: SortOrder
    email1?: SortOrder
    email2?: SortOrder
  }

  export type contactoMinOrderByAggregateInput = {
    idContacto?: SortOrder
    contacto1?: SortOrder
    contacto2?: SortOrder
    email1?: SortOrder
    email2?: SortOrder
  }

  export type contactoSumOrderByAggregateInput = {
    idContacto?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type MunicipioRelationFilter = {
    is?: municipioWhereInput
    isNot?: municipioWhereInput
  }

  export type enderecoCountOrderByAggregateInput = {
    idEndereco?: SortOrder
    idMunicipio?: SortOrder
    descricaoEndereco?: SortOrder
  }

  export type enderecoAvgOrderByAggregateInput = {
    idEndereco?: SortOrder
    idMunicipio?: SortOrder
  }

  export type enderecoMaxOrderByAggregateInput = {
    idEndereco?: SortOrder
    idMunicipio?: SortOrder
    descricaoEndereco?: SortOrder
  }

  export type enderecoMinOrderByAggregateInput = {
    idEndereco?: SortOrder
    idMunicipio?: SortOrder
    descricaoEndereco?: SortOrder
  }

  export type enderecoSumOrderByAggregateInput = {
    idEndereco?: SortOrder
    idMunicipio?: SortOrder
  }

  export type Enumficheiro_estadoValidacaoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ficheiro_estadoValidacao | Enumficheiro_estadoValidacaoFieldRefInput<$PrismaModel> | null
    in?: $Enums.ficheiro_estadoValidacao[] | null
    notIn?: $Enums.ficheiro_estadoValidacao[] | null
    not?: NestedEnumficheiro_estadoValidacaoNullableFilter<$PrismaModel> | $Enums.ficheiro_estadoValidacao | null
  }

  export type BiListRelationFilter = {
    every?: biWhereInput
    some?: biWhereInput
    none?: biWhereInput
  }

  export type FuncionarioListRelationFilter = {
    every?: funcionarioWhereInput
    some?: funcionarioWhereInput
    none?: funcionarioWhereInput
  }

  export type PagamentomultaListRelationFilter = {
    every?: pagamentomultaWhereInput
    some?: pagamentomultaWhereInput
    none?: pagamentomultaWhereInput
  }

  export type TitulopropriedadeListRelationFilter = {
    every?: titulopropriedadeWhereInput
    some?: titulopropriedadeWhereInput
    none?: titulopropriedadeWhereInput
  }

  export type biOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type funcionarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pagamentomultaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type titulopropriedadeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ficheiroCountOrderByAggregateInput = {
    idFicheiro?: SortOrder
    nomeFicheiro?: SortOrder
    dataEntrada?: SortOrder
    dataValidacao?: SortOrder
    estadoValidacao?: SortOrder
  }

  export type ficheiroAvgOrderByAggregateInput = {
    idFicheiro?: SortOrder
  }

  export type ficheiroMaxOrderByAggregateInput = {
    idFicheiro?: SortOrder
    nomeFicheiro?: SortOrder
    dataEntrada?: SortOrder
    dataValidacao?: SortOrder
    estadoValidacao?: SortOrder
  }

  export type ficheiroMinOrderByAggregateInput = {
    idFicheiro?: SortOrder
    nomeFicheiro?: SortOrder
    dataEntrada?: SortOrder
    dataValidacao?: SortOrder
    estadoValidacao?: SortOrder
  }

  export type ficheiroSumOrderByAggregateInput = {
    idFicheiro?: SortOrder
  }

  export type Enumficheiro_estadoValidacaoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ficheiro_estadoValidacao | Enumficheiro_estadoValidacaoFieldRefInput<$PrismaModel> | null
    in?: $Enums.ficheiro_estadoValidacao[] | null
    notIn?: $Enums.ficheiro_estadoValidacao[] | null
    not?: NestedEnumficheiro_estadoValidacaoNullableWithAggregatesFilter<$PrismaModel> | $Enums.ficheiro_estadoValidacao | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumficheiro_estadoValidacaoNullableFilter<$PrismaModel>
    _max?: NestedEnumficheiro_estadoValidacaoNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type funcionarioCountOrderByAggregateInput = {
    codFuncionario?: SortOrder
    codPessoa?: SortOrder
    codficheiroFotoPerfil?: SortOrder
    codficheiroFotoPendente?: SortOrder
    numeroAgente?: SortOrder
    senha?: SortOrder
  }

  export type funcionarioAvgOrderByAggregateInput = {
    codFuncionario?: SortOrder
    codPessoa?: SortOrder
    codficheiroFotoPerfil?: SortOrder
    codficheiroFotoPendente?: SortOrder
    senha?: SortOrder
  }

  export type funcionarioMaxOrderByAggregateInput = {
    codFuncionario?: SortOrder
    codPessoa?: SortOrder
    codficheiroFotoPerfil?: SortOrder
    codficheiroFotoPendente?: SortOrder
    numeroAgente?: SortOrder
    senha?: SortOrder
  }

  export type funcionarioMinOrderByAggregateInput = {
    codFuncionario?: SortOrder
    codPessoa?: SortOrder
    codficheiroFotoPerfil?: SortOrder
    codficheiroFotoPendente?: SortOrder
    numeroAgente?: SortOrder
    senha?: SortOrder
  }

  export type funcionarioSumOrderByAggregateInput = {
    codFuncionario?: SortOrder
    codPessoa?: SortOrder
    codficheiroFotoPerfil?: SortOrder
    codficheiroFotoPendente?: SortOrder
    senha?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type MultaRelationFilter = {
    is?: multaWhereInput
    isNot?: multaWhereInput
  }

  export type TipoinfracaoRelationFilter = {
    is?: tipoinfracaoWhereInput
    isNot?: tipoinfracaoWhereInput
  }

  export type infracaoCountOrderByAggregateInput = {
    codInfracao?: SortOrder
    codMulta?: SortOrder
    codTipoInfracao?: SortOrder
  }

  export type infracaoAvgOrderByAggregateInput = {
    codInfracao?: SortOrder
    codMulta?: SortOrder
    codTipoInfracao?: SortOrder
  }

  export type infracaoMaxOrderByAggregateInput = {
    codInfracao?: SortOrder
    codMulta?: SortOrder
    codTipoInfracao?: SortOrder
  }

  export type infracaoMinOrderByAggregateInput = {
    codInfracao?: SortOrder
    codMulta?: SortOrder
    codTipoInfracao?: SortOrder
  }

  export type infracaoSumOrderByAggregateInput = {
    codInfracao?: SortOrder
    codMulta?: SortOrder
    codTipoInfracao?: SortOrder
  }

  export type MarcaRelationFilter = {
    is?: marcaWhereInput
    isNot?: marcaWhereInput
  }

  export type SerivicoviaturaRelationFilter = {
    is?: serivicoviaturaWhereInput
    isNot?: serivicoviaturaWhereInput
  }

  export type livreteCountOrderByAggregateInput = {
    codLivrete?: SortOrder
    codViatura?: SortOrder
    numeroQuadro?: SortOrder
    corViatura?: SortOrder
    MedidasPneumaticos?: SortOrder
    codServico?: SortOrder
    dataEmissao?: SortOrder
    dataPrimeiroRegistro?: SortOrder
    lotacao?: SortOrder
    cilindrada?: SortOrder
    numeroCilindro?: SortOrder
    conbustivel?: SortOrder
    peso?: SortOrder
    tara?: SortOrder
    tipoCaixa?: SortOrder
    distanciaEixo?: SortOrder
    modelo?: SortOrder
    codMarca?: SortOrder
  }

  export type livreteAvgOrderByAggregateInput = {
    codLivrete?: SortOrder
    codViatura?: SortOrder
    codServico?: SortOrder
    codMarca?: SortOrder
  }

  export type livreteMaxOrderByAggregateInput = {
    codLivrete?: SortOrder
    codViatura?: SortOrder
    numeroQuadro?: SortOrder
    corViatura?: SortOrder
    MedidasPneumaticos?: SortOrder
    codServico?: SortOrder
    dataEmissao?: SortOrder
    dataPrimeiroRegistro?: SortOrder
    lotacao?: SortOrder
    cilindrada?: SortOrder
    numeroCilindro?: SortOrder
    conbustivel?: SortOrder
    peso?: SortOrder
    tara?: SortOrder
    tipoCaixa?: SortOrder
    distanciaEixo?: SortOrder
    modelo?: SortOrder
    codMarca?: SortOrder
  }

  export type livreteMinOrderByAggregateInput = {
    codLivrete?: SortOrder
    codViatura?: SortOrder
    numeroQuadro?: SortOrder
    corViatura?: SortOrder
    MedidasPneumaticos?: SortOrder
    codServico?: SortOrder
    dataEmissao?: SortOrder
    dataPrimeiroRegistro?: SortOrder
    lotacao?: SortOrder
    cilindrada?: SortOrder
    numeroCilindro?: SortOrder
    conbustivel?: SortOrder
    peso?: SortOrder
    tara?: SortOrder
    tipoCaixa?: SortOrder
    distanciaEixo?: SortOrder
    modelo?: SortOrder
    codMarca?: SortOrder
  }

  export type livreteSumOrderByAggregateInput = {
    codLivrete?: SortOrder
    codViatura?: SortOrder
    codServico?: SortOrder
    codMarca?: SortOrder
  }

  export type LivreteListRelationFilter = {
    every?: livreteWhereInput
    some?: livreteWhereInput
    none?: livreteWhereInput
  }

  export type livreteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type marcaCountOrderByAggregateInput = {
    codMarca?: SortOrder
    descMarca?: SortOrder
  }

  export type marcaAvgOrderByAggregateInput = {
    codMarca?: SortOrder
  }

  export type marcaMaxOrderByAggregateInput = {
    codMarca?: SortOrder
    descMarca?: SortOrder
  }

  export type marcaMinOrderByAggregateInput = {
    codMarca?: SortOrder
    descMarca?: SortOrder
  }

  export type marcaSumOrderByAggregateInput = {
    codMarca?: SortOrder
  }

  export type Enummulta_estadoMultaFilter<$PrismaModel = never> = {
    equals?: $Enums.multa_estadoMulta | Enummulta_estadoMultaFieldRefInput<$PrismaModel>
    in?: $Enums.multa_estadoMulta[]
    notIn?: $Enums.multa_estadoMulta[]
    not?: NestedEnummulta_estadoMultaFilter<$PrismaModel> | $Enums.multa_estadoMulta
  }

  export type InfracaoListRelationFilter = {
    every?: infracaoWhereInput
    some?: infracaoWhereInput
    none?: infracaoWhereInput
  }

  export type AutomobilistaNullableRelationFilter = {
    is?: automobilistaWhereInput | null
    isNot?: automobilistaWhereInput | null
  }

  export type InfracaoRelationFilter = {
    is?: infracaoWhereInput
    isNot?: infracaoWhereInput
  }

  export type ViaturaNullableRelationFilter = {
    is?: viaturaWhereInput | null
    isNot?: viaturaWhereInput | null
  }

  export type infracaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type multaCountOrderByAggregateInput = {
    codMulta?: SortOrder
    codAutomobilista?: SortOrder
    CodViatura?: SortOrder
    codInfracao?: SortOrder
    valorMulta?: SortOrder
    estadoMulta?: SortOrder
  }

  export type multaAvgOrderByAggregateInput = {
    codMulta?: SortOrder
    codAutomobilista?: SortOrder
    CodViatura?: SortOrder
    codInfracao?: SortOrder
  }

  export type multaMaxOrderByAggregateInput = {
    codMulta?: SortOrder
    codAutomobilista?: SortOrder
    CodViatura?: SortOrder
    codInfracao?: SortOrder
    valorMulta?: SortOrder
    estadoMulta?: SortOrder
  }

  export type multaMinOrderByAggregateInput = {
    codMulta?: SortOrder
    codAutomobilista?: SortOrder
    CodViatura?: SortOrder
    codInfracao?: SortOrder
    valorMulta?: SortOrder
    estadoMulta?: SortOrder
  }

  export type multaSumOrderByAggregateInput = {
    codMulta?: SortOrder
    codAutomobilista?: SortOrder
    CodViatura?: SortOrder
    codInfracao?: SortOrder
  }

  export type Enummulta_estadoMultaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.multa_estadoMulta | Enummulta_estadoMultaFieldRefInput<$PrismaModel>
    in?: $Enums.multa_estadoMulta[]
    notIn?: $Enums.multa_estadoMulta[]
    not?: NestedEnummulta_estadoMultaWithAggregatesFilter<$PrismaModel> | $Enums.multa_estadoMulta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummulta_estadoMultaFilter<$PrismaModel>
    _max?: NestedEnummulta_estadoMultaFilter<$PrismaModel>
  }

  export type EnderecoListRelationFilter = {
    every?: enderecoWhereInput
    some?: enderecoWhereInput
    none?: enderecoWhereInput
  }

  export type ProvinciaRelationFilter = {
    is?: provinciaWhereInput
    isNot?: provinciaWhereInput
  }

  export type enderecoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type municipioCountOrderByAggregateInput = {
    idMunicipio?: SortOrder
    idProvincia?: SortOrder
    municipio?: SortOrder
  }

  export type municipioAvgOrderByAggregateInput = {
    idMunicipio?: SortOrder
    idProvincia?: SortOrder
  }

  export type municipioMaxOrderByAggregateInput = {
    idMunicipio?: SortOrder
    idProvincia?: SortOrder
    municipio?: SortOrder
  }

  export type municipioMinOrderByAggregateInput = {
    idMunicipio?: SortOrder
    idProvincia?: SortOrder
    municipio?: SortOrder
  }

  export type municipioSumOrderByAggregateInput = {
    idMunicipio?: SortOrder
    idProvincia?: SortOrder
  }

  export type pagamentomultaCountOrderByAggregateInput = {
    codPagamentoMulta?: SortOrder
    codMulta?: SortOrder
    dataPagamento?: SortOrder
    valorPago?: SortOrder
    descCodigoDeposito?: SortOrder
    codFicheiroPagamento?: SortOrder
  }

  export type pagamentomultaAvgOrderByAggregateInput = {
    codPagamentoMulta?: SortOrder
    codMulta?: SortOrder
    codFicheiroPagamento?: SortOrder
  }

  export type pagamentomultaMaxOrderByAggregateInput = {
    codPagamentoMulta?: SortOrder
    codMulta?: SortOrder
    dataPagamento?: SortOrder
    valorPago?: SortOrder
    descCodigoDeposito?: SortOrder
    codFicheiroPagamento?: SortOrder
  }

  export type pagamentomultaMinOrderByAggregateInput = {
    codPagamentoMulta?: SortOrder
    codMulta?: SortOrder
    dataPagamento?: SortOrder
    valorPago?: SortOrder
    descCodigoDeposito?: SortOrder
    codFicheiroPagamento?: SortOrder
  }

  export type pagamentomultaSumOrderByAggregateInput = {
    codPagamentoMulta?: SortOrder
    codMulta?: SortOrder
    codFicheiroPagamento?: SortOrder
  }

  export type paisCountOrderByAggregateInput = {
    idPais?: SortOrder
    pais?: SortOrder
  }

  export type paisAvgOrderByAggregateInput = {
    idPais?: SortOrder
  }

  export type paisMaxOrderByAggregateInput = {
    idPais?: SortOrder
    pais?: SortOrder
  }

  export type paisMinOrderByAggregateInput = {
    idPais?: SortOrder
    pais?: SortOrder
  }

  export type paisSumOrderByAggregateInput = {
    idPais?: SortOrder
  }

  export type Enumpessoa_generoFilter<$PrismaModel = never> = {
    equals?: $Enums.pessoa_genero | Enumpessoa_generoFieldRefInput<$PrismaModel>
    in?: $Enums.pessoa_genero[]
    notIn?: $Enums.pessoa_genero[]
    not?: NestedEnumpessoa_generoFilter<$PrismaModel> | $Enums.pessoa_genero
  }

  export type Enumpessoa_estadoCivilFilter<$PrismaModel = never> = {
    equals?: $Enums.pessoa_estadoCivil | Enumpessoa_estadoCivilFieldRefInput<$PrismaModel>
    in?: $Enums.pessoa_estadoCivil[]
    notIn?: $Enums.pessoa_estadoCivil[]
    not?: NestedEnumpessoa_estadoCivilFilter<$PrismaModel> | $Enums.pessoa_estadoCivil
  }

  export type ContactoNullableRelationFilter = {
    is?: contactoWhereInput | null
    isNot?: contactoWhereInput | null
  }

  export type EnderecoNullableRelationFilter = {
    is?: enderecoWhereInput | null
    isNot?: enderecoWhereInput | null
  }

  export type PaisNullableRelationFilter = {
    is?: paisWhereInput | null
    isNot?: paisWhereInput | null
  }

  export type BiRelationFilter = {
    is?: biWhereInput
    isNot?: biWhereInput
  }

  export type pessoaCountOrderByAggregateInput = {
    codPessoa?: SortOrder
    codEndereco?: SortOrder
    codNacionalidade?: SortOrder
    codContacto?: SortOrder
    nome?: SortOrder
    genero?: SortOrder
    estadoCivil?: SortOrder
    dataCadastro?: SortOrder
    dataNascimento?: SortOrder
    codBi?: SortOrder
    senha?: SortOrder
  }

  export type pessoaAvgOrderByAggregateInput = {
    codPessoa?: SortOrder
    codEndereco?: SortOrder
    codNacionalidade?: SortOrder
    codContacto?: SortOrder
    codBi?: SortOrder
  }

  export type pessoaMaxOrderByAggregateInput = {
    codPessoa?: SortOrder
    codEndereco?: SortOrder
    codNacionalidade?: SortOrder
    codContacto?: SortOrder
    nome?: SortOrder
    genero?: SortOrder
    estadoCivil?: SortOrder
    dataCadastro?: SortOrder
    dataNascimento?: SortOrder
    codBi?: SortOrder
    senha?: SortOrder
  }

  export type pessoaMinOrderByAggregateInput = {
    codPessoa?: SortOrder
    codEndereco?: SortOrder
    codNacionalidade?: SortOrder
    codContacto?: SortOrder
    nome?: SortOrder
    genero?: SortOrder
    estadoCivil?: SortOrder
    dataCadastro?: SortOrder
    dataNascimento?: SortOrder
    codBi?: SortOrder
    senha?: SortOrder
  }

  export type pessoaSumOrderByAggregateInput = {
    codPessoa?: SortOrder
    codEndereco?: SortOrder
    codNacionalidade?: SortOrder
    codContacto?: SortOrder
    codBi?: SortOrder
  }

  export type Enumpessoa_generoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.pessoa_genero | Enumpessoa_generoFieldRefInput<$PrismaModel>
    in?: $Enums.pessoa_genero[]
    notIn?: $Enums.pessoa_genero[]
    not?: NestedEnumpessoa_generoWithAggregatesFilter<$PrismaModel> | $Enums.pessoa_genero
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpessoa_generoFilter<$PrismaModel>
    _max?: NestedEnumpessoa_generoFilter<$PrismaModel>
  }

  export type Enumpessoa_estadoCivilWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.pessoa_estadoCivil | Enumpessoa_estadoCivilFieldRefInput<$PrismaModel>
    in?: $Enums.pessoa_estadoCivil[]
    notIn?: $Enums.pessoa_estadoCivil[]
    not?: NestedEnumpessoa_estadoCivilWithAggregatesFilter<$PrismaModel> | $Enums.pessoa_estadoCivil
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpessoa_estadoCivilFilter<$PrismaModel>
    _max?: NestedEnumpessoa_estadoCivilFilter<$PrismaModel>
  }

  export type MunicipioListRelationFilter = {
    every?: municipioWhereInput
    some?: municipioWhereInput
    none?: municipioWhereInput
  }

  export type municipioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type provinciaCountOrderByAggregateInput = {
    idProvincia?: SortOrder
    provincia?: SortOrder
  }

  export type provinciaAvgOrderByAggregateInput = {
    idProvincia?: SortOrder
  }

  export type provinciaMaxOrderByAggregateInput = {
    idProvincia?: SortOrder
    provincia?: SortOrder
  }

  export type provinciaMinOrderByAggregateInput = {
    idProvincia?: SortOrder
    provincia?: SortOrder
  }

  export type provinciaSumOrderByAggregateInput = {
    idProvincia?: SortOrder
  }

  export type serivicoviaturaCountOrderByAggregateInput = {
    codServicoViatura?: SortOrder
    descServico?: SortOrder
  }

  export type serivicoviaturaAvgOrderByAggregateInput = {
    codServicoViatura?: SortOrder
  }

  export type serivicoviaturaMaxOrderByAggregateInput = {
    codServicoViatura?: SortOrder
    descServico?: SortOrder
  }

  export type serivicoviaturaMinOrderByAggregateInput = {
    codServicoViatura?: SortOrder
    descServico?: SortOrder
  }

  export type serivicoviaturaSumOrderByAggregateInput = {
    codServicoViatura?: SortOrder
  }

  export type tipoinfracaoCountOrderByAggregateInput = {
    codTipoInfracao?: SortOrder
    descTipoInfracao?: SortOrder
    valorInfracao?: SortOrder
  }

  export type tipoinfracaoAvgOrderByAggregateInput = {
    codTipoInfracao?: SortOrder
  }

  export type tipoinfracaoMaxOrderByAggregateInput = {
    codTipoInfracao?: SortOrder
    descTipoInfracao?: SortOrder
    valorInfracao?: SortOrder
  }

  export type tipoinfracaoMinOrderByAggregateInput = {
    codTipoInfracao?: SortOrder
    descTipoInfracao?: SortOrder
    valorInfracao?: SortOrder
  }

  export type tipoinfracaoSumOrderByAggregateInput = {
    codTipoInfracao?: SortOrder
  }

  export type tiporouboCountOrderByAggregateInput = {
    codTipoRoubo?: SortOrder
    descTipoRoubo?: SortOrder
  }

  export type tiporouboAvgOrderByAggregateInput = {
    codTipoRoubo?: SortOrder
  }

  export type tiporouboMaxOrderByAggregateInput = {
    codTipoRoubo?: SortOrder
    descTipoRoubo?: SortOrder
  }

  export type tiporouboMinOrderByAggregateInput = {
    codTipoRoubo?: SortOrder
    descTipoRoubo?: SortOrder
  }

  export type tiporouboSumOrderByAggregateInput = {
    codTipoRoubo?: SortOrder
  }

  export type titulopropriedadeCountOrderByAggregateInput = {
    codTituloPropriedade?: SortOrder
    codPessoa?: SortOrder
    dataEmissao?: SortOrder
    dataPrimeiroRegistro?: SortOrder
    numeroEmissao?: SortOrder
    codViatura?: SortOrder
    codFicheiroTituloPropriedade?: SortOrder
  }

  export type titulopropriedadeAvgOrderByAggregateInput = {
    codTituloPropriedade?: SortOrder
    codPessoa?: SortOrder
    codViatura?: SortOrder
    codFicheiroTituloPropriedade?: SortOrder
  }

  export type titulopropriedadeMaxOrderByAggregateInput = {
    codTituloPropriedade?: SortOrder
    codPessoa?: SortOrder
    dataEmissao?: SortOrder
    dataPrimeiroRegistro?: SortOrder
    numeroEmissao?: SortOrder
    codViatura?: SortOrder
    codFicheiroTituloPropriedade?: SortOrder
  }

  export type titulopropriedadeMinOrderByAggregateInput = {
    codTituloPropriedade?: SortOrder
    codPessoa?: SortOrder
    dataEmissao?: SortOrder
    dataPrimeiroRegistro?: SortOrder
    numeroEmissao?: SortOrder
    codViatura?: SortOrder
    codFicheiroTituloPropriedade?: SortOrder
  }

  export type titulopropriedadeSumOrderByAggregateInput = {
    codTituloPropriedade?: SortOrder
    codPessoa?: SortOrder
    codViatura?: SortOrder
    codFicheiroTituloPropriedade?: SortOrder
  }

  export type viaturaCountOrderByAggregateInput = {
    codViatura?: SortOrder
    numeroMatricula?: SortOrder
  }

  export type viaturaAvgOrderByAggregateInput = {
    codViatura?: SortOrder
  }

  export type viaturaMaxOrderByAggregateInput = {
    codViatura?: SortOrder
    numeroMatricula?: SortOrder
  }

  export type viaturaMinOrderByAggregateInput = {
    codViatura?: SortOrder
    numeroMatricula?: SortOrder
  }

  export type viaturaSumOrderByAggregateInput = {
    codViatura?: SortOrder
  }

  export type automobilistaCreateNestedOneWithoutAlertarouboInput = {
    create?: XOR<automobilistaCreateWithoutAlertarouboInput, automobilistaUncheckedCreateWithoutAlertarouboInput>
    connectOrCreate?: automobilistaCreateOrConnectWithoutAlertarouboInput
    connect?: automobilistaWhereUniqueInput
  }

  export type tiporouboCreateNestedOneWithoutAlertarouboInput = {
    create?: XOR<tiporouboCreateWithoutAlertarouboInput, tiporouboUncheckedCreateWithoutAlertarouboInput>
    connectOrCreate?: tiporouboCreateOrConnectWithoutAlertarouboInput
    connect?: tiporouboWhereUniqueInput
  }

  export type viaturaCreateNestedOneWithoutAlertarouboInput = {
    create?: XOR<viaturaCreateWithoutAlertarouboInput, viaturaUncheckedCreateWithoutAlertarouboInput>
    connectOrCreate?: viaturaCreateOrConnectWithoutAlertarouboInput
    connect?: viaturaWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type automobilistaUpdateOneRequiredWithoutAlertarouboNestedInput = {
    create?: XOR<automobilistaCreateWithoutAlertarouboInput, automobilistaUncheckedCreateWithoutAlertarouboInput>
    connectOrCreate?: automobilistaCreateOrConnectWithoutAlertarouboInput
    upsert?: automobilistaUpsertWithoutAlertarouboInput
    connect?: automobilistaWhereUniqueInput
    update?: XOR<XOR<automobilistaUpdateToOneWithWhereWithoutAlertarouboInput, automobilistaUpdateWithoutAlertarouboInput>, automobilistaUncheckedUpdateWithoutAlertarouboInput>
  }

  export type tiporouboUpdateOneRequiredWithoutAlertarouboNestedInput = {
    create?: XOR<tiporouboCreateWithoutAlertarouboInput, tiporouboUncheckedCreateWithoutAlertarouboInput>
    connectOrCreate?: tiporouboCreateOrConnectWithoutAlertarouboInput
    upsert?: tiporouboUpsertWithoutAlertarouboInput
    connect?: tiporouboWhereUniqueInput
    update?: XOR<XOR<tiporouboUpdateToOneWithWhereWithoutAlertarouboInput, tiporouboUpdateWithoutAlertarouboInput>, tiporouboUncheckedUpdateWithoutAlertarouboInput>
  }

  export type viaturaUpdateOneRequiredWithoutAlertarouboNestedInput = {
    create?: XOR<viaturaCreateWithoutAlertarouboInput, viaturaUncheckedCreateWithoutAlertarouboInput>
    connectOrCreate?: viaturaCreateOrConnectWithoutAlertarouboInput
    upsert?: viaturaUpsertWithoutAlertarouboInput
    connect?: viaturaWhereUniqueInput
    update?: XOR<XOR<viaturaUpdateToOneWithWhereWithoutAlertarouboInput, viaturaUpdateWithoutAlertarouboInput>, viaturaUncheckedUpdateWithoutAlertarouboInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type alertarouboCreateNestedManyWithoutAutomobilistaInput = {
    create?: XOR<alertarouboCreateWithoutAutomobilistaInput, alertarouboUncheckedCreateWithoutAutomobilistaInput> | alertarouboCreateWithoutAutomobilistaInput[] | alertarouboUncheckedCreateWithoutAutomobilistaInput[]
    connectOrCreate?: alertarouboCreateOrConnectWithoutAutomobilistaInput | alertarouboCreateOrConnectWithoutAutomobilistaInput[]
    createMany?: alertarouboCreateManyAutomobilistaInputEnvelope
    connect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
  }

  export type cartaconducaoCreateNestedOneWithoutAutomobilistaInput = {
    create?: XOR<cartaconducaoCreateWithoutAutomobilistaInput, cartaconducaoUncheckedCreateWithoutAutomobilistaInput>
    connectOrCreate?: cartaconducaoCreateOrConnectWithoutAutomobilistaInput
    connect?: cartaconducaoWhereUniqueInput
  }

  export type pessoaCreateNestedOneWithoutAutomobilistaInput = {
    create?: XOR<pessoaCreateWithoutAutomobilistaInput, pessoaUncheckedCreateWithoutAutomobilistaInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutAutomobilistaInput
    connect?: pessoaWhereUniqueInput
  }

  export type multaCreateNestedManyWithoutAutomobilistaInput = {
    create?: XOR<multaCreateWithoutAutomobilistaInput, multaUncheckedCreateWithoutAutomobilistaInput> | multaCreateWithoutAutomobilistaInput[] | multaUncheckedCreateWithoutAutomobilistaInput[]
    connectOrCreate?: multaCreateOrConnectWithoutAutomobilistaInput | multaCreateOrConnectWithoutAutomobilistaInput[]
    createMany?: multaCreateManyAutomobilistaInputEnvelope
    connect?: multaWhereUniqueInput | multaWhereUniqueInput[]
  }

  export type alertarouboUncheckedCreateNestedManyWithoutAutomobilistaInput = {
    create?: XOR<alertarouboCreateWithoutAutomobilistaInput, alertarouboUncheckedCreateWithoutAutomobilistaInput> | alertarouboCreateWithoutAutomobilistaInput[] | alertarouboUncheckedCreateWithoutAutomobilistaInput[]
    connectOrCreate?: alertarouboCreateOrConnectWithoutAutomobilistaInput | alertarouboCreateOrConnectWithoutAutomobilistaInput[]
    createMany?: alertarouboCreateManyAutomobilistaInputEnvelope
    connect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
  }

  export type multaUncheckedCreateNestedManyWithoutAutomobilistaInput = {
    create?: XOR<multaCreateWithoutAutomobilistaInput, multaUncheckedCreateWithoutAutomobilistaInput> | multaCreateWithoutAutomobilistaInput[] | multaUncheckedCreateWithoutAutomobilistaInput[]
    connectOrCreate?: multaCreateOrConnectWithoutAutomobilistaInput | multaCreateOrConnectWithoutAutomobilistaInput[]
    createMany?: multaCreateManyAutomobilistaInputEnvelope
    connect?: multaWhereUniqueInput | multaWhereUniqueInput[]
  }

  export type alertarouboUpdateManyWithoutAutomobilistaNestedInput = {
    create?: XOR<alertarouboCreateWithoutAutomobilistaInput, alertarouboUncheckedCreateWithoutAutomobilistaInput> | alertarouboCreateWithoutAutomobilistaInput[] | alertarouboUncheckedCreateWithoutAutomobilistaInput[]
    connectOrCreate?: alertarouboCreateOrConnectWithoutAutomobilistaInput | alertarouboCreateOrConnectWithoutAutomobilistaInput[]
    upsert?: alertarouboUpsertWithWhereUniqueWithoutAutomobilistaInput | alertarouboUpsertWithWhereUniqueWithoutAutomobilistaInput[]
    createMany?: alertarouboCreateManyAutomobilistaInputEnvelope
    set?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    disconnect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    delete?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    connect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    update?: alertarouboUpdateWithWhereUniqueWithoutAutomobilistaInput | alertarouboUpdateWithWhereUniqueWithoutAutomobilistaInput[]
    updateMany?: alertarouboUpdateManyWithWhereWithoutAutomobilistaInput | alertarouboUpdateManyWithWhereWithoutAutomobilistaInput[]
    deleteMany?: alertarouboScalarWhereInput | alertarouboScalarWhereInput[]
  }

  export type cartaconducaoUpdateOneRequiredWithoutAutomobilistaNestedInput = {
    create?: XOR<cartaconducaoCreateWithoutAutomobilistaInput, cartaconducaoUncheckedCreateWithoutAutomobilistaInput>
    connectOrCreate?: cartaconducaoCreateOrConnectWithoutAutomobilistaInput
    upsert?: cartaconducaoUpsertWithoutAutomobilistaInput
    connect?: cartaconducaoWhereUniqueInput
    update?: XOR<XOR<cartaconducaoUpdateToOneWithWhereWithoutAutomobilistaInput, cartaconducaoUpdateWithoutAutomobilistaInput>, cartaconducaoUncheckedUpdateWithoutAutomobilistaInput>
  }

  export type pessoaUpdateOneRequiredWithoutAutomobilistaNestedInput = {
    create?: XOR<pessoaCreateWithoutAutomobilistaInput, pessoaUncheckedCreateWithoutAutomobilistaInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutAutomobilistaInput
    upsert?: pessoaUpsertWithoutAutomobilistaInput
    connect?: pessoaWhereUniqueInput
    update?: XOR<XOR<pessoaUpdateToOneWithWhereWithoutAutomobilistaInput, pessoaUpdateWithoutAutomobilistaInput>, pessoaUncheckedUpdateWithoutAutomobilistaInput>
  }

  export type multaUpdateManyWithoutAutomobilistaNestedInput = {
    create?: XOR<multaCreateWithoutAutomobilistaInput, multaUncheckedCreateWithoutAutomobilistaInput> | multaCreateWithoutAutomobilistaInput[] | multaUncheckedCreateWithoutAutomobilistaInput[]
    connectOrCreate?: multaCreateOrConnectWithoutAutomobilistaInput | multaCreateOrConnectWithoutAutomobilistaInput[]
    upsert?: multaUpsertWithWhereUniqueWithoutAutomobilistaInput | multaUpsertWithWhereUniqueWithoutAutomobilistaInput[]
    createMany?: multaCreateManyAutomobilistaInputEnvelope
    set?: multaWhereUniqueInput | multaWhereUniqueInput[]
    disconnect?: multaWhereUniqueInput | multaWhereUniqueInput[]
    delete?: multaWhereUniqueInput | multaWhereUniqueInput[]
    connect?: multaWhereUniqueInput | multaWhereUniqueInput[]
    update?: multaUpdateWithWhereUniqueWithoutAutomobilistaInput | multaUpdateWithWhereUniqueWithoutAutomobilistaInput[]
    updateMany?: multaUpdateManyWithWhereWithoutAutomobilistaInput | multaUpdateManyWithWhereWithoutAutomobilistaInput[]
    deleteMany?: multaScalarWhereInput | multaScalarWhereInput[]
  }

  export type alertarouboUncheckedUpdateManyWithoutAutomobilistaNestedInput = {
    create?: XOR<alertarouboCreateWithoutAutomobilistaInput, alertarouboUncheckedCreateWithoutAutomobilistaInput> | alertarouboCreateWithoutAutomobilistaInput[] | alertarouboUncheckedCreateWithoutAutomobilistaInput[]
    connectOrCreate?: alertarouboCreateOrConnectWithoutAutomobilistaInput | alertarouboCreateOrConnectWithoutAutomobilistaInput[]
    upsert?: alertarouboUpsertWithWhereUniqueWithoutAutomobilistaInput | alertarouboUpsertWithWhereUniqueWithoutAutomobilistaInput[]
    createMany?: alertarouboCreateManyAutomobilistaInputEnvelope
    set?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    disconnect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    delete?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    connect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    update?: alertarouboUpdateWithWhereUniqueWithoutAutomobilistaInput | alertarouboUpdateWithWhereUniqueWithoutAutomobilistaInput[]
    updateMany?: alertarouboUpdateManyWithWhereWithoutAutomobilistaInput | alertarouboUpdateManyWithWhereWithoutAutomobilistaInput[]
    deleteMany?: alertarouboScalarWhereInput | alertarouboScalarWhereInput[]
  }

  export type multaUncheckedUpdateManyWithoutAutomobilistaNestedInput = {
    create?: XOR<multaCreateWithoutAutomobilistaInput, multaUncheckedCreateWithoutAutomobilistaInput> | multaCreateWithoutAutomobilistaInput[] | multaUncheckedCreateWithoutAutomobilistaInput[]
    connectOrCreate?: multaCreateOrConnectWithoutAutomobilistaInput | multaCreateOrConnectWithoutAutomobilistaInput[]
    upsert?: multaUpsertWithWhereUniqueWithoutAutomobilistaInput | multaUpsertWithWhereUniqueWithoutAutomobilistaInput[]
    createMany?: multaCreateManyAutomobilistaInputEnvelope
    set?: multaWhereUniqueInput | multaWhereUniqueInput[]
    disconnect?: multaWhereUniqueInput | multaWhereUniqueInput[]
    delete?: multaWhereUniqueInput | multaWhereUniqueInput[]
    connect?: multaWhereUniqueInput | multaWhereUniqueInput[]
    update?: multaUpdateWithWhereUniqueWithoutAutomobilistaInput | multaUpdateWithWhereUniqueWithoutAutomobilistaInput[]
    updateMany?: multaUpdateManyWithWhereWithoutAutomobilistaInput | multaUpdateManyWithWhereWithoutAutomobilistaInput[]
    deleteMany?: multaScalarWhereInput | multaScalarWhereInput[]
  }

  export type ficheiroCreateNestedOneWithoutBiInput = {
    create?: XOR<ficheiroCreateWithoutBiInput, ficheiroUncheckedCreateWithoutBiInput>
    connectOrCreate?: ficheiroCreateOrConnectWithoutBiInput
    connect?: ficheiroWhereUniqueInput
  }

  export type pessoaCreateNestedManyWithoutBiInput = {
    create?: XOR<pessoaCreateWithoutBiInput, pessoaUncheckedCreateWithoutBiInput> | pessoaCreateWithoutBiInput[] | pessoaUncheckedCreateWithoutBiInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutBiInput | pessoaCreateOrConnectWithoutBiInput[]
    createMany?: pessoaCreateManyBiInputEnvelope
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
  }

  export type pessoaUncheckedCreateNestedManyWithoutBiInput = {
    create?: XOR<pessoaCreateWithoutBiInput, pessoaUncheckedCreateWithoutBiInput> | pessoaCreateWithoutBiInput[] | pessoaUncheckedCreateWithoutBiInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutBiInput | pessoaCreateOrConnectWithoutBiInput[]
    createMany?: pessoaCreateManyBiInputEnvelope
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
  }

  export type ficheiroUpdateOneRequiredWithoutBiNestedInput = {
    create?: XOR<ficheiroCreateWithoutBiInput, ficheiroUncheckedCreateWithoutBiInput>
    connectOrCreate?: ficheiroCreateOrConnectWithoutBiInput
    upsert?: ficheiroUpsertWithoutBiInput
    connect?: ficheiroWhereUniqueInput
    update?: XOR<XOR<ficheiroUpdateToOneWithWhereWithoutBiInput, ficheiroUpdateWithoutBiInput>, ficheiroUncheckedUpdateWithoutBiInput>
  }

  export type pessoaUpdateManyWithoutBiNestedInput = {
    create?: XOR<pessoaCreateWithoutBiInput, pessoaUncheckedCreateWithoutBiInput> | pessoaCreateWithoutBiInput[] | pessoaUncheckedCreateWithoutBiInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutBiInput | pessoaCreateOrConnectWithoutBiInput[]
    upsert?: pessoaUpsertWithWhereUniqueWithoutBiInput | pessoaUpsertWithWhereUniqueWithoutBiInput[]
    createMany?: pessoaCreateManyBiInputEnvelope
    set?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    disconnect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    delete?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    update?: pessoaUpdateWithWhereUniqueWithoutBiInput | pessoaUpdateWithWhereUniqueWithoutBiInput[]
    updateMany?: pessoaUpdateManyWithWhereWithoutBiInput | pessoaUpdateManyWithWhereWithoutBiInput[]
    deleteMany?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
  }

  export type pessoaUncheckedUpdateManyWithoutBiNestedInput = {
    create?: XOR<pessoaCreateWithoutBiInput, pessoaUncheckedCreateWithoutBiInput> | pessoaCreateWithoutBiInput[] | pessoaUncheckedCreateWithoutBiInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutBiInput | pessoaCreateOrConnectWithoutBiInput[]
    upsert?: pessoaUpsertWithWhereUniqueWithoutBiInput | pessoaUpsertWithWhereUniqueWithoutBiInput[]
    createMany?: pessoaCreateManyBiInputEnvelope
    set?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    disconnect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    delete?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    update?: pessoaUpdateWithWhereUniqueWithoutBiInput | pessoaUpdateWithWhereUniqueWithoutBiInput[]
    updateMany?: pessoaUpdateManyWithWhereWithoutBiInput | pessoaUpdateManyWithWhereWithoutBiInput[]
    deleteMany?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
  }

  export type automobilistaCreateNestedManyWithoutCartaconducaoInput = {
    create?: XOR<automobilistaCreateWithoutCartaconducaoInput, automobilistaUncheckedCreateWithoutCartaconducaoInput> | automobilistaCreateWithoutCartaconducaoInput[] | automobilistaUncheckedCreateWithoutCartaconducaoInput[]
    connectOrCreate?: automobilistaCreateOrConnectWithoutCartaconducaoInput | automobilistaCreateOrConnectWithoutCartaconducaoInput[]
    createMany?: automobilistaCreateManyCartaconducaoInputEnvelope
    connect?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
  }

  export type categoriacartaCreateNestedOneWithoutCartaconducaoInput = {
    create?: XOR<categoriacartaCreateWithoutCartaconducaoInput, categoriacartaUncheckedCreateWithoutCartaconducaoInput>
    connectOrCreate?: categoriacartaCreateOrConnectWithoutCartaconducaoInput
    connect?: categoriacartaWhereUniqueInput
  }

  export type ficheiroCreateNestedOneWithoutCartaconducaoInput = {
    create?: XOR<ficheiroCreateWithoutCartaconducaoInput, ficheiroUncheckedCreateWithoutCartaconducaoInput>
    connectOrCreate?: ficheiroCreateOrConnectWithoutCartaconducaoInput
    connect?: ficheiroWhereUniqueInput
  }

  export type automobilistaUncheckedCreateNestedManyWithoutCartaconducaoInput = {
    create?: XOR<automobilistaCreateWithoutCartaconducaoInput, automobilistaUncheckedCreateWithoutCartaconducaoInput> | automobilistaCreateWithoutCartaconducaoInput[] | automobilistaUncheckedCreateWithoutCartaconducaoInput[]
    connectOrCreate?: automobilistaCreateOrConnectWithoutCartaconducaoInput | automobilistaCreateOrConnectWithoutCartaconducaoInput[]
    createMany?: automobilistaCreateManyCartaconducaoInputEnvelope
    connect?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
  }

  export type automobilistaUpdateManyWithoutCartaconducaoNestedInput = {
    create?: XOR<automobilistaCreateWithoutCartaconducaoInput, automobilistaUncheckedCreateWithoutCartaconducaoInput> | automobilistaCreateWithoutCartaconducaoInput[] | automobilistaUncheckedCreateWithoutCartaconducaoInput[]
    connectOrCreate?: automobilistaCreateOrConnectWithoutCartaconducaoInput | automobilistaCreateOrConnectWithoutCartaconducaoInput[]
    upsert?: automobilistaUpsertWithWhereUniqueWithoutCartaconducaoInput | automobilistaUpsertWithWhereUniqueWithoutCartaconducaoInput[]
    createMany?: automobilistaCreateManyCartaconducaoInputEnvelope
    set?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
    disconnect?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
    delete?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
    connect?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
    update?: automobilistaUpdateWithWhereUniqueWithoutCartaconducaoInput | automobilistaUpdateWithWhereUniqueWithoutCartaconducaoInput[]
    updateMany?: automobilistaUpdateManyWithWhereWithoutCartaconducaoInput | automobilistaUpdateManyWithWhereWithoutCartaconducaoInput[]
    deleteMany?: automobilistaScalarWhereInput | automobilistaScalarWhereInput[]
  }

  export type categoriacartaUpdateOneRequiredWithoutCartaconducaoNestedInput = {
    create?: XOR<categoriacartaCreateWithoutCartaconducaoInput, categoriacartaUncheckedCreateWithoutCartaconducaoInput>
    connectOrCreate?: categoriacartaCreateOrConnectWithoutCartaconducaoInput
    upsert?: categoriacartaUpsertWithoutCartaconducaoInput
    connect?: categoriacartaWhereUniqueInput
    update?: XOR<XOR<categoriacartaUpdateToOneWithWhereWithoutCartaconducaoInput, categoriacartaUpdateWithoutCartaconducaoInput>, categoriacartaUncheckedUpdateWithoutCartaconducaoInput>
  }

  export type ficheiroUpdateOneRequiredWithoutCartaconducaoNestedInput = {
    create?: XOR<ficheiroCreateWithoutCartaconducaoInput, ficheiroUncheckedCreateWithoutCartaconducaoInput>
    connectOrCreate?: ficheiroCreateOrConnectWithoutCartaconducaoInput
    upsert?: ficheiroUpsertWithoutCartaconducaoInput
    connect?: ficheiroWhereUniqueInput
    update?: XOR<XOR<ficheiroUpdateToOneWithWhereWithoutCartaconducaoInput, ficheiroUpdateWithoutCartaconducaoInput>, ficheiroUncheckedUpdateWithoutCartaconducaoInput>
  }

  export type automobilistaUncheckedUpdateManyWithoutCartaconducaoNestedInput = {
    create?: XOR<automobilistaCreateWithoutCartaconducaoInput, automobilistaUncheckedCreateWithoutCartaconducaoInput> | automobilistaCreateWithoutCartaconducaoInput[] | automobilistaUncheckedCreateWithoutCartaconducaoInput[]
    connectOrCreate?: automobilistaCreateOrConnectWithoutCartaconducaoInput | automobilistaCreateOrConnectWithoutCartaconducaoInput[]
    upsert?: automobilistaUpsertWithWhereUniqueWithoutCartaconducaoInput | automobilistaUpsertWithWhereUniqueWithoutCartaconducaoInput[]
    createMany?: automobilistaCreateManyCartaconducaoInputEnvelope
    set?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
    disconnect?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
    delete?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
    connect?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
    update?: automobilistaUpdateWithWhereUniqueWithoutCartaconducaoInput | automobilistaUpdateWithWhereUniqueWithoutCartaconducaoInput[]
    updateMany?: automobilistaUpdateManyWithWhereWithoutCartaconducaoInput | automobilistaUpdateManyWithWhereWithoutCartaconducaoInput[]
    deleteMany?: automobilistaScalarWhereInput | automobilistaScalarWhereInput[]
  }

  export type cartaconducaoCreateNestedManyWithoutCategoriacartaInput = {
    create?: XOR<cartaconducaoCreateWithoutCategoriacartaInput, cartaconducaoUncheckedCreateWithoutCategoriacartaInput> | cartaconducaoCreateWithoutCategoriacartaInput[] | cartaconducaoUncheckedCreateWithoutCategoriacartaInput[]
    connectOrCreate?: cartaconducaoCreateOrConnectWithoutCategoriacartaInput | cartaconducaoCreateOrConnectWithoutCategoriacartaInput[]
    createMany?: cartaconducaoCreateManyCategoriacartaInputEnvelope
    connect?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
  }

  export type cartaconducaoUncheckedCreateNestedManyWithoutCategoriacartaInput = {
    create?: XOR<cartaconducaoCreateWithoutCategoriacartaInput, cartaconducaoUncheckedCreateWithoutCategoriacartaInput> | cartaconducaoCreateWithoutCategoriacartaInput[] | cartaconducaoUncheckedCreateWithoutCategoriacartaInput[]
    connectOrCreate?: cartaconducaoCreateOrConnectWithoutCategoriacartaInput | cartaconducaoCreateOrConnectWithoutCategoriacartaInput[]
    createMany?: cartaconducaoCreateManyCategoriacartaInputEnvelope
    connect?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
  }

  export type cartaconducaoUpdateManyWithoutCategoriacartaNestedInput = {
    create?: XOR<cartaconducaoCreateWithoutCategoriacartaInput, cartaconducaoUncheckedCreateWithoutCategoriacartaInput> | cartaconducaoCreateWithoutCategoriacartaInput[] | cartaconducaoUncheckedCreateWithoutCategoriacartaInput[]
    connectOrCreate?: cartaconducaoCreateOrConnectWithoutCategoriacartaInput | cartaconducaoCreateOrConnectWithoutCategoriacartaInput[]
    upsert?: cartaconducaoUpsertWithWhereUniqueWithoutCategoriacartaInput | cartaconducaoUpsertWithWhereUniqueWithoutCategoriacartaInput[]
    createMany?: cartaconducaoCreateManyCategoriacartaInputEnvelope
    set?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
    disconnect?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
    delete?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
    connect?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
    update?: cartaconducaoUpdateWithWhereUniqueWithoutCategoriacartaInput | cartaconducaoUpdateWithWhereUniqueWithoutCategoriacartaInput[]
    updateMany?: cartaconducaoUpdateManyWithWhereWithoutCategoriacartaInput | cartaconducaoUpdateManyWithWhereWithoutCategoriacartaInput[]
    deleteMany?: cartaconducaoScalarWhereInput | cartaconducaoScalarWhereInput[]
  }

  export type cartaconducaoUncheckedUpdateManyWithoutCategoriacartaNestedInput = {
    create?: XOR<cartaconducaoCreateWithoutCategoriacartaInput, cartaconducaoUncheckedCreateWithoutCategoriacartaInput> | cartaconducaoCreateWithoutCategoriacartaInput[] | cartaconducaoUncheckedCreateWithoutCategoriacartaInput[]
    connectOrCreate?: cartaconducaoCreateOrConnectWithoutCategoriacartaInput | cartaconducaoCreateOrConnectWithoutCategoriacartaInput[]
    upsert?: cartaconducaoUpsertWithWhereUniqueWithoutCategoriacartaInput | cartaconducaoUpsertWithWhereUniqueWithoutCategoriacartaInput[]
    createMany?: cartaconducaoCreateManyCategoriacartaInputEnvelope
    set?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
    disconnect?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
    delete?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
    connect?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
    update?: cartaconducaoUpdateWithWhereUniqueWithoutCategoriacartaInput | cartaconducaoUpdateWithWhereUniqueWithoutCategoriacartaInput[]
    updateMany?: cartaconducaoUpdateManyWithWhereWithoutCategoriacartaInput | cartaconducaoUpdateManyWithWhereWithoutCategoriacartaInput[]
    deleteMany?: cartaconducaoScalarWhereInput | cartaconducaoScalarWhereInput[]
  }

  export type pessoaCreateNestedManyWithoutContactoInput = {
    create?: XOR<pessoaCreateWithoutContactoInput, pessoaUncheckedCreateWithoutContactoInput> | pessoaCreateWithoutContactoInput[] | pessoaUncheckedCreateWithoutContactoInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutContactoInput | pessoaCreateOrConnectWithoutContactoInput[]
    createMany?: pessoaCreateManyContactoInputEnvelope
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
  }

  export type pessoaUncheckedCreateNestedManyWithoutContactoInput = {
    create?: XOR<pessoaCreateWithoutContactoInput, pessoaUncheckedCreateWithoutContactoInput> | pessoaCreateWithoutContactoInput[] | pessoaUncheckedCreateWithoutContactoInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutContactoInput | pessoaCreateOrConnectWithoutContactoInput[]
    createMany?: pessoaCreateManyContactoInputEnvelope
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type pessoaUpdateManyWithoutContactoNestedInput = {
    create?: XOR<pessoaCreateWithoutContactoInput, pessoaUncheckedCreateWithoutContactoInput> | pessoaCreateWithoutContactoInput[] | pessoaUncheckedCreateWithoutContactoInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutContactoInput | pessoaCreateOrConnectWithoutContactoInput[]
    upsert?: pessoaUpsertWithWhereUniqueWithoutContactoInput | pessoaUpsertWithWhereUniqueWithoutContactoInput[]
    createMany?: pessoaCreateManyContactoInputEnvelope
    set?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    disconnect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    delete?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    update?: pessoaUpdateWithWhereUniqueWithoutContactoInput | pessoaUpdateWithWhereUniqueWithoutContactoInput[]
    updateMany?: pessoaUpdateManyWithWhereWithoutContactoInput | pessoaUpdateManyWithWhereWithoutContactoInput[]
    deleteMany?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
  }

  export type pessoaUncheckedUpdateManyWithoutContactoNestedInput = {
    create?: XOR<pessoaCreateWithoutContactoInput, pessoaUncheckedCreateWithoutContactoInput> | pessoaCreateWithoutContactoInput[] | pessoaUncheckedCreateWithoutContactoInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutContactoInput | pessoaCreateOrConnectWithoutContactoInput[]
    upsert?: pessoaUpsertWithWhereUniqueWithoutContactoInput | pessoaUpsertWithWhereUniqueWithoutContactoInput[]
    createMany?: pessoaCreateManyContactoInputEnvelope
    set?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    disconnect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    delete?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    update?: pessoaUpdateWithWhereUniqueWithoutContactoInput | pessoaUpdateWithWhereUniqueWithoutContactoInput[]
    updateMany?: pessoaUpdateManyWithWhereWithoutContactoInput | pessoaUpdateManyWithWhereWithoutContactoInput[]
    deleteMany?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
  }

  export type municipioCreateNestedOneWithoutEnderecoInput = {
    create?: XOR<municipioCreateWithoutEnderecoInput, municipioUncheckedCreateWithoutEnderecoInput>
    connectOrCreate?: municipioCreateOrConnectWithoutEnderecoInput
    connect?: municipioWhereUniqueInput
  }

  export type pessoaCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<pessoaCreateWithoutEnderecoInput, pessoaUncheckedCreateWithoutEnderecoInput> | pessoaCreateWithoutEnderecoInput[] | pessoaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutEnderecoInput | pessoaCreateOrConnectWithoutEnderecoInput[]
    createMany?: pessoaCreateManyEnderecoInputEnvelope
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
  }

  export type pessoaUncheckedCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<pessoaCreateWithoutEnderecoInput, pessoaUncheckedCreateWithoutEnderecoInput> | pessoaCreateWithoutEnderecoInput[] | pessoaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutEnderecoInput | pessoaCreateOrConnectWithoutEnderecoInput[]
    createMany?: pessoaCreateManyEnderecoInputEnvelope
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
  }

  export type municipioUpdateOneRequiredWithoutEnderecoNestedInput = {
    create?: XOR<municipioCreateWithoutEnderecoInput, municipioUncheckedCreateWithoutEnderecoInput>
    connectOrCreate?: municipioCreateOrConnectWithoutEnderecoInput
    upsert?: municipioUpsertWithoutEnderecoInput
    connect?: municipioWhereUniqueInput
    update?: XOR<XOR<municipioUpdateToOneWithWhereWithoutEnderecoInput, municipioUpdateWithoutEnderecoInput>, municipioUncheckedUpdateWithoutEnderecoInput>
  }

  export type pessoaUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<pessoaCreateWithoutEnderecoInput, pessoaUncheckedCreateWithoutEnderecoInput> | pessoaCreateWithoutEnderecoInput[] | pessoaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutEnderecoInput | pessoaCreateOrConnectWithoutEnderecoInput[]
    upsert?: pessoaUpsertWithWhereUniqueWithoutEnderecoInput | pessoaUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: pessoaCreateManyEnderecoInputEnvelope
    set?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    disconnect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    delete?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    update?: pessoaUpdateWithWhereUniqueWithoutEnderecoInput | pessoaUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: pessoaUpdateManyWithWhereWithoutEnderecoInput | pessoaUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
  }

  export type pessoaUncheckedUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<pessoaCreateWithoutEnderecoInput, pessoaUncheckedCreateWithoutEnderecoInput> | pessoaCreateWithoutEnderecoInput[] | pessoaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutEnderecoInput | pessoaCreateOrConnectWithoutEnderecoInput[]
    upsert?: pessoaUpsertWithWhereUniqueWithoutEnderecoInput | pessoaUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: pessoaCreateManyEnderecoInputEnvelope
    set?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    disconnect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    delete?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    update?: pessoaUpdateWithWhereUniqueWithoutEnderecoInput | pessoaUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: pessoaUpdateManyWithWhereWithoutEnderecoInput | pessoaUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
  }

  export type biCreateNestedManyWithoutFicheiroInput = {
    create?: XOR<biCreateWithoutFicheiroInput, biUncheckedCreateWithoutFicheiroInput> | biCreateWithoutFicheiroInput[] | biUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: biCreateOrConnectWithoutFicheiroInput | biCreateOrConnectWithoutFicheiroInput[]
    createMany?: biCreateManyFicheiroInputEnvelope
    connect?: biWhereUniqueInput | biWhereUniqueInput[]
  }

  export type cartaconducaoCreateNestedManyWithoutFicheiroInput = {
    create?: XOR<cartaconducaoCreateWithoutFicheiroInput, cartaconducaoUncheckedCreateWithoutFicheiroInput> | cartaconducaoCreateWithoutFicheiroInput[] | cartaconducaoUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: cartaconducaoCreateOrConnectWithoutFicheiroInput | cartaconducaoCreateOrConnectWithoutFicheiroInput[]
    createMany?: cartaconducaoCreateManyFicheiroInputEnvelope
    connect?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
  }

  export type funcionarioCreateNestedManyWithoutFicheiroInput = {
    create?: XOR<funcionarioCreateWithoutFicheiroInput, funcionarioUncheckedCreateWithoutFicheiroInput> | funcionarioCreateWithoutFicheiroInput[] | funcionarioUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: funcionarioCreateOrConnectWithoutFicheiroInput | funcionarioCreateOrConnectWithoutFicheiroInput[]
    createMany?: funcionarioCreateManyFicheiroInputEnvelope
    connect?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
  }

  export type pagamentomultaCreateNestedManyWithoutFicheiroInput = {
    create?: XOR<pagamentomultaCreateWithoutFicheiroInput, pagamentomultaUncheckedCreateWithoutFicheiroInput> | pagamentomultaCreateWithoutFicheiroInput[] | pagamentomultaUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: pagamentomultaCreateOrConnectWithoutFicheiroInput | pagamentomultaCreateOrConnectWithoutFicheiroInput[]
    createMany?: pagamentomultaCreateManyFicheiroInputEnvelope
    connect?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
  }

  export type titulopropriedadeCreateNestedManyWithoutFicheiroInput = {
    create?: XOR<titulopropriedadeCreateWithoutFicheiroInput, titulopropriedadeUncheckedCreateWithoutFicheiroInput> | titulopropriedadeCreateWithoutFicheiroInput[] | titulopropriedadeUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: titulopropriedadeCreateOrConnectWithoutFicheiroInput | titulopropriedadeCreateOrConnectWithoutFicheiroInput[]
    createMany?: titulopropriedadeCreateManyFicheiroInputEnvelope
    connect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
  }

  export type biUncheckedCreateNestedManyWithoutFicheiroInput = {
    create?: XOR<biCreateWithoutFicheiroInput, biUncheckedCreateWithoutFicheiroInput> | biCreateWithoutFicheiroInput[] | biUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: biCreateOrConnectWithoutFicheiroInput | biCreateOrConnectWithoutFicheiroInput[]
    createMany?: biCreateManyFicheiroInputEnvelope
    connect?: biWhereUniqueInput | biWhereUniqueInput[]
  }

  export type cartaconducaoUncheckedCreateNestedManyWithoutFicheiroInput = {
    create?: XOR<cartaconducaoCreateWithoutFicheiroInput, cartaconducaoUncheckedCreateWithoutFicheiroInput> | cartaconducaoCreateWithoutFicheiroInput[] | cartaconducaoUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: cartaconducaoCreateOrConnectWithoutFicheiroInput | cartaconducaoCreateOrConnectWithoutFicheiroInput[]
    createMany?: cartaconducaoCreateManyFicheiroInputEnvelope
    connect?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
  }

  export type funcionarioUncheckedCreateNestedManyWithoutFicheiroInput = {
    create?: XOR<funcionarioCreateWithoutFicheiroInput, funcionarioUncheckedCreateWithoutFicheiroInput> | funcionarioCreateWithoutFicheiroInput[] | funcionarioUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: funcionarioCreateOrConnectWithoutFicheiroInput | funcionarioCreateOrConnectWithoutFicheiroInput[]
    createMany?: funcionarioCreateManyFicheiroInputEnvelope
    connect?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
  }

  export type pagamentomultaUncheckedCreateNestedManyWithoutFicheiroInput = {
    create?: XOR<pagamentomultaCreateWithoutFicheiroInput, pagamentomultaUncheckedCreateWithoutFicheiroInput> | pagamentomultaCreateWithoutFicheiroInput[] | pagamentomultaUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: pagamentomultaCreateOrConnectWithoutFicheiroInput | pagamentomultaCreateOrConnectWithoutFicheiroInput[]
    createMany?: pagamentomultaCreateManyFicheiroInputEnvelope
    connect?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
  }

  export type titulopropriedadeUncheckedCreateNestedManyWithoutFicheiroInput = {
    create?: XOR<titulopropriedadeCreateWithoutFicheiroInput, titulopropriedadeUncheckedCreateWithoutFicheiroInput> | titulopropriedadeCreateWithoutFicheiroInput[] | titulopropriedadeUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: titulopropriedadeCreateOrConnectWithoutFicheiroInput | titulopropriedadeCreateOrConnectWithoutFicheiroInput[]
    createMany?: titulopropriedadeCreateManyFicheiroInputEnvelope
    connect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
  }

  export type NullableEnumficheiro_estadoValidacaoFieldUpdateOperationsInput = {
    set?: $Enums.ficheiro_estadoValidacao | null
  }

  export type biUpdateManyWithoutFicheiroNestedInput = {
    create?: XOR<biCreateWithoutFicheiroInput, biUncheckedCreateWithoutFicheiroInput> | biCreateWithoutFicheiroInput[] | biUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: biCreateOrConnectWithoutFicheiroInput | biCreateOrConnectWithoutFicheiroInput[]
    upsert?: biUpsertWithWhereUniqueWithoutFicheiroInput | biUpsertWithWhereUniqueWithoutFicheiroInput[]
    createMany?: biCreateManyFicheiroInputEnvelope
    set?: biWhereUniqueInput | biWhereUniqueInput[]
    disconnect?: biWhereUniqueInput | biWhereUniqueInput[]
    delete?: biWhereUniqueInput | biWhereUniqueInput[]
    connect?: biWhereUniqueInput | biWhereUniqueInput[]
    update?: biUpdateWithWhereUniqueWithoutFicheiroInput | biUpdateWithWhereUniqueWithoutFicheiroInput[]
    updateMany?: biUpdateManyWithWhereWithoutFicheiroInput | biUpdateManyWithWhereWithoutFicheiroInput[]
    deleteMany?: biScalarWhereInput | biScalarWhereInput[]
  }

  export type cartaconducaoUpdateManyWithoutFicheiroNestedInput = {
    create?: XOR<cartaconducaoCreateWithoutFicheiroInput, cartaconducaoUncheckedCreateWithoutFicheiroInput> | cartaconducaoCreateWithoutFicheiroInput[] | cartaconducaoUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: cartaconducaoCreateOrConnectWithoutFicheiroInput | cartaconducaoCreateOrConnectWithoutFicheiroInput[]
    upsert?: cartaconducaoUpsertWithWhereUniqueWithoutFicheiroInput | cartaconducaoUpsertWithWhereUniqueWithoutFicheiroInput[]
    createMany?: cartaconducaoCreateManyFicheiroInputEnvelope
    set?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
    disconnect?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
    delete?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
    connect?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
    update?: cartaconducaoUpdateWithWhereUniqueWithoutFicheiroInput | cartaconducaoUpdateWithWhereUniqueWithoutFicheiroInput[]
    updateMany?: cartaconducaoUpdateManyWithWhereWithoutFicheiroInput | cartaconducaoUpdateManyWithWhereWithoutFicheiroInput[]
    deleteMany?: cartaconducaoScalarWhereInput | cartaconducaoScalarWhereInput[]
  }

  export type funcionarioUpdateManyWithoutFicheiroNestedInput = {
    create?: XOR<funcionarioCreateWithoutFicheiroInput, funcionarioUncheckedCreateWithoutFicheiroInput> | funcionarioCreateWithoutFicheiroInput[] | funcionarioUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: funcionarioCreateOrConnectWithoutFicheiroInput | funcionarioCreateOrConnectWithoutFicheiroInput[]
    upsert?: funcionarioUpsertWithWhereUniqueWithoutFicheiroInput | funcionarioUpsertWithWhereUniqueWithoutFicheiroInput[]
    createMany?: funcionarioCreateManyFicheiroInputEnvelope
    set?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
    disconnect?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
    delete?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
    connect?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
    update?: funcionarioUpdateWithWhereUniqueWithoutFicheiroInput | funcionarioUpdateWithWhereUniqueWithoutFicheiroInput[]
    updateMany?: funcionarioUpdateManyWithWhereWithoutFicheiroInput | funcionarioUpdateManyWithWhereWithoutFicheiroInput[]
    deleteMany?: funcionarioScalarWhereInput | funcionarioScalarWhereInput[]
  }

  export type pagamentomultaUpdateManyWithoutFicheiroNestedInput = {
    create?: XOR<pagamentomultaCreateWithoutFicheiroInput, pagamentomultaUncheckedCreateWithoutFicheiroInput> | pagamentomultaCreateWithoutFicheiroInput[] | pagamentomultaUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: pagamentomultaCreateOrConnectWithoutFicheiroInput | pagamentomultaCreateOrConnectWithoutFicheiroInput[]
    upsert?: pagamentomultaUpsertWithWhereUniqueWithoutFicheiroInput | pagamentomultaUpsertWithWhereUniqueWithoutFicheiroInput[]
    createMany?: pagamentomultaCreateManyFicheiroInputEnvelope
    set?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
    disconnect?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
    delete?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
    connect?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
    update?: pagamentomultaUpdateWithWhereUniqueWithoutFicheiroInput | pagamentomultaUpdateWithWhereUniqueWithoutFicheiroInput[]
    updateMany?: pagamentomultaUpdateManyWithWhereWithoutFicheiroInput | pagamentomultaUpdateManyWithWhereWithoutFicheiroInput[]
    deleteMany?: pagamentomultaScalarWhereInput | pagamentomultaScalarWhereInput[]
  }

  export type titulopropriedadeUpdateManyWithoutFicheiroNestedInput = {
    create?: XOR<titulopropriedadeCreateWithoutFicheiroInput, titulopropriedadeUncheckedCreateWithoutFicheiroInput> | titulopropriedadeCreateWithoutFicheiroInput[] | titulopropriedadeUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: titulopropriedadeCreateOrConnectWithoutFicheiroInput | titulopropriedadeCreateOrConnectWithoutFicheiroInput[]
    upsert?: titulopropriedadeUpsertWithWhereUniqueWithoutFicheiroInput | titulopropriedadeUpsertWithWhereUniqueWithoutFicheiroInput[]
    createMany?: titulopropriedadeCreateManyFicheiroInputEnvelope
    set?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    disconnect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    delete?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    connect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    update?: titulopropriedadeUpdateWithWhereUniqueWithoutFicheiroInput | titulopropriedadeUpdateWithWhereUniqueWithoutFicheiroInput[]
    updateMany?: titulopropriedadeUpdateManyWithWhereWithoutFicheiroInput | titulopropriedadeUpdateManyWithWhereWithoutFicheiroInput[]
    deleteMany?: titulopropriedadeScalarWhereInput | titulopropriedadeScalarWhereInput[]
  }

  export type biUncheckedUpdateManyWithoutFicheiroNestedInput = {
    create?: XOR<biCreateWithoutFicheiroInput, biUncheckedCreateWithoutFicheiroInput> | biCreateWithoutFicheiroInput[] | biUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: biCreateOrConnectWithoutFicheiroInput | biCreateOrConnectWithoutFicheiroInput[]
    upsert?: biUpsertWithWhereUniqueWithoutFicheiroInput | biUpsertWithWhereUniqueWithoutFicheiroInput[]
    createMany?: biCreateManyFicheiroInputEnvelope
    set?: biWhereUniqueInput | biWhereUniqueInput[]
    disconnect?: biWhereUniqueInput | biWhereUniqueInput[]
    delete?: biWhereUniqueInput | biWhereUniqueInput[]
    connect?: biWhereUniqueInput | biWhereUniqueInput[]
    update?: biUpdateWithWhereUniqueWithoutFicheiroInput | biUpdateWithWhereUniqueWithoutFicheiroInput[]
    updateMany?: biUpdateManyWithWhereWithoutFicheiroInput | biUpdateManyWithWhereWithoutFicheiroInput[]
    deleteMany?: biScalarWhereInput | biScalarWhereInput[]
  }

  export type cartaconducaoUncheckedUpdateManyWithoutFicheiroNestedInput = {
    create?: XOR<cartaconducaoCreateWithoutFicheiroInput, cartaconducaoUncheckedCreateWithoutFicheiroInput> | cartaconducaoCreateWithoutFicheiroInput[] | cartaconducaoUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: cartaconducaoCreateOrConnectWithoutFicheiroInput | cartaconducaoCreateOrConnectWithoutFicheiroInput[]
    upsert?: cartaconducaoUpsertWithWhereUniqueWithoutFicheiroInput | cartaconducaoUpsertWithWhereUniqueWithoutFicheiroInput[]
    createMany?: cartaconducaoCreateManyFicheiroInputEnvelope
    set?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
    disconnect?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
    delete?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
    connect?: cartaconducaoWhereUniqueInput | cartaconducaoWhereUniqueInput[]
    update?: cartaconducaoUpdateWithWhereUniqueWithoutFicheiroInput | cartaconducaoUpdateWithWhereUniqueWithoutFicheiroInput[]
    updateMany?: cartaconducaoUpdateManyWithWhereWithoutFicheiroInput | cartaconducaoUpdateManyWithWhereWithoutFicheiroInput[]
    deleteMany?: cartaconducaoScalarWhereInput | cartaconducaoScalarWhereInput[]
  }

  export type funcionarioUncheckedUpdateManyWithoutFicheiroNestedInput = {
    create?: XOR<funcionarioCreateWithoutFicheiroInput, funcionarioUncheckedCreateWithoutFicheiroInput> | funcionarioCreateWithoutFicheiroInput[] | funcionarioUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: funcionarioCreateOrConnectWithoutFicheiroInput | funcionarioCreateOrConnectWithoutFicheiroInput[]
    upsert?: funcionarioUpsertWithWhereUniqueWithoutFicheiroInput | funcionarioUpsertWithWhereUniqueWithoutFicheiroInput[]
    createMany?: funcionarioCreateManyFicheiroInputEnvelope
    set?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
    disconnect?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
    delete?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
    connect?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
    update?: funcionarioUpdateWithWhereUniqueWithoutFicheiroInput | funcionarioUpdateWithWhereUniqueWithoutFicheiroInput[]
    updateMany?: funcionarioUpdateManyWithWhereWithoutFicheiroInput | funcionarioUpdateManyWithWhereWithoutFicheiroInput[]
    deleteMany?: funcionarioScalarWhereInput | funcionarioScalarWhereInput[]
  }

  export type pagamentomultaUncheckedUpdateManyWithoutFicheiroNestedInput = {
    create?: XOR<pagamentomultaCreateWithoutFicheiroInput, pagamentomultaUncheckedCreateWithoutFicheiroInput> | pagamentomultaCreateWithoutFicheiroInput[] | pagamentomultaUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: pagamentomultaCreateOrConnectWithoutFicheiroInput | pagamentomultaCreateOrConnectWithoutFicheiroInput[]
    upsert?: pagamentomultaUpsertWithWhereUniqueWithoutFicheiroInput | pagamentomultaUpsertWithWhereUniqueWithoutFicheiroInput[]
    createMany?: pagamentomultaCreateManyFicheiroInputEnvelope
    set?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
    disconnect?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
    delete?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
    connect?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
    update?: pagamentomultaUpdateWithWhereUniqueWithoutFicheiroInput | pagamentomultaUpdateWithWhereUniqueWithoutFicheiroInput[]
    updateMany?: pagamentomultaUpdateManyWithWhereWithoutFicheiroInput | pagamentomultaUpdateManyWithWhereWithoutFicheiroInput[]
    deleteMany?: pagamentomultaScalarWhereInput | pagamentomultaScalarWhereInput[]
  }

  export type titulopropriedadeUncheckedUpdateManyWithoutFicheiroNestedInput = {
    create?: XOR<titulopropriedadeCreateWithoutFicheiroInput, titulopropriedadeUncheckedCreateWithoutFicheiroInput> | titulopropriedadeCreateWithoutFicheiroInput[] | titulopropriedadeUncheckedCreateWithoutFicheiroInput[]
    connectOrCreate?: titulopropriedadeCreateOrConnectWithoutFicheiroInput | titulopropriedadeCreateOrConnectWithoutFicheiroInput[]
    upsert?: titulopropriedadeUpsertWithWhereUniqueWithoutFicheiroInput | titulopropriedadeUpsertWithWhereUniqueWithoutFicheiroInput[]
    createMany?: titulopropriedadeCreateManyFicheiroInputEnvelope
    set?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    disconnect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    delete?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    connect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    update?: titulopropriedadeUpdateWithWhereUniqueWithoutFicheiroInput | titulopropriedadeUpdateWithWhereUniqueWithoutFicheiroInput[]
    updateMany?: titulopropriedadeUpdateManyWithWhereWithoutFicheiroInput | titulopropriedadeUpdateManyWithWhereWithoutFicheiroInput[]
    deleteMany?: titulopropriedadeScalarWhereInput | titulopropriedadeScalarWhereInput[]
  }

  export type ficheiroCreateNestedOneWithoutFuncionarioInput = {
    create?: XOR<ficheiroCreateWithoutFuncionarioInput, ficheiroUncheckedCreateWithoutFuncionarioInput>
    connectOrCreate?: ficheiroCreateOrConnectWithoutFuncionarioInput
    connect?: ficheiroWhereUniqueInput
  }

  export type pessoaCreateNestedOneWithoutFuncionarioInput = {
    create?: XOR<pessoaCreateWithoutFuncionarioInput, pessoaUncheckedCreateWithoutFuncionarioInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutFuncionarioInput
    connect?: pessoaWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ficheiroUpdateOneRequiredWithoutFuncionarioNestedInput = {
    create?: XOR<ficheiroCreateWithoutFuncionarioInput, ficheiroUncheckedCreateWithoutFuncionarioInput>
    connectOrCreate?: ficheiroCreateOrConnectWithoutFuncionarioInput
    upsert?: ficheiroUpsertWithoutFuncionarioInput
    connect?: ficheiroWhereUniqueInput
    update?: XOR<XOR<ficheiroUpdateToOneWithWhereWithoutFuncionarioInput, ficheiroUpdateWithoutFuncionarioInput>, ficheiroUncheckedUpdateWithoutFuncionarioInput>
  }

  export type pessoaUpdateOneRequiredWithoutFuncionarioNestedInput = {
    create?: XOR<pessoaCreateWithoutFuncionarioInput, pessoaUncheckedCreateWithoutFuncionarioInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutFuncionarioInput
    upsert?: pessoaUpsertWithoutFuncionarioInput
    connect?: pessoaWhereUniqueInput
    update?: XOR<XOR<pessoaUpdateToOneWithWhereWithoutFuncionarioInput, pessoaUpdateWithoutFuncionarioInput>, pessoaUncheckedUpdateWithoutFuncionarioInput>
  }

  export type multaCreateNestedOneWithoutInfracao_infracao_codMultaTomultaInput = {
    create?: XOR<multaCreateWithoutInfracao_infracao_codMultaTomultaInput, multaUncheckedCreateWithoutInfracao_infracao_codMultaTomultaInput>
    connectOrCreate?: multaCreateOrConnectWithoutInfracao_infracao_codMultaTomultaInput
    connect?: multaWhereUniqueInput
  }

  export type tipoinfracaoCreateNestedOneWithoutInfracaoInput = {
    create?: XOR<tipoinfracaoCreateWithoutInfracaoInput, tipoinfracaoUncheckedCreateWithoutInfracaoInput>
    connectOrCreate?: tipoinfracaoCreateOrConnectWithoutInfracaoInput
    connect?: tipoinfracaoWhereUniqueInput
  }

  export type multaCreateNestedManyWithoutInfracao_multa_codInfracaoToinfracaoInput = {
    create?: XOR<multaCreateWithoutInfracao_multa_codInfracaoToinfracaoInput, multaUncheckedCreateWithoutInfracao_multa_codInfracaoToinfracaoInput> | multaCreateWithoutInfracao_multa_codInfracaoToinfracaoInput[] | multaUncheckedCreateWithoutInfracao_multa_codInfracaoToinfracaoInput[]
    connectOrCreate?: multaCreateOrConnectWithoutInfracao_multa_codInfracaoToinfracaoInput | multaCreateOrConnectWithoutInfracao_multa_codInfracaoToinfracaoInput[]
    createMany?: multaCreateManyInfracao_multa_codInfracaoToinfracaoInputEnvelope
    connect?: multaWhereUniqueInput | multaWhereUniqueInput[]
  }

  export type multaUncheckedCreateNestedManyWithoutInfracao_multa_codInfracaoToinfracaoInput = {
    create?: XOR<multaCreateWithoutInfracao_multa_codInfracaoToinfracaoInput, multaUncheckedCreateWithoutInfracao_multa_codInfracaoToinfracaoInput> | multaCreateWithoutInfracao_multa_codInfracaoToinfracaoInput[] | multaUncheckedCreateWithoutInfracao_multa_codInfracaoToinfracaoInput[]
    connectOrCreate?: multaCreateOrConnectWithoutInfracao_multa_codInfracaoToinfracaoInput | multaCreateOrConnectWithoutInfracao_multa_codInfracaoToinfracaoInput[]
    createMany?: multaCreateManyInfracao_multa_codInfracaoToinfracaoInputEnvelope
    connect?: multaWhereUniqueInput | multaWhereUniqueInput[]
  }

  export type multaUpdateOneRequiredWithoutInfracao_infracao_codMultaTomultaNestedInput = {
    create?: XOR<multaCreateWithoutInfracao_infracao_codMultaTomultaInput, multaUncheckedCreateWithoutInfracao_infracao_codMultaTomultaInput>
    connectOrCreate?: multaCreateOrConnectWithoutInfracao_infracao_codMultaTomultaInput
    upsert?: multaUpsertWithoutInfracao_infracao_codMultaTomultaInput
    connect?: multaWhereUniqueInput
    update?: XOR<XOR<multaUpdateToOneWithWhereWithoutInfracao_infracao_codMultaTomultaInput, multaUpdateWithoutInfracao_infracao_codMultaTomultaInput>, multaUncheckedUpdateWithoutInfracao_infracao_codMultaTomultaInput>
  }

  export type tipoinfracaoUpdateOneRequiredWithoutInfracaoNestedInput = {
    create?: XOR<tipoinfracaoCreateWithoutInfracaoInput, tipoinfracaoUncheckedCreateWithoutInfracaoInput>
    connectOrCreate?: tipoinfracaoCreateOrConnectWithoutInfracaoInput
    upsert?: tipoinfracaoUpsertWithoutInfracaoInput
    connect?: tipoinfracaoWhereUniqueInput
    update?: XOR<XOR<tipoinfracaoUpdateToOneWithWhereWithoutInfracaoInput, tipoinfracaoUpdateWithoutInfracaoInput>, tipoinfracaoUncheckedUpdateWithoutInfracaoInput>
  }

  export type multaUpdateManyWithoutInfracao_multa_codInfracaoToinfracaoNestedInput = {
    create?: XOR<multaCreateWithoutInfracao_multa_codInfracaoToinfracaoInput, multaUncheckedCreateWithoutInfracao_multa_codInfracaoToinfracaoInput> | multaCreateWithoutInfracao_multa_codInfracaoToinfracaoInput[] | multaUncheckedCreateWithoutInfracao_multa_codInfracaoToinfracaoInput[]
    connectOrCreate?: multaCreateOrConnectWithoutInfracao_multa_codInfracaoToinfracaoInput | multaCreateOrConnectWithoutInfracao_multa_codInfracaoToinfracaoInput[]
    upsert?: multaUpsertWithWhereUniqueWithoutInfracao_multa_codInfracaoToinfracaoInput | multaUpsertWithWhereUniqueWithoutInfracao_multa_codInfracaoToinfracaoInput[]
    createMany?: multaCreateManyInfracao_multa_codInfracaoToinfracaoInputEnvelope
    set?: multaWhereUniqueInput | multaWhereUniqueInput[]
    disconnect?: multaWhereUniqueInput | multaWhereUniqueInput[]
    delete?: multaWhereUniqueInput | multaWhereUniqueInput[]
    connect?: multaWhereUniqueInput | multaWhereUniqueInput[]
    update?: multaUpdateWithWhereUniqueWithoutInfracao_multa_codInfracaoToinfracaoInput | multaUpdateWithWhereUniqueWithoutInfracao_multa_codInfracaoToinfracaoInput[]
    updateMany?: multaUpdateManyWithWhereWithoutInfracao_multa_codInfracaoToinfracaoInput | multaUpdateManyWithWhereWithoutInfracao_multa_codInfracaoToinfracaoInput[]
    deleteMany?: multaScalarWhereInput | multaScalarWhereInput[]
  }

  export type multaUncheckedUpdateManyWithoutInfracao_multa_codInfracaoToinfracaoNestedInput = {
    create?: XOR<multaCreateWithoutInfracao_multa_codInfracaoToinfracaoInput, multaUncheckedCreateWithoutInfracao_multa_codInfracaoToinfracaoInput> | multaCreateWithoutInfracao_multa_codInfracaoToinfracaoInput[] | multaUncheckedCreateWithoutInfracao_multa_codInfracaoToinfracaoInput[]
    connectOrCreate?: multaCreateOrConnectWithoutInfracao_multa_codInfracaoToinfracaoInput | multaCreateOrConnectWithoutInfracao_multa_codInfracaoToinfracaoInput[]
    upsert?: multaUpsertWithWhereUniqueWithoutInfracao_multa_codInfracaoToinfracaoInput | multaUpsertWithWhereUniqueWithoutInfracao_multa_codInfracaoToinfracaoInput[]
    createMany?: multaCreateManyInfracao_multa_codInfracaoToinfracaoInputEnvelope
    set?: multaWhereUniqueInput | multaWhereUniqueInput[]
    disconnect?: multaWhereUniqueInput | multaWhereUniqueInput[]
    delete?: multaWhereUniqueInput | multaWhereUniqueInput[]
    connect?: multaWhereUniqueInput | multaWhereUniqueInput[]
    update?: multaUpdateWithWhereUniqueWithoutInfracao_multa_codInfracaoToinfracaoInput | multaUpdateWithWhereUniqueWithoutInfracao_multa_codInfracaoToinfracaoInput[]
    updateMany?: multaUpdateManyWithWhereWithoutInfracao_multa_codInfracaoToinfracaoInput | multaUpdateManyWithWhereWithoutInfracao_multa_codInfracaoToinfracaoInput[]
    deleteMany?: multaScalarWhereInput | multaScalarWhereInput[]
  }

  export type marcaCreateNestedOneWithoutLivreteInput = {
    create?: XOR<marcaCreateWithoutLivreteInput, marcaUncheckedCreateWithoutLivreteInput>
    connectOrCreate?: marcaCreateOrConnectWithoutLivreteInput
    connect?: marcaWhereUniqueInput
  }

  export type viaturaCreateNestedOneWithoutLivreteInput = {
    create?: XOR<viaturaCreateWithoutLivreteInput, viaturaUncheckedCreateWithoutLivreteInput>
    connectOrCreate?: viaturaCreateOrConnectWithoutLivreteInput
    connect?: viaturaWhereUniqueInput
  }

  export type serivicoviaturaCreateNestedOneWithoutLivreteInput = {
    create?: XOR<serivicoviaturaCreateWithoutLivreteInput, serivicoviaturaUncheckedCreateWithoutLivreteInput>
    connectOrCreate?: serivicoviaturaCreateOrConnectWithoutLivreteInput
    connect?: serivicoviaturaWhereUniqueInput
  }

  export type marcaUpdateOneRequiredWithoutLivreteNestedInput = {
    create?: XOR<marcaCreateWithoutLivreteInput, marcaUncheckedCreateWithoutLivreteInput>
    connectOrCreate?: marcaCreateOrConnectWithoutLivreteInput
    upsert?: marcaUpsertWithoutLivreteInput
    connect?: marcaWhereUniqueInput
    update?: XOR<XOR<marcaUpdateToOneWithWhereWithoutLivreteInput, marcaUpdateWithoutLivreteInput>, marcaUncheckedUpdateWithoutLivreteInput>
  }

  export type viaturaUpdateOneRequiredWithoutLivreteNestedInput = {
    create?: XOR<viaturaCreateWithoutLivreteInput, viaturaUncheckedCreateWithoutLivreteInput>
    connectOrCreate?: viaturaCreateOrConnectWithoutLivreteInput
    upsert?: viaturaUpsertWithoutLivreteInput
    connect?: viaturaWhereUniqueInput
    update?: XOR<XOR<viaturaUpdateToOneWithWhereWithoutLivreteInput, viaturaUpdateWithoutLivreteInput>, viaturaUncheckedUpdateWithoutLivreteInput>
  }

  export type serivicoviaturaUpdateOneRequiredWithoutLivreteNestedInput = {
    create?: XOR<serivicoviaturaCreateWithoutLivreteInput, serivicoviaturaUncheckedCreateWithoutLivreteInput>
    connectOrCreate?: serivicoviaturaCreateOrConnectWithoutLivreteInput
    upsert?: serivicoviaturaUpsertWithoutLivreteInput
    connect?: serivicoviaturaWhereUniqueInput
    update?: XOR<XOR<serivicoviaturaUpdateToOneWithWhereWithoutLivreteInput, serivicoviaturaUpdateWithoutLivreteInput>, serivicoviaturaUncheckedUpdateWithoutLivreteInput>
  }

  export type livreteCreateNestedManyWithoutMarcaInput = {
    create?: XOR<livreteCreateWithoutMarcaInput, livreteUncheckedCreateWithoutMarcaInput> | livreteCreateWithoutMarcaInput[] | livreteUncheckedCreateWithoutMarcaInput[]
    connectOrCreate?: livreteCreateOrConnectWithoutMarcaInput | livreteCreateOrConnectWithoutMarcaInput[]
    createMany?: livreteCreateManyMarcaInputEnvelope
    connect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
  }

  export type livreteUncheckedCreateNestedManyWithoutMarcaInput = {
    create?: XOR<livreteCreateWithoutMarcaInput, livreteUncheckedCreateWithoutMarcaInput> | livreteCreateWithoutMarcaInput[] | livreteUncheckedCreateWithoutMarcaInput[]
    connectOrCreate?: livreteCreateOrConnectWithoutMarcaInput | livreteCreateOrConnectWithoutMarcaInput[]
    createMany?: livreteCreateManyMarcaInputEnvelope
    connect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
  }

  export type livreteUpdateManyWithoutMarcaNestedInput = {
    create?: XOR<livreteCreateWithoutMarcaInput, livreteUncheckedCreateWithoutMarcaInput> | livreteCreateWithoutMarcaInput[] | livreteUncheckedCreateWithoutMarcaInput[]
    connectOrCreate?: livreteCreateOrConnectWithoutMarcaInput | livreteCreateOrConnectWithoutMarcaInput[]
    upsert?: livreteUpsertWithWhereUniqueWithoutMarcaInput | livreteUpsertWithWhereUniqueWithoutMarcaInput[]
    createMany?: livreteCreateManyMarcaInputEnvelope
    set?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    disconnect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    delete?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    connect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    update?: livreteUpdateWithWhereUniqueWithoutMarcaInput | livreteUpdateWithWhereUniqueWithoutMarcaInput[]
    updateMany?: livreteUpdateManyWithWhereWithoutMarcaInput | livreteUpdateManyWithWhereWithoutMarcaInput[]
    deleteMany?: livreteScalarWhereInput | livreteScalarWhereInput[]
  }

  export type livreteUncheckedUpdateManyWithoutMarcaNestedInput = {
    create?: XOR<livreteCreateWithoutMarcaInput, livreteUncheckedCreateWithoutMarcaInput> | livreteCreateWithoutMarcaInput[] | livreteUncheckedCreateWithoutMarcaInput[]
    connectOrCreate?: livreteCreateOrConnectWithoutMarcaInput | livreteCreateOrConnectWithoutMarcaInput[]
    upsert?: livreteUpsertWithWhereUniqueWithoutMarcaInput | livreteUpsertWithWhereUniqueWithoutMarcaInput[]
    createMany?: livreteCreateManyMarcaInputEnvelope
    set?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    disconnect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    delete?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    connect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    update?: livreteUpdateWithWhereUniqueWithoutMarcaInput | livreteUpdateWithWhereUniqueWithoutMarcaInput[]
    updateMany?: livreteUpdateManyWithWhereWithoutMarcaInput | livreteUpdateManyWithWhereWithoutMarcaInput[]
    deleteMany?: livreteScalarWhereInput | livreteScalarWhereInput[]
  }

  export type infracaoCreateNestedManyWithoutMulta_infracao_codMultaTomultaInput = {
    create?: XOR<infracaoCreateWithoutMulta_infracao_codMultaTomultaInput, infracaoUncheckedCreateWithoutMulta_infracao_codMultaTomultaInput> | infracaoCreateWithoutMulta_infracao_codMultaTomultaInput[] | infracaoUncheckedCreateWithoutMulta_infracao_codMultaTomultaInput[]
    connectOrCreate?: infracaoCreateOrConnectWithoutMulta_infracao_codMultaTomultaInput | infracaoCreateOrConnectWithoutMulta_infracao_codMultaTomultaInput[]
    createMany?: infracaoCreateManyMulta_infracao_codMultaTomultaInputEnvelope
    connect?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
  }

  export type automobilistaCreateNestedOneWithoutMultaInput = {
    create?: XOR<automobilistaCreateWithoutMultaInput, automobilistaUncheckedCreateWithoutMultaInput>
    connectOrCreate?: automobilistaCreateOrConnectWithoutMultaInput
    connect?: automobilistaWhereUniqueInput
  }

  export type infracaoCreateNestedOneWithoutMulta_multa_codInfracaoToinfracaoInput = {
    create?: XOR<infracaoCreateWithoutMulta_multa_codInfracaoToinfracaoInput, infracaoUncheckedCreateWithoutMulta_multa_codInfracaoToinfracaoInput>
    connectOrCreate?: infracaoCreateOrConnectWithoutMulta_multa_codInfracaoToinfracaoInput
    connect?: infracaoWhereUniqueInput
  }

  export type viaturaCreateNestedOneWithoutMultaInput = {
    create?: XOR<viaturaCreateWithoutMultaInput, viaturaUncheckedCreateWithoutMultaInput>
    connectOrCreate?: viaturaCreateOrConnectWithoutMultaInput
    connect?: viaturaWhereUniqueInput
  }

  export type pagamentomultaCreateNestedManyWithoutMultaInput = {
    create?: XOR<pagamentomultaCreateWithoutMultaInput, pagamentomultaUncheckedCreateWithoutMultaInput> | pagamentomultaCreateWithoutMultaInput[] | pagamentomultaUncheckedCreateWithoutMultaInput[]
    connectOrCreate?: pagamentomultaCreateOrConnectWithoutMultaInput | pagamentomultaCreateOrConnectWithoutMultaInput[]
    createMany?: pagamentomultaCreateManyMultaInputEnvelope
    connect?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
  }

  export type infracaoUncheckedCreateNestedManyWithoutMulta_infracao_codMultaTomultaInput = {
    create?: XOR<infracaoCreateWithoutMulta_infracao_codMultaTomultaInput, infracaoUncheckedCreateWithoutMulta_infracao_codMultaTomultaInput> | infracaoCreateWithoutMulta_infracao_codMultaTomultaInput[] | infracaoUncheckedCreateWithoutMulta_infracao_codMultaTomultaInput[]
    connectOrCreate?: infracaoCreateOrConnectWithoutMulta_infracao_codMultaTomultaInput | infracaoCreateOrConnectWithoutMulta_infracao_codMultaTomultaInput[]
    createMany?: infracaoCreateManyMulta_infracao_codMultaTomultaInputEnvelope
    connect?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
  }

  export type pagamentomultaUncheckedCreateNestedManyWithoutMultaInput = {
    create?: XOR<pagamentomultaCreateWithoutMultaInput, pagamentomultaUncheckedCreateWithoutMultaInput> | pagamentomultaCreateWithoutMultaInput[] | pagamentomultaUncheckedCreateWithoutMultaInput[]
    connectOrCreate?: pagamentomultaCreateOrConnectWithoutMultaInput | pagamentomultaCreateOrConnectWithoutMultaInput[]
    createMany?: pagamentomultaCreateManyMultaInputEnvelope
    connect?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
  }

  export type Enummulta_estadoMultaFieldUpdateOperationsInput = {
    set?: $Enums.multa_estadoMulta
  }

  export type infracaoUpdateManyWithoutMulta_infracao_codMultaTomultaNestedInput = {
    create?: XOR<infracaoCreateWithoutMulta_infracao_codMultaTomultaInput, infracaoUncheckedCreateWithoutMulta_infracao_codMultaTomultaInput> | infracaoCreateWithoutMulta_infracao_codMultaTomultaInput[] | infracaoUncheckedCreateWithoutMulta_infracao_codMultaTomultaInput[]
    connectOrCreate?: infracaoCreateOrConnectWithoutMulta_infracao_codMultaTomultaInput | infracaoCreateOrConnectWithoutMulta_infracao_codMultaTomultaInput[]
    upsert?: infracaoUpsertWithWhereUniqueWithoutMulta_infracao_codMultaTomultaInput | infracaoUpsertWithWhereUniqueWithoutMulta_infracao_codMultaTomultaInput[]
    createMany?: infracaoCreateManyMulta_infracao_codMultaTomultaInputEnvelope
    set?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
    disconnect?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
    delete?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
    connect?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
    update?: infracaoUpdateWithWhereUniqueWithoutMulta_infracao_codMultaTomultaInput | infracaoUpdateWithWhereUniqueWithoutMulta_infracao_codMultaTomultaInput[]
    updateMany?: infracaoUpdateManyWithWhereWithoutMulta_infracao_codMultaTomultaInput | infracaoUpdateManyWithWhereWithoutMulta_infracao_codMultaTomultaInput[]
    deleteMany?: infracaoScalarWhereInput | infracaoScalarWhereInput[]
  }

  export type automobilistaUpdateOneWithoutMultaNestedInput = {
    create?: XOR<automobilistaCreateWithoutMultaInput, automobilistaUncheckedCreateWithoutMultaInput>
    connectOrCreate?: automobilistaCreateOrConnectWithoutMultaInput
    upsert?: automobilistaUpsertWithoutMultaInput
    disconnect?: automobilistaWhereInput | boolean
    delete?: automobilistaWhereInput | boolean
    connect?: automobilistaWhereUniqueInput
    update?: XOR<XOR<automobilistaUpdateToOneWithWhereWithoutMultaInput, automobilistaUpdateWithoutMultaInput>, automobilistaUncheckedUpdateWithoutMultaInput>
  }

  export type infracaoUpdateOneRequiredWithoutMulta_multa_codInfracaoToinfracaoNestedInput = {
    create?: XOR<infracaoCreateWithoutMulta_multa_codInfracaoToinfracaoInput, infracaoUncheckedCreateWithoutMulta_multa_codInfracaoToinfracaoInput>
    connectOrCreate?: infracaoCreateOrConnectWithoutMulta_multa_codInfracaoToinfracaoInput
    upsert?: infracaoUpsertWithoutMulta_multa_codInfracaoToinfracaoInput
    connect?: infracaoWhereUniqueInput
    update?: XOR<XOR<infracaoUpdateToOneWithWhereWithoutMulta_multa_codInfracaoToinfracaoInput, infracaoUpdateWithoutMulta_multa_codInfracaoToinfracaoInput>, infracaoUncheckedUpdateWithoutMulta_multa_codInfracaoToinfracaoInput>
  }

  export type viaturaUpdateOneWithoutMultaNestedInput = {
    create?: XOR<viaturaCreateWithoutMultaInput, viaturaUncheckedCreateWithoutMultaInput>
    connectOrCreate?: viaturaCreateOrConnectWithoutMultaInput
    upsert?: viaturaUpsertWithoutMultaInput
    disconnect?: viaturaWhereInput | boolean
    delete?: viaturaWhereInput | boolean
    connect?: viaturaWhereUniqueInput
    update?: XOR<XOR<viaturaUpdateToOneWithWhereWithoutMultaInput, viaturaUpdateWithoutMultaInput>, viaturaUncheckedUpdateWithoutMultaInput>
  }

  export type pagamentomultaUpdateManyWithoutMultaNestedInput = {
    create?: XOR<pagamentomultaCreateWithoutMultaInput, pagamentomultaUncheckedCreateWithoutMultaInput> | pagamentomultaCreateWithoutMultaInput[] | pagamentomultaUncheckedCreateWithoutMultaInput[]
    connectOrCreate?: pagamentomultaCreateOrConnectWithoutMultaInput | pagamentomultaCreateOrConnectWithoutMultaInput[]
    upsert?: pagamentomultaUpsertWithWhereUniqueWithoutMultaInput | pagamentomultaUpsertWithWhereUniqueWithoutMultaInput[]
    createMany?: pagamentomultaCreateManyMultaInputEnvelope
    set?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
    disconnect?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
    delete?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
    connect?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
    update?: pagamentomultaUpdateWithWhereUniqueWithoutMultaInput | pagamentomultaUpdateWithWhereUniqueWithoutMultaInput[]
    updateMany?: pagamentomultaUpdateManyWithWhereWithoutMultaInput | pagamentomultaUpdateManyWithWhereWithoutMultaInput[]
    deleteMany?: pagamentomultaScalarWhereInput | pagamentomultaScalarWhereInput[]
  }

  export type infracaoUncheckedUpdateManyWithoutMulta_infracao_codMultaTomultaNestedInput = {
    create?: XOR<infracaoCreateWithoutMulta_infracao_codMultaTomultaInput, infracaoUncheckedCreateWithoutMulta_infracao_codMultaTomultaInput> | infracaoCreateWithoutMulta_infracao_codMultaTomultaInput[] | infracaoUncheckedCreateWithoutMulta_infracao_codMultaTomultaInput[]
    connectOrCreate?: infracaoCreateOrConnectWithoutMulta_infracao_codMultaTomultaInput | infracaoCreateOrConnectWithoutMulta_infracao_codMultaTomultaInput[]
    upsert?: infracaoUpsertWithWhereUniqueWithoutMulta_infracao_codMultaTomultaInput | infracaoUpsertWithWhereUniqueWithoutMulta_infracao_codMultaTomultaInput[]
    createMany?: infracaoCreateManyMulta_infracao_codMultaTomultaInputEnvelope
    set?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
    disconnect?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
    delete?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
    connect?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
    update?: infracaoUpdateWithWhereUniqueWithoutMulta_infracao_codMultaTomultaInput | infracaoUpdateWithWhereUniqueWithoutMulta_infracao_codMultaTomultaInput[]
    updateMany?: infracaoUpdateManyWithWhereWithoutMulta_infracao_codMultaTomultaInput | infracaoUpdateManyWithWhereWithoutMulta_infracao_codMultaTomultaInput[]
    deleteMany?: infracaoScalarWhereInput | infracaoScalarWhereInput[]
  }

  export type pagamentomultaUncheckedUpdateManyWithoutMultaNestedInput = {
    create?: XOR<pagamentomultaCreateWithoutMultaInput, pagamentomultaUncheckedCreateWithoutMultaInput> | pagamentomultaCreateWithoutMultaInput[] | pagamentomultaUncheckedCreateWithoutMultaInput[]
    connectOrCreate?: pagamentomultaCreateOrConnectWithoutMultaInput | pagamentomultaCreateOrConnectWithoutMultaInput[]
    upsert?: pagamentomultaUpsertWithWhereUniqueWithoutMultaInput | pagamentomultaUpsertWithWhereUniqueWithoutMultaInput[]
    createMany?: pagamentomultaCreateManyMultaInputEnvelope
    set?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
    disconnect?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
    delete?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
    connect?: pagamentomultaWhereUniqueInput | pagamentomultaWhereUniqueInput[]
    update?: pagamentomultaUpdateWithWhereUniqueWithoutMultaInput | pagamentomultaUpdateWithWhereUniqueWithoutMultaInput[]
    updateMany?: pagamentomultaUpdateManyWithWhereWithoutMultaInput | pagamentomultaUpdateManyWithWhereWithoutMultaInput[]
    deleteMany?: pagamentomultaScalarWhereInput | pagamentomultaScalarWhereInput[]
  }

  export type enderecoCreateNestedManyWithoutMunicipioInput = {
    create?: XOR<enderecoCreateWithoutMunicipioInput, enderecoUncheckedCreateWithoutMunicipioInput> | enderecoCreateWithoutMunicipioInput[] | enderecoUncheckedCreateWithoutMunicipioInput[]
    connectOrCreate?: enderecoCreateOrConnectWithoutMunicipioInput | enderecoCreateOrConnectWithoutMunicipioInput[]
    createMany?: enderecoCreateManyMunicipioInputEnvelope
    connect?: enderecoWhereUniqueInput | enderecoWhereUniqueInput[]
  }

  export type provinciaCreateNestedOneWithoutMunicipioInput = {
    create?: XOR<provinciaCreateWithoutMunicipioInput, provinciaUncheckedCreateWithoutMunicipioInput>
    connectOrCreate?: provinciaCreateOrConnectWithoutMunicipioInput
    connect?: provinciaWhereUniqueInput
  }

  export type enderecoUncheckedCreateNestedManyWithoutMunicipioInput = {
    create?: XOR<enderecoCreateWithoutMunicipioInput, enderecoUncheckedCreateWithoutMunicipioInput> | enderecoCreateWithoutMunicipioInput[] | enderecoUncheckedCreateWithoutMunicipioInput[]
    connectOrCreate?: enderecoCreateOrConnectWithoutMunicipioInput | enderecoCreateOrConnectWithoutMunicipioInput[]
    createMany?: enderecoCreateManyMunicipioInputEnvelope
    connect?: enderecoWhereUniqueInput | enderecoWhereUniqueInput[]
  }

  export type enderecoUpdateManyWithoutMunicipioNestedInput = {
    create?: XOR<enderecoCreateWithoutMunicipioInput, enderecoUncheckedCreateWithoutMunicipioInput> | enderecoCreateWithoutMunicipioInput[] | enderecoUncheckedCreateWithoutMunicipioInput[]
    connectOrCreate?: enderecoCreateOrConnectWithoutMunicipioInput | enderecoCreateOrConnectWithoutMunicipioInput[]
    upsert?: enderecoUpsertWithWhereUniqueWithoutMunicipioInput | enderecoUpsertWithWhereUniqueWithoutMunicipioInput[]
    createMany?: enderecoCreateManyMunicipioInputEnvelope
    set?: enderecoWhereUniqueInput | enderecoWhereUniqueInput[]
    disconnect?: enderecoWhereUniqueInput | enderecoWhereUniqueInput[]
    delete?: enderecoWhereUniqueInput | enderecoWhereUniqueInput[]
    connect?: enderecoWhereUniqueInput | enderecoWhereUniqueInput[]
    update?: enderecoUpdateWithWhereUniqueWithoutMunicipioInput | enderecoUpdateWithWhereUniqueWithoutMunicipioInput[]
    updateMany?: enderecoUpdateManyWithWhereWithoutMunicipioInput | enderecoUpdateManyWithWhereWithoutMunicipioInput[]
    deleteMany?: enderecoScalarWhereInput | enderecoScalarWhereInput[]
  }

  export type provinciaUpdateOneRequiredWithoutMunicipioNestedInput = {
    create?: XOR<provinciaCreateWithoutMunicipioInput, provinciaUncheckedCreateWithoutMunicipioInput>
    connectOrCreate?: provinciaCreateOrConnectWithoutMunicipioInput
    upsert?: provinciaUpsertWithoutMunicipioInput
    connect?: provinciaWhereUniqueInput
    update?: XOR<XOR<provinciaUpdateToOneWithWhereWithoutMunicipioInput, provinciaUpdateWithoutMunicipioInput>, provinciaUncheckedUpdateWithoutMunicipioInput>
  }

  export type enderecoUncheckedUpdateManyWithoutMunicipioNestedInput = {
    create?: XOR<enderecoCreateWithoutMunicipioInput, enderecoUncheckedCreateWithoutMunicipioInput> | enderecoCreateWithoutMunicipioInput[] | enderecoUncheckedCreateWithoutMunicipioInput[]
    connectOrCreate?: enderecoCreateOrConnectWithoutMunicipioInput | enderecoCreateOrConnectWithoutMunicipioInput[]
    upsert?: enderecoUpsertWithWhereUniqueWithoutMunicipioInput | enderecoUpsertWithWhereUniqueWithoutMunicipioInput[]
    createMany?: enderecoCreateManyMunicipioInputEnvelope
    set?: enderecoWhereUniqueInput | enderecoWhereUniqueInput[]
    disconnect?: enderecoWhereUniqueInput | enderecoWhereUniqueInput[]
    delete?: enderecoWhereUniqueInput | enderecoWhereUniqueInput[]
    connect?: enderecoWhereUniqueInput | enderecoWhereUniqueInput[]
    update?: enderecoUpdateWithWhereUniqueWithoutMunicipioInput | enderecoUpdateWithWhereUniqueWithoutMunicipioInput[]
    updateMany?: enderecoUpdateManyWithWhereWithoutMunicipioInput | enderecoUpdateManyWithWhereWithoutMunicipioInput[]
    deleteMany?: enderecoScalarWhereInput | enderecoScalarWhereInput[]
  }

  export type multaCreateNestedOneWithoutPagamentomultaInput = {
    create?: XOR<multaCreateWithoutPagamentomultaInput, multaUncheckedCreateWithoutPagamentomultaInput>
    connectOrCreate?: multaCreateOrConnectWithoutPagamentomultaInput
    connect?: multaWhereUniqueInput
  }

  export type ficheiroCreateNestedOneWithoutPagamentomultaInput = {
    create?: XOR<ficheiroCreateWithoutPagamentomultaInput, ficheiroUncheckedCreateWithoutPagamentomultaInput>
    connectOrCreate?: ficheiroCreateOrConnectWithoutPagamentomultaInput
    connect?: ficheiroWhereUniqueInput
  }

  export type multaUpdateOneRequiredWithoutPagamentomultaNestedInput = {
    create?: XOR<multaCreateWithoutPagamentomultaInput, multaUncheckedCreateWithoutPagamentomultaInput>
    connectOrCreate?: multaCreateOrConnectWithoutPagamentomultaInput
    upsert?: multaUpsertWithoutPagamentomultaInput
    connect?: multaWhereUniqueInput
    update?: XOR<XOR<multaUpdateToOneWithWhereWithoutPagamentomultaInput, multaUpdateWithoutPagamentomultaInput>, multaUncheckedUpdateWithoutPagamentomultaInput>
  }

  export type ficheiroUpdateOneRequiredWithoutPagamentomultaNestedInput = {
    create?: XOR<ficheiroCreateWithoutPagamentomultaInput, ficheiroUncheckedCreateWithoutPagamentomultaInput>
    connectOrCreate?: ficheiroCreateOrConnectWithoutPagamentomultaInput
    upsert?: ficheiroUpsertWithoutPagamentomultaInput
    connect?: ficheiroWhereUniqueInput
    update?: XOR<XOR<ficheiroUpdateToOneWithWhereWithoutPagamentomultaInput, ficheiroUpdateWithoutPagamentomultaInput>, ficheiroUncheckedUpdateWithoutPagamentomultaInput>
  }

  export type pessoaCreateNestedManyWithoutPaisInput = {
    create?: XOR<pessoaCreateWithoutPaisInput, pessoaUncheckedCreateWithoutPaisInput> | pessoaCreateWithoutPaisInput[] | pessoaUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutPaisInput | pessoaCreateOrConnectWithoutPaisInput[]
    createMany?: pessoaCreateManyPaisInputEnvelope
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
  }

  export type pessoaUncheckedCreateNestedManyWithoutPaisInput = {
    create?: XOR<pessoaCreateWithoutPaisInput, pessoaUncheckedCreateWithoutPaisInput> | pessoaCreateWithoutPaisInput[] | pessoaUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutPaisInput | pessoaCreateOrConnectWithoutPaisInput[]
    createMany?: pessoaCreateManyPaisInputEnvelope
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
  }

  export type pessoaUpdateManyWithoutPaisNestedInput = {
    create?: XOR<pessoaCreateWithoutPaisInput, pessoaUncheckedCreateWithoutPaisInput> | pessoaCreateWithoutPaisInput[] | pessoaUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutPaisInput | pessoaCreateOrConnectWithoutPaisInput[]
    upsert?: pessoaUpsertWithWhereUniqueWithoutPaisInput | pessoaUpsertWithWhereUniqueWithoutPaisInput[]
    createMany?: pessoaCreateManyPaisInputEnvelope
    set?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    disconnect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    delete?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    update?: pessoaUpdateWithWhereUniqueWithoutPaisInput | pessoaUpdateWithWhereUniqueWithoutPaisInput[]
    updateMany?: pessoaUpdateManyWithWhereWithoutPaisInput | pessoaUpdateManyWithWhereWithoutPaisInput[]
    deleteMany?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
  }

  export type pessoaUncheckedUpdateManyWithoutPaisNestedInput = {
    create?: XOR<pessoaCreateWithoutPaisInput, pessoaUncheckedCreateWithoutPaisInput> | pessoaCreateWithoutPaisInput[] | pessoaUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutPaisInput | pessoaCreateOrConnectWithoutPaisInput[]
    upsert?: pessoaUpsertWithWhereUniqueWithoutPaisInput | pessoaUpsertWithWhereUniqueWithoutPaisInput[]
    createMany?: pessoaCreateManyPaisInputEnvelope
    set?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    disconnect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    delete?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    update?: pessoaUpdateWithWhereUniqueWithoutPaisInput | pessoaUpdateWithWhereUniqueWithoutPaisInput[]
    updateMany?: pessoaUpdateManyWithWhereWithoutPaisInput | pessoaUpdateManyWithWhereWithoutPaisInput[]
    deleteMany?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
  }

  export type automobilistaCreateNestedManyWithoutPessoaInput = {
    create?: XOR<automobilistaCreateWithoutPessoaInput, automobilistaUncheckedCreateWithoutPessoaInput> | automobilistaCreateWithoutPessoaInput[] | automobilistaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: automobilistaCreateOrConnectWithoutPessoaInput | automobilistaCreateOrConnectWithoutPessoaInput[]
    createMany?: automobilistaCreateManyPessoaInputEnvelope
    connect?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
  }

  export type funcionarioCreateNestedManyWithoutPessoaInput = {
    create?: XOR<funcionarioCreateWithoutPessoaInput, funcionarioUncheckedCreateWithoutPessoaInput> | funcionarioCreateWithoutPessoaInput[] | funcionarioUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: funcionarioCreateOrConnectWithoutPessoaInput | funcionarioCreateOrConnectWithoutPessoaInput[]
    createMany?: funcionarioCreateManyPessoaInputEnvelope
    connect?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
  }

  export type contactoCreateNestedOneWithoutPessoaInput = {
    create?: XOR<contactoCreateWithoutPessoaInput, contactoUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: contactoCreateOrConnectWithoutPessoaInput
    connect?: contactoWhereUniqueInput
  }

  export type enderecoCreateNestedOneWithoutPessoaInput = {
    create?: XOR<enderecoCreateWithoutPessoaInput, enderecoUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: enderecoCreateOrConnectWithoutPessoaInput
    connect?: enderecoWhereUniqueInput
  }

  export type paisCreateNestedOneWithoutPessoaInput = {
    create?: XOR<paisCreateWithoutPessoaInput, paisUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: paisCreateOrConnectWithoutPessoaInput
    connect?: paisWhereUniqueInput
  }

  export type biCreateNestedOneWithoutPessoaInput = {
    create?: XOR<biCreateWithoutPessoaInput, biUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: biCreateOrConnectWithoutPessoaInput
    connect?: biWhereUniqueInput
  }

  export type titulopropriedadeCreateNestedManyWithoutPessoaInput = {
    create?: XOR<titulopropriedadeCreateWithoutPessoaInput, titulopropriedadeUncheckedCreateWithoutPessoaInput> | titulopropriedadeCreateWithoutPessoaInput[] | titulopropriedadeUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: titulopropriedadeCreateOrConnectWithoutPessoaInput | titulopropriedadeCreateOrConnectWithoutPessoaInput[]
    createMany?: titulopropriedadeCreateManyPessoaInputEnvelope
    connect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
  }

  export type automobilistaUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<automobilistaCreateWithoutPessoaInput, automobilistaUncheckedCreateWithoutPessoaInput> | automobilistaCreateWithoutPessoaInput[] | automobilistaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: automobilistaCreateOrConnectWithoutPessoaInput | automobilistaCreateOrConnectWithoutPessoaInput[]
    createMany?: automobilistaCreateManyPessoaInputEnvelope
    connect?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
  }

  export type funcionarioUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<funcionarioCreateWithoutPessoaInput, funcionarioUncheckedCreateWithoutPessoaInput> | funcionarioCreateWithoutPessoaInput[] | funcionarioUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: funcionarioCreateOrConnectWithoutPessoaInput | funcionarioCreateOrConnectWithoutPessoaInput[]
    createMany?: funcionarioCreateManyPessoaInputEnvelope
    connect?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
  }

  export type titulopropriedadeUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<titulopropriedadeCreateWithoutPessoaInput, titulopropriedadeUncheckedCreateWithoutPessoaInput> | titulopropriedadeCreateWithoutPessoaInput[] | titulopropriedadeUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: titulopropriedadeCreateOrConnectWithoutPessoaInput | titulopropriedadeCreateOrConnectWithoutPessoaInput[]
    createMany?: titulopropriedadeCreateManyPessoaInputEnvelope
    connect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
  }

  export type Enumpessoa_generoFieldUpdateOperationsInput = {
    set?: $Enums.pessoa_genero
  }

  export type Enumpessoa_estadoCivilFieldUpdateOperationsInput = {
    set?: $Enums.pessoa_estadoCivil
  }

  export type automobilistaUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<automobilistaCreateWithoutPessoaInput, automobilistaUncheckedCreateWithoutPessoaInput> | automobilistaCreateWithoutPessoaInput[] | automobilistaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: automobilistaCreateOrConnectWithoutPessoaInput | automobilistaCreateOrConnectWithoutPessoaInput[]
    upsert?: automobilistaUpsertWithWhereUniqueWithoutPessoaInput | automobilistaUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: automobilistaCreateManyPessoaInputEnvelope
    set?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
    disconnect?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
    delete?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
    connect?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
    update?: automobilistaUpdateWithWhereUniqueWithoutPessoaInput | automobilistaUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: automobilistaUpdateManyWithWhereWithoutPessoaInput | automobilistaUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: automobilistaScalarWhereInput | automobilistaScalarWhereInput[]
  }

  export type funcionarioUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<funcionarioCreateWithoutPessoaInput, funcionarioUncheckedCreateWithoutPessoaInput> | funcionarioCreateWithoutPessoaInput[] | funcionarioUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: funcionarioCreateOrConnectWithoutPessoaInput | funcionarioCreateOrConnectWithoutPessoaInput[]
    upsert?: funcionarioUpsertWithWhereUniqueWithoutPessoaInput | funcionarioUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: funcionarioCreateManyPessoaInputEnvelope
    set?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
    disconnect?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
    delete?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
    connect?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
    update?: funcionarioUpdateWithWhereUniqueWithoutPessoaInput | funcionarioUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: funcionarioUpdateManyWithWhereWithoutPessoaInput | funcionarioUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: funcionarioScalarWhereInput | funcionarioScalarWhereInput[]
  }

  export type contactoUpdateOneWithoutPessoaNestedInput = {
    create?: XOR<contactoCreateWithoutPessoaInput, contactoUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: contactoCreateOrConnectWithoutPessoaInput
    upsert?: contactoUpsertWithoutPessoaInput
    disconnect?: contactoWhereInput | boolean
    delete?: contactoWhereInput | boolean
    connect?: contactoWhereUniqueInput
    update?: XOR<XOR<contactoUpdateToOneWithWhereWithoutPessoaInput, contactoUpdateWithoutPessoaInput>, contactoUncheckedUpdateWithoutPessoaInput>
  }

  export type enderecoUpdateOneWithoutPessoaNestedInput = {
    create?: XOR<enderecoCreateWithoutPessoaInput, enderecoUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: enderecoCreateOrConnectWithoutPessoaInput
    upsert?: enderecoUpsertWithoutPessoaInput
    disconnect?: enderecoWhereInput | boolean
    delete?: enderecoWhereInput | boolean
    connect?: enderecoWhereUniqueInput
    update?: XOR<XOR<enderecoUpdateToOneWithWhereWithoutPessoaInput, enderecoUpdateWithoutPessoaInput>, enderecoUncheckedUpdateWithoutPessoaInput>
  }

  export type paisUpdateOneWithoutPessoaNestedInput = {
    create?: XOR<paisCreateWithoutPessoaInput, paisUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: paisCreateOrConnectWithoutPessoaInput
    upsert?: paisUpsertWithoutPessoaInput
    disconnect?: paisWhereInput | boolean
    delete?: paisWhereInput | boolean
    connect?: paisWhereUniqueInput
    update?: XOR<XOR<paisUpdateToOneWithWhereWithoutPessoaInput, paisUpdateWithoutPessoaInput>, paisUncheckedUpdateWithoutPessoaInput>
  }

  export type biUpdateOneRequiredWithoutPessoaNestedInput = {
    create?: XOR<biCreateWithoutPessoaInput, biUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: biCreateOrConnectWithoutPessoaInput
    upsert?: biUpsertWithoutPessoaInput
    connect?: biWhereUniqueInput
    update?: XOR<XOR<biUpdateToOneWithWhereWithoutPessoaInput, biUpdateWithoutPessoaInput>, biUncheckedUpdateWithoutPessoaInput>
  }

  export type titulopropriedadeUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<titulopropriedadeCreateWithoutPessoaInput, titulopropriedadeUncheckedCreateWithoutPessoaInput> | titulopropriedadeCreateWithoutPessoaInput[] | titulopropriedadeUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: titulopropriedadeCreateOrConnectWithoutPessoaInput | titulopropriedadeCreateOrConnectWithoutPessoaInput[]
    upsert?: titulopropriedadeUpsertWithWhereUniqueWithoutPessoaInput | titulopropriedadeUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: titulopropriedadeCreateManyPessoaInputEnvelope
    set?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    disconnect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    delete?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    connect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    update?: titulopropriedadeUpdateWithWhereUniqueWithoutPessoaInput | titulopropriedadeUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: titulopropriedadeUpdateManyWithWhereWithoutPessoaInput | titulopropriedadeUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: titulopropriedadeScalarWhereInput | titulopropriedadeScalarWhereInput[]
  }

  export type automobilistaUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<automobilistaCreateWithoutPessoaInput, automobilistaUncheckedCreateWithoutPessoaInput> | automobilistaCreateWithoutPessoaInput[] | automobilistaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: automobilistaCreateOrConnectWithoutPessoaInput | automobilistaCreateOrConnectWithoutPessoaInput[]
    upsert?: automobilistaUpsertWithWhereUniqueWithoutPessoaInput | automobilistaUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: automobilistaCreateManyPessoaInputEnvelope
    set?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
    disconnect?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
    delete?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
    connect?: automobilistaWhereUniqueInput | automobilistaWhereUniqueInput[]
    update?: automobilistaUpdateWithWhereUniqueWithoutPessoaInput | automobilistaUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: automobilistaUpdateManyWithWhereWithoutPessoaInput | automobilistaUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: automobilistaScalarWhereInput | automobilistaScalarWhereInput[]
  }

  export type funcionarioUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<funcionarioCreateWithoutPessoaInput, funcionarioUncheckedCreateWithoutPessoaInput> | funcionarioCreateWithoutPessoaInput[] | funcionarioUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: funcionarioCreateOrConnectWithoutPessoaInput | funcionarioCreateOrConnectWithoutPessoaInput[]
    upsert?: funcionarioUpsertWithWhereUniqueWithoutPessoaInput | funcionarioUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: funcionarioCreateManyPessoaInputEnvelope
    set?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
    disconnect?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
    delete?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
    connect?: funcionarioWhereUniqueInput | funcionarioWhereUniqueInput[]
    update?: funcionarioUpdateWithWhereUniqueWithoutPessoaInput | funcionarioUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: funcionarioUpdateManyWithWhereWithoutPessoaInput | funcionarioUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: funcionarioScalarWhereInput | funcionarioScalarWhereInput[]
  }

  export type titulopropriedadeUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<titulopropriedadeCreateWithoutPessoaInput, titulopropriedadeUncheckedCreateWithoutPessoaInput> | titulopropriedadeCreateWithoutPessoaInput[] | titulopropriedadeUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: titulopropriedadeCreateOrConnectWithoutPessoaInput | titulopropriedadeCreateOrConnectWithoutPessoaInput[]
    upsert?: titulopropriedadeUpsertWithWhereUniqueWithoutPessoaInput | titulopropriedadeUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: titulopropriedadeCreateManyPessoaInputEnvelope
    set?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    disconnect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    delete?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    connect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    update?: titulopropriedadeUpdateWithWhereUniqueWithoutPessoaInput | titulopropriedadeUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: titulopropriedadeUpdateManyWithWhereWithoutPessoaInput | titulopropriedadeUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: titulopropriedadeScalarWhereInput | titulopropriedadeScalarWhereInput[]
  }

  export type municipioCreateNestedManyWithoutProvinciaInput = {
    create?: XOR<municipioCreateWithoutProvinciaInput, municipioUncheckedCreateWithoutProvinciaInput> | municipioCreateWithoutProvinciaInput[] | municipioUncheckedCreateWithoutProvinciaInput[]
    connectOrCreate?: municipioCreateOrConnectWithoutProvinciaInput | municipioCreateOrConnectWithoutProvinciaInput[]
    createMany?: municipioCreateManyProvinciaInputEnvelope
    connect?: municipioWhereUniqueInput | municipioWhereUniqueInput[]
  }

  export type municipioUncheckedCreateNestedManyWithoutProvinciaInput = {
    create?: XOR<municipioCreateWithoutProvinciaInput, municipioUncheckedCreateWithoutProvinciaInput> | municipioCreateWithoutProvinciaInput[] | municipioUncheckedCreateWithoutProvinciaInput[]
    connectOrCreate?: municipioCreateOrConnectWithoutProvinciaInput | municipioCreateOrConnectWithoutProvinciaInput[]
    createMany?: municipioCreateManyProvinciaInputEnvelope
    connect?: municipioWhereUniqueInput | municipioWhereUniqueInput[]
  }

  export type municipioUpdateManyWithoutProvinciaNestedInput = {
    create?: XOR<municipioCreateWithoutProvinciaInput, municipioUncheckedCreateWithoutProvinciaInput> | municipioCreateWithoutProvinciaInput[] | municipioUncheckedCreateWithoutProvinciaInput[]
    connectOrCreate?: municipioCreateOrConnectWithoutProvinciaInput | municipioCreateOrConnectWithoutProvinciaInput[]
    upsert?: municipioUpsertWithWhereUniqueWithoutProvinciaInput | municipioUpsertWithWhereUniqueWithoutProvinciaInput[]
    createMany?: municipioCreateManyProvinciaInputEnvelope
    set?: municipioWhereUniqueInput | municipioWhereUniqueInput[]
    disconnect?: municipioWhereUniqueInput | municipioWhereUniqueInput[]
    delete?: municipioWhereUniqueInput | municipioWhereUniqueInput[]
    connect?: municipioWhereUniqueInput | municipioWhereUniqueInput[]
    update?: municipioUpdateWithWhereUniqueWithoutProvinciaInput | municipioUpdateWithWhereUniqueWithoutProvinciaInput[]
    updateMany?: municipioUpdateManyWithWhereWithoutProvinciaInput | municipioUpdateManyWithWhereWithoutProvinciaInput[]
    deleteMany?: municipioScalarWhereInput | municipioScalarWhereInput[]
  }

  export type municipioUncheckedUpdateManyWithoutProvinciaNestedInput = {
    create?: XOR<municipioCreateWithoutProvinciaInput, municipioUncheckedCreateWithoutProvinciaInput> | municipioCreateWithoutProvinciaInput[] | municipioUncheckedCreateWithoutProvinciaInput[]
    connectOrCreate?: municipioCreateOrConnectWithoutProvinciaInput | municipioCreateOrConnectWithoutProvinciaInput[]
    upsert?: municipioUpsertWithWhereUniqueWithoutProvinciaInput | municipioUpsertWithWhereUniqueWithoutProvinciaInput[]
    createMany?: municipioCreateManyProvinciaInputEnvelope
    set?: municipioWhereUniqueInput | municipioWhereUniqueInput[]
    disconnect?: municipioWhereUniqueInput | municipioWhereUniqueInput[]
    delete?: municipioWhereUniqueInput | municipioWhereUniqueInput[]
    connect?: municipioWhereUniqueInput | municipioWhereUniqueInput[]
    update?: municipioUpdateWithWhereUniqueWithoutProvinciaInput | municipioUpdateWithWhereUniqueWithoutProvinciaInput[]
    updateMany?: municipioUpdateManyWithWhereWithoutProvinciaInput | municipioUpdateManyWithWhereWithoutProvinciaInput[]
    deleteMany?: municipioScalarWhereInput | municipioScalarWhereInput[]
  }

  export type livreteCreateNestedManyWithoutSerivicoviaturaInput = {
    create?: XOR<livreteCreateWithoutSerivicoviaturaInput, livreteUncheckedCreateWithoutSerivicoviaturaInput> | livreteCreateWithoutSerivicoviaturaInput[] | livreteUncheckedCreateWithoutSerivicoviaturaInput[]
    connectOrCreate?: livreteCreateOrConnectWithoutSerivicoviaturaInput | livreteCreateOrConnectWithoutSerivicoviaturaInput[]
    createMany?: livreteCreateManySerivicoviaturaInputEnvelope
    connect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
  }

  export type livreteUncheckedCreateNestedManyWithoutSerivicoviaturaInput = {
    create?: XOR<livreteCreateWithoutSerivicoviaturaInput, livreteUncheckedCreateWithoutSerivicoviaturaInput> | livreteCreateWithoutSerivicoviaturaInput[] | livreteUncheckedCreateWithoutSerivicoviaturaInput[]
    connectOrCreate?: livreteCreateOrConnectWithoutSerivicoviaturaInput | livreteCreateOrConnectWithoutSerivicoviaturaInput[]
    createMany?: livreteCreateManySerivicoviaturaInputEnvelope
    connect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
  }

  export type livreteUpdateManyWithoutSerivicoviaturaNestedInput = {
    create?: XOR<livreteCreateWithoutSerivicoviaturaInput, livreteUncheckedCreateWithoutSerivicoviaturaInput> | livreteCreateWithoutSerivicoviaturaInput[] | livreteUncheckedCreateWithoutSerivicoviaturaInput[]
    connectOrCreate?: livreteCreateOrConnectWithoutSerivicoviaturaInput | livreteCreateOrConnectWithoutSerivicoviaturaInput[]
    upsert?: livreteUpsertWithWhereUniqueWithoutSerivicoviaturaInput | livreteUpsertWithWhereUniqueWithoutSerivicoviaturaInput[]
    createMany?: livreteCreateManySerivicoviaturaInputEnvelope
    set?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    disconnect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    delete?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    connect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    update?: livreteUpdateWithWhereUniqueWithoutSerivicoviaturaInput | livreteUpdateWithWhereUniqueWithoutSerivicoviaturaInput[]
    updateMany?: livreteUpdateManyWithWhereWithoutSerivicoviaturaInput | livreteUpdateManyWithWhereWithoutSerivicoviaturaInput[]
    deleteMany?: livreteScalarWhereInput | livreteScalarWhereInput[]
  }

  export type livreteUncheckedUpdateManyWithoutSerivicoviaturaNestedInput = {
    create?: XOR<livreteCreateWithoutSerivicoviaturaInput, livreteUncheckedCreateWithoutSerivicoviaturaInput> | livreteCreateWithoutSerivicoviaturaInput[] | livreteUncheckedCreateWithoutSerivicoviaturaInput[]
    connectOrCreate?: livreteCreateOrConnectWithoutSerivicoviaturaInput | livreteCreateOrConnectWithoutSerivicoviaturaInput[]
    upsert?: livreteUpsertWithWhereUniqueWithoutSerivicoviaturaInput | livreteUpsertWithWhereUniqueWithoutSerivicoviaturaInput[]
    createMany?: livreteCreateManySerivicoviaturaInputEnvelope
    set?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    disconnect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    delete?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    connect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    update?: livreteUpdateWithWhereUniqueWithoutSerivicoviaturaInput | livreteUpdateWithWhereUniqueWithoutSerivicoviaturaInput[]
    updateMany?: livreteUpdateManyWithWhereWithoutSerivicoviaturaInput | livreteUpdateManyWithWhereWithoutSerivicoviaturaInput[]
    deleteMany?: livreteScalarWhereInput | livreteScalarWhereInput[]
  }

  export type infracaoCreateNestedManyWithoutTipoinfracaoInput = {
    create?: XOR<infracaoCreateWithoutTipoinfracaoInput, infracaoUncheckedCreateWithoutTipoinfracaoInput> | infracaoCreateWithoutTipoinfracaoInput[] | infracaoUncheckedCreateWithoutTipoinfracaoInput[]
    connectOrCreate?: infracaoCreateOrConnectWithoutTipoinfracaoInput | infracaoCreateOrConnectWithoutTipoinfracaoInput[]
    createMany?: infracaoCreateManyTipoinfracaoInputEnvelope
    connect?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
  }

  export type infracaoUncheckedCreateNestedManyWithoutTipoinfracaoInput = {
    create?: XOR<infracaoCreateWithoutTipoinfracaoInput, infracaoUncheckedCreateWithoutTipoinfracaoInput> | infracaoCreateWithoutTipoinfracaoInput[] | infracaoUncheckedCreateWithoutTipoinfracaoInput[]
    connectOrCreate?: infracaoCreateOrConnectWithoutTipoinfracaoInput | infracaoCreateOrConnectWithoutTipoinfracaoInput[]
    createMany?: infracaoCreateManyTipoinfracaoInputEnvelope
    connect?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
  }

  export type infracaoUpdateManyWithoutTipoinfracaoNestedInput = {
    create?: XOR<infracaoCreateWithoutTipoinfracaoInput, infracaoUncheckedCreateWithoutTipoinfracaoInput> | infracaoCreateWithoutTipoinfracaoInput[] | infracaoUncheckedCreateWithoutTipoinfracaoInput[]
    connectOrCreate?: infracaoCreateOrConnectWithoutTipoinfracaoInput | infracaoCreateOrConnectWithoutTipoinfracaoInput[]
    upsert?: infracaoUpsertWithWhereUniqueWithoutTipoinfracaoInput | infracaoUpsertWithWhereUniqueWithoutTipoinfracaoInput[]
    createMany?: infracaoCreateManyTipoinfracaoInputEnvelope
    set?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
    disconnect?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
    delete?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
    connect?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
    update?: infracaoUpdateWithWhereUniqueWithoutTipoinfracaoInput | infracaoUpdateWithWhereUniqueWithoutTipoinfracaoInput[]
    updateMany?: infracaoUpdateManyWithWhereWithoutTipoinfracaoInput | infracaoUpdateManyWithWhereWithoutTipoinfracaoInput[]
    deleteMany?: infracaoScalarWhereInput | infracaoScalarWhereInput[]
  }

  export type infracaoUncheckedUpdateManyWithoutTipoinfracaoNestedInput = {
    create?: XOR<infracaoCreateWithoutTipoinfracaoInput, infracaoUncheckedCreateWithoutTipoinfracaoInput> | infracaoCreateWithoutTipoinfracaoInput[] | infracaoUncheckedCreateWithoutTipoinfracaoInput[]
    connectOrCreate?: infracaoCreateOrConnectWithoutTipoinfracaoInput | infracaoCreateOrConnectWithoutTipoinfracaoInput[]
    upsert?: infracaoUpsertWithWhereUniqueWithoutTipoinfracaoInput | infracaoUpsertWithWhereUniqueWithoutTipoinfracaoInput[]
    createMany?: infracaoCreateManyTipoinfracaoInputEnvelope
    set?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
    disconnect?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
    delete?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
    connect?: infracaoWhereUniqueInput | infracaoWhereUniqueInput[]
    update?: infracaoUpdateWithWhereUniqueWithoutTipoinfracaoInput | infracaoUpdateWithWhereUniqueWithoutTipoinfracaoInput[]
    updateMany?: infracaoUpdateManyWithWhereWithoutTipoinfracaoInput | infracaoUpdateManyWithWhereWithoutTipoinfracaoInput[]
    deleteMany?: infracaoScalarWhereInput | infracaoScalarWhereInput[]
  }

  export type alertarouboCreateNestedManyWithoutTiporouboInput = {
    create?: XOR<alertarouboCreateWithoutTiporouboInput, alertarouboUncheckedCreateWithoutTiporouboInput> | alertarouboCreateWithoutTiporouboInput[] | alertarouboUncheckedCreateWithoutTiporouboInput[]
    connectOrCreate?: alertarouboCreateOrConnectWithoutTiporouboInput | alertarouboCreateOrConnectWithoutTiporouboInput[]
    createMany?: alertarouboCreateManyTiporouboInputEnvelope
    connect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
  }

  export type alertarouboUncheckedCreateNestedManyWithoutTiporouboInput = {
    create?: XOR<alertarouboCreateWithoutTiporouboInput, alertarouboUncheckedCreateWithoutTiporouboInput> | alertarouboCreateWithoutTiporouboInput[] | alertarouboUncheckedCreateWithoutTiporouboInput[]
    connectOrCreate?: alertarouboCreateOrConnectWithoutTiporouboInput | alertarouboCreateOrConnectWithoutTiporouboInput[]
    createMany?: alertarouboCreateManyTiporouboInputEnvelope
    connect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
  }

  export type alertarouboUpdateManyWithoutTiporouboNestedInput = {
    create?: XOR<alertarouboCreateWithoutTiporouboInput, alertarouboUncheckedCreateWithoutTiporouboInput> | alertarouboCreateWithoutTiporouboInput[] | alertarouboUncheckedCreateWithoutTiporouboInput[]
    connectOrCreate?: alertarouboCreateOrConnectWithoutTiporouboInput | alertarouboCreateOrConnectWithoutTiporouboInput[]
    upsert?: alertarouboUpsertWithWhereUniqueWithoutTiporouboInput | alertarouboUpsertWithWhereUniqueWithoutTiporouboInput[]
    createMany?: alertarouboCreateManyTiporouboInputEnvelope
    set?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    disconnect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    delete?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    connect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    update?: alertarouboUpdateWithWhereUniqueWithoutTiporouboInput | alertarouboUpdateWithWhereUniqueWithoutTiporouboInput[]
    updateMany?: alertarouboUpdateManyWithWhereWithoutTiporouboInput | alertarouboUpdateManyWithWhereWithoutTiporouboInput[]
    deleteMany?: alertarouboScalarWhereInput | alertarouboScalarWhereInput[]
  }

  export type alertarouboUncheckedUpdateManyWithoutTiporouboNestedInput = {
    create?: XOR<alertarouboCreateWithoutTiporouboInput, alertarouboUncheckedCreateWithoutTiporouboInput> | alertarouboCreateWithoutTiporouboInput[] | alertarouboUncheckedCreateWithoutTiporouboInput[]
    connectOrCreate?: alertarouboCreateOrConnectWithoutTiporouboInput | alertarouboCreateOrConnectWithoutTiporouboInput[]
    upsert?: alertarouboUpsertWithWhereUniqueWithoutTiporouboInput | alertarouboUpsertWithWhereUniqueWithoutTiporouboInput[]
    createMany?: alertarouboCreateManyTiporouboInputEnvelope
    set?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    disconnect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    delete?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    connect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    update?: alertarouboUpdateWithWhereUniqueWithoutTiporouboInput | alertarouboUpdateWithWhereUniqueWithoutTiporouboInput[]
    updateMany?: alertarouboUpdateManyWithWhereWithoutTiporouboInput | alertarouboUpdateManyWithWhereWithoutTiporouboInput[]
    deleteMany?: alertarouboScalarWhereInput | alertarouboScalarWhereInput[]
  }

  export type pessoaCreateNestedOneWithoutTitulopropriedadeInput = {
    create?: XOR<pessoaCreateWithoutTitulopropriedadeInput, pessoaUncheckedCreateWithoutTitulopropriedadeInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutTitulopropriedadeInput
    connect?: pessoaWhereUniqueInput
  }

  export type viaturaCreateNestedOneWithoutTitulopropriedadeInput = {
    create?: XOR<viaturaCreateWithoutTitulopropriedadeInput, viaturaUncheckedCreateWithoutTitulopropriedadeInput>
    connectOrCreate?: viaturaCreateOrConnectWithoutTitulopropriedadeInput
    connect?: viaturaWhereUniqueInput
  }

  export type ficheiroCreateNestedOneWithoutTitulopropriedadeInput = {
    create?: XOR<ficheiroCreateWithoutTitulopropriedadeInput, ficheiroUncheckedCreateWithoutTitulopropriedadeInput>
    connectOrCreate?: ficheiroCreateOrConnectWithoutTitulopropriedadeInput
    connect?: ficheiroWhereUniqueInput
  }

  export type pessoaUpdateOneRequiredWithoutTitulopropriedadeNestedInput = {
    create?: XOR<pessoaCreateWithoutTitulopropriedadeInput, pessoaUncheckedCreateWithoutTitulopropriedadeInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutTitulopropriedadeInput
    upsert?: pessoaUpsertWithoutTitulopropriedadeInput
    connect?: pessoaWhereUniqueInput
    update?: XOR<XOR<pessoaUpdateToOneWithWhereWithoutTitulopropriedadeInput, pessoaUpdateWithoutTitulopropriedadeInput>, pessoaUncheckedUpdateWithoutTitulopropriedadeInput>
  }

  export type viaturaUpdateOneRequiredWithoutTitulopropriedadeNestedInput = {
    create?: XOR<viaturaCreateWithoutTitulopropriedadeInput, viaturaUncheckedCreateWithoutTitulopropriedadeInput>
    connectOrCreate?: viaturaCreateOrConnectWithoutTitulopropriedadeInput
    upsert?: viaturaUpsertWithoutTitulopropriedadeInput
    connect?: viaturaWhereUniqueInput
    update?: XOR<XOR<viaturaUpdateToOneWithWhereWithoutTitulopropriedadeInput, viaturaUpdateWithoutTitulopropriedadeInput>, viaturaUncheckedUpdateWithoutTitulopropriedadeInput>
  }

  export type ficheiroUpdateOneRequiredWithoutTitulopropriedadeNestedInput = {
    create?: XOR<ficheiroCreateWithoutTitulopropriedadeInput, ficheiroUncheckedCreateWithoutTitulopropriedadeInput>
    connectOrCreate?: ficheiroCreateOrConnectWithoutTitulopropriedadeInput
    upsert?: ficheiroUpsertWithoutTitulopropriedadeInput
    connect?: ficheiroWhereUniqueInput
    update?: XOR<XOR<ficheiroUpdateToOneWithWhereWithoutTitulopropriedadeInput, ficheiroUpdateWithoutTitulopropriedadeInput>, ficheiroUncheckedUpdateWithoutTitulopropriedadeInput>
  }

  export type alertarouboCreateNestedManyWithoutViaturaInput = {
    create?: XOR<alertarouboCreateWithoutViaturaInput, alertarouboUncheckedCreateWithoutViaturaInput> | alertarouboCreateWithoutViaturaInput[] | alertarouboUncheckedCreateWithoutViaturaInput[]
    connectOrCreate?: alertarouboCreateOrConnectWithoutViaturaInput | alertarouboCreateOrConnectWithoutViaturaInput[]
    createMany?: alertarouboCreateManyViaturaInputEnvelope
    connect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
  }

  export type livreteCreateNestedManyWithoutViaturaInput = {
    create?: XOR<livreteCreateWithoutViaturaInput, livreteUncheckedCreateWithoutViaturaInput> | livreteCreateWithoutViaturaInput[] | livreteUncheckedCreateWithoutViaturaInput[]
    connectOrCreate?: livreteCreateOrConnectWithoutViaturaInput | livreteCreateOrConnectWithoutViaturaInput[]
    createMany?: livreteCreateManyViaturaInputEnvelope
    connect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
  }

  export type multaCreateNestedManyWithoutViaturaInput = {
    create?: XOR<multaCreateWithoutViaturaInput, multaUncheckedCreateWithoutViaturaInput> | multaCreateWithoutViaturaInput[] | multaUncheckedCreateWithoutViaturaInput[]
    connectOrCreate?: multaCreateOrConnectWithoutViaturaInput | multaCreateOrConnectWithoutViaturaInput[]
    createMany?: multaCreateManyViaturaInputEnvelope
    connect?: multaWhereUniqueInput | multaWhereUniqueInput[]
  }

  export type titulopropriedadeCreateNestedManyWithoutViaturaInput = {
    create?: XOR<titulopropriedadeCreateWithoutViaturaInput, titulopropriedadeUncheckedCreateWithoutViaturaInput> | titulopropriedadeCreateWithoutViaturaInput[] | titulopropriedadeUncheckedCreateWithoutViaturaInput[]
    connectOrCreate?: titulopropriedadeCreateOrConnectWithoutViaturaInput | titulopropriedadeCreateOrConnectWithoutViaturaInput[]
    createMany?: titulopropriedadeCreateManyViaturaInputEnvelope
    connect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
  }

  export type alertarouboUncheckedCreateNestedManyWithoutViaturaInput = {
    create?: XOR<alertarouboCreateWithoutViaturaInput, alertarouboUncheckedCreateWithoutViaturaInput> | alertarouboCreateWithoutViaturaInput[] | alertarouboUncheckedCreateWithoutViaturaInput[]
    connectOrCreate?: alertarouboCreateOrConnectWithoutViaturaInput | alertarouboCreateOrConnectWithoutViaturaInput[]
    createMany?: alertarouboCreateManyViaturaInputEnvelope
    connect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
  }

  export type livreteUncheckedCreateNestedManyWithoutViaturaInput = {
    create?: XOR<livreteCreateWithoutViaturaInput, livreteUncheckedCreateWithoutViaturaInput> | livreteCreateWithoutViaturaInput[] | livreteUncheckedCreateWithoutViaturaInput[]
    connectOrCreate?: livreteCreateOrConnectWithoutViaturaInput | livreteCreateOrConnectWithoutViaturaInput[]
    createMany?: livreteCreateManyViaturaInputEnvelope
    connect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
  }

  export type multaUncheckedCreateNestedManyWithoutViaturaInput = {
    create?: XOR<multaCreateWithoutViaturaInput, multaUncheckedCreateWithoutViaturaInput> | multaCreateWithoutViaturaInput[] | multaUncheckedCreateWithoutViaturaInput[]
    connectOrCreate?: multaCreateOrConnectWithoutViaturaInput | multaCreateOrConnectWithoutViaturaInput[]
    createMany?: multaCreateManyViaturaInputEnvelope
    connect?: multaWhereUniqueInput | multaWhereUniqueInput[]
  }

  export type titulopropriedadeUncheckedCreateNestedManyWithoutViaturaInput = {
    create?: XOR<titulopropriedadeCreateWithoutViaturaInput, titulopropriedadeUncheckedCreateWithoutViaturaInput> | titulopropriedadeCreateWithoutViaturaInput[] | titulopropriedadeUncheckedCreateWithoutViaturaInput[]
    connectOrCreate?: titulopropriedadeCreateOrConnectWithoutViaturaInput | titulopropriedadeCreateOrConnectWithoutViaturaInput[]
    createMany?: titulopropriedadeCreateManyViaturaInputEnvelope
    connect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
  }

  export type alertarouboUpdateManyWithoutViaturaNestedInput = {
    create?: XOR<alertarouboCreateWithoutViaturaInput, alertarouboUncheckedCreateWithoutViaturaInput> | alertarouboCreateWithoutViaturaInput[] | alertarouboUncheckedCreateWithoutViaturaInput[]
    connectOrCreate?: alertarouboCreateOrConnectWithoutViaturaInput | alertarouboCreateOrConnectWithoutViaturaInput[]
    upsert?: alertarouboUpsertWithWhereUniqueWithoutViaturaInput | alertarouboUpsertWithWhereUniqueWithoutViaturaInput[]
    createMany?: alertarouboCreateManyViaturaInputEnvelope
    set?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    disconnect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    delete?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    connect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    update?: alertarouboUpdateWithWhereUniqueWithoutViaturaInput | alertarouboUpdateWithWhereUniqueWithoutViaturaInput[]
    updateMany?: alertarouboUpdateManyWithWhereWithoutViaturaInput | alertarouboUpdateManyWithWhereWithoutViaturaInput[]
    deleteMany?: alertarouboScalarWhereInput | alertarouboScalarWhereInput[]
  }

  export type livreteUpdateManyWithoutViaturaNestedInput = {
    create?: XOR<livreteCreateWithoutViaturaInput, livreteUncheckedCreateWithoutViaturaInput> | livreteCreateWithoutViaturaInput[] | livreteUncheckedCreateWithoutViaturaInput[]
    connectOrCreate?: livreteCreateOrConnectWithoutViaturaInput | livreteCreateOrConnectWithoutViaturaInput[]
    upsert?: livreteUpsertWithWhereUniqueWithoutViaturaInput | livreteUpsertWithWhereUniqueWithoutViaturaInput[]
    createMany?: livreteCreateManyViaturaInputEnvelope
    set?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    disconnect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    delete?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    connect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    update?: livreteUpdateWithWhereUniqueWithoutViaturaInput | livreteUpdateWithWhereUniqueWithoutViaturaInput[]
    updateMany?: livreteUpdateManyWithWhereWithoutViaturaInput | livreteUpdateManyWithWhereWithoutViaturaInput[]
    deleteMany?: livreteScalarWhereInput | livreteScalarWhereInput[]
  }

  export type multaUpdateManyWithoutViaturaNestedInput = {
    create?: XOR<multaCreateWithoutViaturaInput, multaUncheckedCreateWithoutViaturaInput> | multaCreateWithoutViaturaInput[] | multaUncheckedCreateWithoutViaturaInput[]
    connectOrCreate?: multaCreateOrConnectWithoutViaturaInput | multaCreateOrConnectWithoutViaturaInput[]
    upsert?: multaUpsertWithWhereUniqueWithoutViaturaInput | multaUpsertWithWhereUniqueWithoutViaturaInput[]
    createMany?: multaCreateManyViaturaInputEnvelope
    set?: multaWhereUniqueInput | multaWhereUniqueInput[]
    disconnect?: multaWhereUniqueInput | multaWhereUniqueInput[]
    delete?: multaWhereUniqueInput | multaWhereUniqueInput[]
    connect?: multaWhereUniqueInput | multaWhereUniqueInput[]
    update?: multaUpdateWithWhereUniqueWithoutViaturaInput | multaUpdateWithWhereUniqueWithoutViaturaInput[]
    updateMany?: multaUpdateManyWithWhereWithoutViaturaInput | multaUpdateManyWithWhereWithoutViaturaInput[]
    deleteMany?: multaScalarWhereInput | multaScalarWhereInput[]
  }

  export type titulopropriedadeUpdateManyWithoutViaturaNestedInput = {
    create?: XOR<titulopropriedadeCreateWithoutViaturaInput, titulopropriedadeUncheckedCreateWithoutViaturaInput> | titulopropriedadeCreateWithoutViaturaInput[] | titulopropriedadeUncheckedCreateWithoutViaturaInput[]
    connectOrCreate?: titulopropriedadeCreateOrConnectWithoutViaturaInput | titulopropriedadeCreateOrConnectWithoutViaturaInput[]
    upsert?: titulopropriedadeUpsertWithWhereUniqueWithoutViaturaInput | titulopropriedadeUpsertWithWhereUniqueWithoutViaturaInput[]
    createMany?: titulopropriedadeCreateManyViaturaInputEnvelope
    set?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    disconnect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    delete?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    connect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    update?: titulopropriedadeUpdateWithWhereUniqueWithoutViaturaInput | titulopropriedadeUpdateWithWhereUniqueWithoutViaturaInput[]
    updateMany?: titulopropriedadeUpdateManyWithWhereWithoutViaturaInput | titulopropriedadeUpdateManyWithWhereWithoutViaturaInput[]
    deleteMany?: titulopropriedadeScalarWhereInput | titulopropriedadeScalarWhereInput[]
  }

  export type alertarouboUncheckedUpdateManyWithoutViaturaNestedInput = {
    create?: XOR<alertarouboCreateWithoutViaturaInput, alertarouboUncheckedCreateWithoutViaturaInput> | alertarouboCreateWithoutViaturaInput[] | alertarouboUncheckedCreateWithoutViaturaInput[]
    connectOrCreate?: alertarouboCreateOrConnectWithoutViaturaInput | alertarouboCreateOrConnectWithoutViaturaInput[]
    upsert?: alertarouboUpsertWithWhereUniqueWithoutViaturaInput | alertarouboUpsertWithWhereUniqueWithoutViaturaInput[]
    createMany?: alertarouboCreateManyViaturaInputEnvelope
    set?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    disconnect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    delete?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    connect?: alertarouboWhereUniqueInput | alertarouboWhereUniqueInput[]
    update?: alertarouboUpdateWithWhereUniqueWithoutViaturaInput | alertarouboUpdateWithWhereUniqueWithoutViaturaInput[]
    updateMany?: alertarouboUpdateManyWithWhereWithoutViaturaInput | alertarouboUpdateManyWithWhereWithoutViaturaInput[]
    deleteMany?: alertarouboScalarWhereInput | alertarouboScalarWhereInput[]
  }

  export type livreteUncheckedUpdateManyWithoutViaturaNestedInput = {
    create?: XOR<livreteCreateWithoutViaturaInput, livreteUncheckedCreateWithoutViaturaInput> | livreteCreateWithoutViaturaInput[] | livreteUncheckedCreateWithoutViaturaInput[]
    connectOrCreate?: livreteCreateOrConnectWithoutViaturaInput | livreteCreateOrConnectWithoutViaturaInput[]
    upsert?: livreteUpsertWithWhereUniqueWithoutViaturaInput | livreteUpsertWithWhereUniqueWithoutViaturaInput[]
    createMany?: livreteCreateManyViaturaInputEnvelope
    set?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    disconnect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    delete?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    connect?: livreteWhereUniqueInput | livreteWhereUniqueInput[]
    update?: livreteUpdateWithWhereUniqueWithoutViaturaInput | livreteUpdateWithWhereUniqueWithoutViaturaInput[]
    updateMany?: livreteUpdateManyWithWhereWithoutViaturaInput | livreteUpdateManyWithWhereWithoutViaturaInput[]
    deleteMany?: livreteScalarWhereInput | livreteScalarWhereInput[]
  }

  export type multaUncheckedUpdateManyWithoutViaturaNestedInput = {
    create?: XOR<multaCreateWithoutViaturaInput, multaUncheckedCreateWithoutViaturaInput> | multaCreateWithoutViaturaInput[] | multaUncheckedCreateWithoutViaturaInput[]
    connectOrCreate?: multaCreateOrConnectWithoutViaturaInput | multaCreateOrConnectWithoutViaturaInput[]
    upsert?: multaUpsertWithWhereUniqueWithoutViaturaInput | multaUpsertWithWhereUniqueWithoutViaturaInput[]
    createMany?: multaCreateManyViaturaInputEnvelope
    set?: multaWhereUniqueInput | multaWhereUniqueInput[]
    disconnect?: multaWhereUniqueInput | multaWhereUniqueInput[]
    delete?: multaWhereUniqueInput | multaWhereUniqueInput[]
    connect?: multaWhereUniqueInput | multaWhereUniqueInput[]
    update?: multaUpdateWithWhereUniqueWithoutViaturaInput | multaUpdateWithWhereUniqueWithoutViaturaInput[]
    updateMany?: multaUpdateManyWithWhereWithoutViaturaInput | multaUpdateManyWithWhereWithoutViaturaInput[]
    deleteMany?: multaScalarWhereInput | multaScalarWhereInput[]
  }

  export type titulopropriedadeUncheckedUpdateManyWithoutViaturaNestedInput = {
    create?: XOR<titulopropriedadeCreateWithoutViaturaInput, titulopropriedadeUncheckedCreateWithoutViaturaInput> | titulopropriedadeCreateWithoutViaturaInput[] | titulopropriedadeUncheckedCreateWithoutViaturaInput[]
    connectOrCreate?: titulopropriedadeCreateOrConnectWithoutViaturaInput | titulopropriedadeCreateOrConnectWithoutViaturaInput[]
    upsert?: titulopropriedadeUpsertWithWhereUniqueWithoutViaturaInput | titulopropriedadeUpsertWithWhereUniqueWithoutViaturaInput[]
    createMany?: titulopropriedadeCreateManyViaturaInputEnvelope
    set?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    disconnect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    delete?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    connect?: titulopropriedadeWhereUniqueInput | titulopropriedadeWhereUniqueInput[]
    update?: titulopropriedadeUpdateWithWhereUniqueWithoutViaturaInput | titulopropriedadeUpdateWithWhereUniqueWithoutViaturaInput[]
    updateMany?: titulopropriedadeUpdateManyWithWhereWithoutViaturaInput | titulopropriedadeUpdateManyWithWhereWithoutViaturaInput[]
    deleteMany?: titulopropriedadeScalarWhereInput | titulopropriedadeScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumficheiro_estadoValidacaoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ficheiro_estadoValidacao | Enumficheiro_estadoValidacaoFieldRefInput<$PrismaModel> | null
    in?: $Enums.ficheiro_estadoValidacao[] | null
    notIn?: $Enums.ficheiro_estadoValidacao[] | null
    not?: NestedEnumficheiro_estadoValidacaoNullableFilter<$PrismaModel> | $Enums.ficheiro_estadoValidacao | null
  }

  export type NestedEnumficheiro_estadoValidacaoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ficheiro_estadoValidacao | Enumficheiro_estadoValidacaoFieldRefInput<$PrismaModel> | null
    in?: $Enums.ficheiro_estadoValidacao[] | null
    notIn?: $Enums.ficheiro_estadoValidacao[] | null
    not?: NestedEnumficheiro_estadoValidacaoNullableWithAggregatesFilter<$PrismaModel> | $Enums.ficheiro_estadoValidacao | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumficheiro_estadoValidacaoNullableFilter<$PrismaModel>
    _max?: NestedEnumficheiro_estadoValidacaoNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnummulta_estadoMultaFilter<$PrismaModel = never> = {
    equals?: $Enums.multa_estadoMulta | Enummulta_estadoMultaFieldRefInput<$PrismaModel>
    in?: $Enums.multa_estadoMulta[]
    notIn?: $Enums.multa_estadoMulta[]
    not?: NestedEnummulta_estadoMultaFilter<$PrismaModel> | $Enums.multa_estadoMulta
  }

  export type NestedEnummulta_estadoMultaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.multa_estadoMulta | Enummulta_estadoMultaFieldRefInput<$PrismaModel>
    in?: $Enums.multa_estadoMulta[]
    notIn?: $Enums.multa_estadoMulta[]
    not?: NestedEnummulta_estadoMultaWithAggregatesFilter<$PrismaModel> | $Enums.multa_estadoMulta
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnummulta_estadoMultaFilter<$PrismaModel>
    _max?: NestedEnummulta_estadoMultaFilter<$PrismaModel>
  }

  export type NestedEnumpessoa_generoFilter<$PrismaModel = never> = {
    equals?: $Enums.pessoa_genero | Enumpessoa_generoFieldRefInput<$PrismaModel>
    in?: $Enums.pessoa_genero[]
    notIn?: $Enums.pessoa_genero[]
    not?: NestedEnumpessoa_generoFilter<$PrismaModel> | $Enums.pessoa_genero
  }

  export type NestedEnumpessoa_estadoCivilFilter<$PrismaModel = never> = {
    equals?: $Enums.pessoa_estadoCivil | Enumpessoa_estadoCivilFieldRefInput<$PrismaModel>
    in?: $Enums.pessoa_estadoCivil[]
    notIn?: $Enums.pessoa_estadoCivil[]
    not?: NestedEnumpessoa_estadoCivilFilter<$PrismaModel> | $Enums.pessoa_estadoCivil
  }

  export type NestedEnumpessoa_generoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.pessoa_genero | Enumpessoa_generoFieldRefInput<$PrismaModel>
    in?: $Enums.pessoa_genero[]
    notIn?: $Enums.pessoa_genero[]
    not?: NestedEnumpessoa_generoWithAggregatesFilter<$PrismaModel> | $Enums.pessoa_genero
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpessoa_generoFilter<$PrismaModel>
    _max?: NestedEnumpessoa_generoFilter<$PrismaModel>
  }

  export type NestedEnumpessoa_estadoCivilWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.pessoa_estadoCivil | Enumpessoa_estadoCivilFieldRefInput<$PrismaModel>
    in?: $Enums.pessoa_estadoCivil[]
    notIn?: $Enums.pessoa_estadoCivil[]
    not?: NestedEnumpessoa_estadoCivilWithAggregatesFilter<$PrismaModel> | $Enums.pessoa_estadoCivil
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpessoa_estadoCivilFilter<$PrismaModel>
    _max?: NestedEnumpessoa_estadoCivilFilter<$PrismaModel>
  }

  export type automobilistaCreateWithoutAlertarouboInput = {
    cartaconducao: cartaconducaoCreateNestedOneWithoutAutomobilistaInput
    pessoa: pessoaCreateNestedOneWithoutAutomobilistaInput
    multa?: multaCreateNestedManyWithoutAutomobilistaInput
  }

  export type automobilistaUncheckedCreateWithoutAlertarouboInput = {
    codAutomobilista?: number
    codCartaConducao: number
    codPessoa: number
    multa?: multaUncheckedCreateNestedManyWithoutAutomobilistaInput
  }

  export type automobilistaCreateOrConnectWithoutAlertarouboInput = {
    where: automobilistaWhereUniqueInput
    create: XOR<automobilistaCreateWithoutAlertarouboInput, automobilistaUncheckedCreateWithoutAlertarouboInput>
  }

  export type tiporouboCreateWithoutAlertarouboInput = {
    descTipoRoubo: string
  }

  export type tiporouboUncheckedCreateWithoutAlertarouboInput = {
    codTipoRoubo?: number
    descTipoRoubo: string
  }

  export type tiporouboCreateOrConnectWithoutAlertarouboInput = {
    where: tiporouboWhereUniqueInput
    create: XOR<tiporouboCreateWithoutAlertarouboInput, tiporouboUncheckedCreateWithoutAlertarouboInput>
  }

  export type viaturaCreateWithoutAlertarouboInput = {
    numeroMatricula: string
    livrete?: livreteCreateNestedManyWithoutViaturaInput
    multa?: multaCreateNestedManyWithoutViaturaInput
    titulopropriedade?: titulopropriedadeCreateNestedManyWithoutViaturaInput
  }

  export type viaturaUncheckedCreateWithoutAlertarouboInput = {
    codViatura?: number
    numeroMatricula: string
    livrete?: livreteUncheckedCreateNestedManyWithoutViaturaInput
    multa?: multaUncheckedCreateNestedManyWithoutViaturaInput
    titulopropriedade?: titulopropriedadeUncheckedCreateNestedManyWithoutViaturaInput
  }

  export type viaturaCreateOrConnectWithoutAlertarouboInput = {
    where: viaturaWhereUniqueInput
    create: XOR<viaturaCreateWithoutAlertarouboInput, viaturaUncheckedCreateWithoutAlertarouboInput>
  }

  export type automobilistaUpsertWithoutAlertarouboInput = {
    update: XOR<automobilistaUpdateWithoutAlertarouboInput, automobilistaUncheckedUpdateWithoutAlertarouboInput>
    create: XOR<automobilistaCreateWithoutAlertarouboInput, automobilistaUncheckedCreateWithoutAlertarouboInput>
    where?: automobilistaWhereInput
  }

  export type automobilistaUpdateToOneWithWhereWithoutAlertarouboInput = {
    where?: automobilistaWhereInput
    data: XOR<automobilistaUpdateWithoutAlertarouboInput, automobilistaUncheckedUpdateWithoutAlertarouboInput>
  }

  export type automobilistaUpdateWithoutAlertarouboInput = {
    cartaconducao?: cartaconducaoUpdateOneRequiredWithoutAutomobilistaNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutAutomobilistaNestedInput
    multa?: multaUpdateManyWithoutAutomobilistaNestedInput
  }

  export type automobilistaUncheckedUpdateWithoutAlertarouboInput = {
    codAutomobilista?: IntFieldUpdateOperationsInput | number
    codCartaConducao?: IntFieldUpdateOperationsInput | number
    codPessoa?: IntFieldUpdateOperationsInput | number
    multa?: multaUncheckedUpdateManyWithoutAutomobilistaNestedInput
  }

  export type tiporouboUpsertWithoutAlertarouboInput = {
    update: XOR<tiporouboUpdateWithoutAlertarouboInput, tiporouboUncheckedUpdateWithoutAlertarouboInput>
    create: XOR<tiporouboCreateWithoutAlertarouboInput, tiporouboUncheckedCreateWithoutAlertarouboInput>
    where?: tiporouboWhereInput
  }

  export type tiporouboUpdateToOneWithWhereWithoutAlertarouboInput = {
    where?: tiporouboWhereInput
    data: XOR<tiporouboUpdateWithoutAlertarouboInput, tiporouboUncheckedUpdateWithoutAlertarouboInput>
  }

  export type tiporouboUpdateWithoutAlertarouboInput = {
    descTipoRoubo?: StringFieldUpdateOperationsInput | string
  }

  export type tiporouboUncheckedUpdateWithoutAlertarouboInput = {
    codTipoRoubo?: IntFieldUpdateOperationsInput | number
    descTipoRoubo?: StringFieldUpdateOperationsInput | string
  }

  export type viaturaUpsertWithoutAlertarouboInput = {
    update: XOR<viaturaUpdateWithoutAlertarouboInput, viaturaUncheckedUpdateWithoutAlertarouboInput>
    create: XOR<viaturaCreateWithoutAlertarouboInput, viaturaUncheckedCreateWithoutAlertarouboInput>
    where?: viaturaWhereInput
  }

  export type viaturaUpdateToOneWithWhereWithoutAlertarouboInput = {
    where?: viaturaWhereInput
    data: XOR<viaturaUpdateWithoutAlertarouboInput, viaturaUncheckedUpdateWithoutAlertarouboInput>
  }

  export type viaturaUpdateWithoutAlertarouboInput = {
    numeroMatricula?: StringFieldUpdateOperationsInput | string
    livrete?: livreteUpdateManyWithoutViaturaNestedInput
    multa?: multaUpdateManyWithoutViaturaNestedInput
    titulopropriedade?: titulopropriedadeUpdateManyWithoutViaturaNestedInput
  }

  export type viaturaUncheckedUpdateWithoutAlertarouboInput = {
    codViatura?: IntFieldUpdateOperationsInput | number
    numeroMatricula?: StringFieldUpdateOperationsInput | string
    livrete?: livreteUncheckedUpdateManyWithoutViaturaNestedInput
    multa?: multaUncheckedUpdateManyWithoutViaturaNestedInput
    titulopropriedade?: titulopropriedadeUncheckedUpdateManyWithoutViaturaNestedInput
  }

  export type alertarouboCreateWithoutAutomobilistaInput = {
    dataRoubo: Date | string
    enderecoRoubo: string
    descRoubo: string
    tiporoubo: tiporouboCreateNestedOneWithoutAlertarouboInput
    viatura: viaturaCreateNestedOneWithoutAlertarouboInput
  }

  export type alertarouboUncheckedCreateWithoutAutomobilistaInput = {
    codAlertaRoubo?: number
    codViatura: number
    dataRoubo: Date | string
    enderecoRoubo: string
    codTipoRoubo: number
    descRoubo: string
  }

  export type alertarouboCreateOrConnectWithoutAutomobilistaInput = {
    where: alertarouboWhereUniqueInput
    create: XOR<alertarouboCreateWithoutAutomobilistaInput, alertarouboUncheckedCreateWithoutAutomobilistaInput>
  }

  export type alertarouboCreateManyAutomobilistaInputEnvelope = {
    data: alertarouboCreateManyAutomobilistaInput | alertarouboCreateManyAutomobilistaInput[]
    skipDuplicates?: boolean
  }

  export type cartaconducaoCreateWithoutAutomobilistaInput = {
    dataEmissao: Date | string
    dataValidade: Date | string
    numeroVia: string
    numeroCarta: number
    dataPrimeiraEmissao: Date | string
    localEmissao: number
    categoriacarta: categoriacartaCreateNestedOneWithoutCartaconducaoInput
    ficheiro: ficheiroCreateNestedOneWithoutCartaconducaoInput
  }

  export type cartaconducaoUncheckedCreateWithoutAutomobilistaInput = {
    codCartaConducao?: number
    dataEmissao: Date | string
    dataValidade: Date | string
    numeroVia: string
    codCategoriaCarta: number
    numeroCarta: number
    dataPrimeiraEmissao: Date | string
    localEmissao: number
    codFicheiroCartaConducao: number
  }

  export type cartaconducaoCreateOrConnectWithoutAutomobilistaInput = {
    where: cartaconducaoWhereUniqueInput
    create: XOR<cartaconducaoCreateWithoutAutomobilistaInput, cartaconducaoUncheckedCreateWithoutAutomobilistaInput>
  }

  export type pessoaCreateWithoutAutomobilistaInput = {
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    senha: string
    funcionario?: funcionarioCreateNestedManyWithoutPessoaInput
    contacto?: contactoCreateNestedOneWithoutPessoaInput
    endereco?: enderecoCreateNestedOneWithoutPessoaInput
    pais?: paisCreateNestedOneWithoutPessoaInput
    bi: biCreateNestedOneWithoutPessoaInput
    titulopropriedade?: titulopropriedadeCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutAutomobilistaInput = {
    codPessoa?: number
    codEndereco?: number | null
    codNacionalidade?: number | null
    codContacto?: number | null
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    codBi: number
    senha: string
    funcionario?: funcionarioUncheckedCreateNestedManyWithoutPessoaInput
    titulopropriedade?: titulopropriedadeUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutAutomobilistaInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutAutomobilistaInput, pessoaUncheckedCreateWithoutAutomobilistaInput>
  }

  export type multaCreateWithoutAutomobilistaInput = {
    valorMulta: string
    estadoMulta: $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoCreateNestedManyWithoutMulta_infracao_codMultaTomultaInput
    infracao_multa_codInfracaoToinfracao: infracaoCreateNestedOneWithoutMulta_multa_codInfracaoToinfracaoInput
    viatura?: viaturaCreateNestedOneWithoutMultaInput
    pagamentomulta?: pagamentomultaCreateNestedManyWithoutMultaInput
  }

  export type multaUncheckedCreateWithoutAutomobilistaInput = {
    codMulta?: number
    CodViatura?: number | null
    codInfracao: number
    valorMulta: string
    estadoMulta: $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoUncheckedCreateNestedManyWithoutMulta_infracao_codMultaTomultaInput
    pagamentomulta?: pagamentomultaUncheckedCreateNestedManyWithoutMultaInput
  }

  export type multaCreateOrConnectWithoutAutomobilistaInput = {
    where: multaWhereUniqueInput
    create: XOR<multaCreateWithoutAutomobilistaInput, multaUncheckedCreateWithoutAutomobilistaInput>
  }

  export type multaCreateManyAutomobilistaInputEnvelope = {
    data: multaCreateManyAutomobilistaInput | multaCreateManyAutomobilistaInput[]
    skipDuplicates?: boolean
  }

  export type alertarouboUpsertWithWhereUniqueWithoutAutomobilistaInput = {
    where: alertarouboWhereUniqueInput
    update: XOR<alertarouboUpdateWithoutAutomobilistaInput, alertarouboUncheckedUpdateWithoutAutomobilistaInput>
    create: XOR<alertarouboCreateWithoutAutomobilistaInput, alertarouboUncheckedCreateWithoutAutomobilistaInput>
  }

  export type alertarouboUpdateWithWhereUniqueWithoutAutomobilistaInput = {
    where: alertarouboWhereUniqueInput
    data: XOR<alertarouboUpdateWithoutAutomobilistaInput, alertarouboUncheckedUpdateWithoutAutomobilistaInput>
  }

  export type alertarouboUpdateManyWithWhereWithoutAutomobilistaInput = {
    where: alertarouboScalarWhereInput
    data: XOR<alertarouboUpdateManyMutationInput, alertarouboUncheckedUpdateManyWithoutAutomobilistaInput>
  }

  export type alertarouboScalarWhereInput = {
    AND?: alertarouboScalarWhereInput | alertarouboScalarWhereInput[]
    OR?: alertarouboScalarWhereInput[]
    NOT?: alertarouboScalarWhereInput | alertarouboScalarWhereInput[]
    codAlertaRoubo?: IntFilter<"alertaroubo"> | number
    codAutomobilista?: IntFilter<"alertaroubo"> | number
    codViatura?: IntFilter<"alertaroubo"> | number
    dataRoubo?: DateTimeFilter<"alertaroubo"> | Date | string
    enderecoRoubo?: StringFilter<"alertaroubo"> | string
    codTipoRoubo?: IntFilter<"alertaroubo"> | number
    descRoubo?: StringFilter<"alertaroubo"> | string
  }

  export type cartaconducaoUpsertWithoutAutomobilistaInput = {
    update: XOR<cartaconducaoUpdateWithoutAutomobilistaInput, cartaconducaoUncheckedUpdateWithoutAutomobilistaInput>
    create: XOR<cartaconducaoCreateWithoutAutomobilistaInput, cartaconducaoUncheckedCreateWithoutAutomobilistaInput>
    where?: cartaconducaoWhereInput
  }

  export type cartaconducaoUpdateToOneWithWhereWithoutAutomobilistaInput = {
    where?: cartaconducaoWhereInput
    data: XOR<cartaconducaoUpdateWithoutAutomobilistaInput, cartaconducaoUncheckedUpdateWithoutAutomobilistaInput>
  }

  export type cartaconducaoUpdateWithoutAutomobilistaInput = {
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroVia?: StringFieldUpdateOperationsInput | string
    numeroCarta?: IntFieldUpdateOperationsInput | number
    dataPrimeiraEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    localEmissao?: IntFieldUpdateOperationsInput | number
    categoriacarta?: categoriacartaUpdateOneRequiredWithoutCartaconducaoNestedInput
    ficheiro?: ficheiroUpdateOneRequiredWithoutCartaconducaoNestedInput
  }

  export type cartaconducaoUncheckedUpdateWithoutAutomobilistaInput = {
    codCartaConducao?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroVia?: StringFieldUpdateOperationsInput | string
    codCategoriaCarta?: IntFieldUpdateOperationsInput | number
    numeroCarta?: IntFieldUpdateOperationsInput | number
    dataPrimeiraEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    localEmissao?: IntFieldUpdateOperationsInput | number
    codFicheiroCartaConducao?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaUpsertWithoutAutomobilistaInput = {
    update: XOR<pessoaUpdateWithoutAutomobilistaInput, pessoaUncheckedUpdateWithoutAutomobilistaInput>
    create: XOR<pessoaCreateWithoutAutomobilistaInput, pessoaUncheckedCreateWithoutAutomobilistaInput>
    where?: pessoaWhereInput
  }

  export type pessoaUpdateToOneWithWhereWithoutAutomobilistaInput = {
    where?: pessoaWhereInput
    data: XOR<pessoaUpdateWithoutAutomobilistaInput, pessoaUncheckedUpdateWithoutAutomobilistaInput>
  }

  export type pessoaUpdateWithoutAutomobilistaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    funcionario?: funcionarioUpdateManyWithoutPessoaNestedInput
    contacto?: contactoUpdateOneWithoutPessoaNestedInput
    endereco?: enderecoUpdateOneWithoutPessoaNestedInput
    pais?: paisUpdateOneWithoutPessoaNestedInput
    bi?: biUpdateOneRequiredWithoutPessoaNestedInput
    titulopropriedade?: titulopropriedadeUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutAutomobilistaInput = {
    codPessoa?: IntFieldUpdateOperationsInput | number
    codEndereco?: NullableIntFieldUpdateOperationsInput | number | null
    codNacionalidade?: NullableIntFieldUpdateOperationsInput | number | null
    codContacto?: NullableIntFieldUpdateOperationsInput | number | null
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    codBi?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    funcionario?: funcionarioUncheckedUpdateManyWithoutPessoaNestedInput
    titulopropriedade?: titulopropriedadeUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type multaUpsertWithWhereUniqueWithoutAutomobilistaInput = {
    where: multaWhereUniqueInput
    update: XOR<multaUpdateWithoutAutomobilistaInput, multaUncheckedUpdateWithoutAutomobilistaInput>
    create: XOR<multaCreateWithoutAutomobilistaInput, multaUncheckedCreateWithoutAutomobilistaInput>
  }

  export type multaUpdateWithWhereUniqueWithoutAutomobilistaInput = {
    where: multaWhereUniqueInput
    data: XOR<multaUpdateWithoutAutomobilistaInput, multaUncheckedUpdateWithoutAutomobilistaInput>
  }

  export type multaUpdateManyWithWhereWithoutAutomobilistaInput = {
    where: multaScalarWhereInput
    data: XOR<multaUpdateManyMutationInput, multaUncheckedUpdateManyWithoutAutomobilistaInput>
  }

  export type multaScalarWhereInput = {
    AND?: multaScalarWhereInput | multaScalarWhereInput[]
    OR?: multaScalarWhereInput[]
    NOT?: multaScalarWhereInput | multaScalarWhereInput[]
    codMulta?: IntFilter<"multa"> | number
    codAutomobilista?: IntNullableFilter<"multa"> | number | null
    CodViatura?: IntNullableFilter<"multa"> | number | null
    codInfracao?: IntFilter<"multa"> | number
    valorMulta?: StringFilter<"multa"> | string
    estadoMulta?: Enummulta_estadoMultaFilter<"multa"> | $Enums.multa_estadoMulta
  }

  export type ficheiroCreateWithoutBiInput = {
    nomeFicheiro: string
    dataEntrada?: string | null
    dataValidacao?: string | null
    estadoValidacao?: $Enums.ficheiro_estadoValidacao | null
    cartaconducao?: cartaconducaoCreateNestedManyWithoutFicheiroInput
    funcionario?: funcionarioCreateNestedManyWithoutFicheiroInput
    pagamentomulta?: pagamentomultaCreateNestedManyWithoutFicheiroInput
    titulopropriedade?: titulopropriedadeCreateNestedManyWithoutFicheiroInput
  }

  export type ficheiroUncheckedCreateWithoutBiInput = {
    idFicheiro?: number
    nomeFicheiro: string
    dataEntrada?: string | null
    dataValidacao?: string | null
    estadoValidacao?: $Enums.ficheiro_estadoValidacao | null
    cartaconducao?: cartaconducaoUncheckedCreateNestedManyWithoutFicheiroInput
    funcionario?: funcionarioUncheckedCreateNestedManyWithoutFicheiroInput
    pagamentomulta?: pagamentomultaUncheckedCreateNestedManyWithoutFicheiroInput
    titulopropriedade?: titulopropriedadeUncheckedCreateNestedManyWithoutFicheiroInput
  }

  export type ficheiroCreateOrConnectWithoutBiInput = {
    where: ficheiroWhereUniqueInput
    create: XOR<ficheiroCreateWithoutBiInput, ficheiroUncheckedCreateWithoutBiInput>
  }

  export type pessoaCreateWithoutBiInput = {
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    senha: string
    automobilista?: automobilistaCreateNestedManyWithoutPessoaInput
    funcionario?: funcionarioCreateNestedManyWithoutPessoaInput
    contacto?: contactoCreateNestedOneWithoutPessoaInput
    endereco?: enderecoCreateNestedOneWithoutPessoaInput
    pais?: paisCreateNestedOneWithoutPessoaInput
    titulopropriedade?: titulopropriedadeCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutBiInput = {
    codPessoa?: number
    codEndereco?: number | null
    codNacionalidade?: number | null
    codContacto?: number | null
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    senha: string
    automobilista?: automobilistaUncheckedCreateNestedManyWithoutPessoaInput
    funcionario?: funcionarioUncheckedCreateNestedManyWithoutPessoaInput
    titulopropriedade?: titulopropriedadeUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutBiInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutBiInput, pessoaUncheckedCreateWithoutBiInput>
  }

  export type pessoaCreateManyBiInputEnvelope = {
    data: pessoaCreateManyBiInput | pessoaCreateManyBiInput[]
    skipDuplicates?: boolean
  }

  export type ficheiroUpsertWithoutBiInput = {
    update: XOR<ficheiroUpdateWithoutBiInput, ficheiroUncheckedUpdateWithoutBiInput>
    create: XOR<ficheiroCreateWithoutBiInput, ficheiroUncheckedCreateWithoutBiInput>
    where?: ficheiroWhereInput
  }

  export type ficheiroUpdateToOneWithWhereWithoutBiInput = {
    where?: ficheiroWhereInput
    data: XOR<ficheiroUpdateWithoutBiInput, ficheiroUncheckedUpdateWithoutBiInput>
  }

  export type ficheiroUpdateWithoutBiInput = {
    nomeFicheiro?: StringFieldUpdateOperationsInput | string
    dataEntrada?: NullableStringFieldUpdateOperationsInput | string | null
    dataValidacao?: NullableStringFieldUpdateOperationsInput | string | null
    estadoValidacao?: NullableEnumficheiro_estadoValidacaoFieldUpdateOperationsInput | $Enums.ficheiro_estadoValidacao | null
    cartaconducao?: cartaconducaoUpdateManyWithoutFicheiroNestedInput
    funcionario?: funcionarioUpdateManyWithoutFicheiroNestedInput
    pagamentomulta?: pagamentomultaUpdateManyWithoutFicheiroNestedInput
    titulopropriedade?: titulopropriedadeUpdateManyWithoutFicheiroNestedInput
  }

  export type ficheiroUncheckedUpdateWithoutBiInput = {
    idFicheiro?: IntFieldUpdateOperationsInput | number
    nomeFicheiro?: StringFieldUpdateOperationsInput | string
    dataEntrada?: NullableStringFieldUpdateOperationsInput | string | null
    dataValidacao?: NullableStringFieldUpdateOperationsInput | string | null
    estadoValidacao?: NullableEnumficheiro_estadoValidacaoFieldUpdateOperationsInput | $Enums.ficheiro_estadoValidacao | null
    cartaconducao?: cartaconducaoUncheckedUpdateManyWithoutFicheiroNestedInput
    funcionario?: funcionarioUncheckedUpdateManyWithoutFicheiroNestedInput
    pagamentomulta?: pagamentomultaUncheckedUpdateManyWithoutFicheiroNestedInput
    titulopropriedade?: titulopropriedadeUncheckedUpdateManyWithoutFicheiroNestedInput
  }

  export type pessoaUpsertWithWhereUniqueWithoutBiInput = {
    where: pessoaWhereUniqueInput
    update: XOR<pessoaUpdateWithoutBiInput, pessoaUncheckedUpdateWithoutBiInput>
    create: XOR<pessoaCreateWithoutBiInput, pessoaUncheckedCreateWithoutBiInput>
  }

  export type pessoaUpdateWithWhereUniqueWithoutBiInput = {
    where: pessoaWhereUniqueInput
    data: XOR<pessoaUpdateWithoutBiInput, pessoaUncheckedUpdateWithoutBiInput>
  }

  export type pessoaUpdateManyWithWhereWithoutBiInput = {
    where: pessoaScalarWhereInput
    data: XOR<pessoaUpdateManyMutationInput, pessoaUncheckedUpdateManyWithoutBiInput>
  }

  export type pessoaScalarWhereInput = {
    AND?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
    OR?: pessoaScalarWhereInput[]
    NOT?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
    codPessoa?: IntFilter<"pessoa"> | number
    codEndereco?: IntNullableFilter<"pessoa"> | number | null
    codNacionalidade?: IntNullableFilter<"pessoa"> | number | null
    codContacto?: IntNullableFilter<"pessoa"> | number | null
    nome?: StringFilter<"pessoa"> | string
    genero?: Enumpessoa_generoFilter<"pessoa"> | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFilter<"pessoa"> | $Enums.pessoa_estadoCivil
    dataCadastro?: StringNullableFilter<"pessoa"> | string | null
    dataNascimento?: StringFilter<"pessoa"> | string
    codBi?: IntFilter<"pessoa"> | number
    senha?: StringFilter<"pessoa"> | string
  }

  export type automobilistaCreateWithoutCartaconducaoInput = {
    alertaroubo?: alertarouboCreateNestedManyWithoutAutomobilistaInput
    pessoa: pessoaCreateNestedOneWithoutAutomobilistaInput
    multa?: multaCreateNestedManyWithoutAutomobilistaInput
  }

  export type automobilistaUncheckedCreateWithoutCartaconducaoInput = {
    codAutomobilista?: number
    codPessoa: number
    alertaroubo?: alertarouboUncheckedCreateNestedManyWithoutAutomobilistaInput
    multa?: multaUncheckedCreateNestedManyWithoutAutomobilistaInput
  }

  export type automobilistaCreateOrConnectWithoutCartaconducaoInput = {
    where: automobilistaWhereUniqueInput
    create: XOR<automobilistaCreateWithoutCartaconducaoInput, automobilistaUncheckedCreateWithoutCartaconducaoInput>
  }

  export type automobilistaCreateManyCartaconducaoInputEnvelope = {
    data: automobilistaCreateManyCartaconducaoInput | automobilistaCreateManyCartaconducaoInput[]
    skipDuplicates?: boolean
  }

  export type categoriacartaCreateWithoutCartaconducaoInput = {
    descCategoriaCarta: string
    sigla: string
  }

  export type categoriacartaUncheckedCreateWithoutCartaconducaoInput = {
    codCategoriaCarta?: number
    descCategoriaCarta: string
    sigla: string
  }

  export type categoriacartaCreateOrConnectWithoutCartaconducaoInput = {
    where: categoriacartaWhereUniqueInput
    create: XOR<categoriacartaCreateWithoutCartaconducaoInput, categoriacartaUncheckedCreateWithoutCartaconducaoInput>
  }

  export type ficheiroCreateWithoutCartaconducaoInput = {
    nomeFicheiro: string
    dataEntrada?: string | null
    dataValidacao?: string | null
    estadoValidacao?: $Enums.ficheiro_estadoValidacao | null
    bi?: biCreateNestedManyWithoutFicheiroInput
    funcionario?: funcionarioCreateNestedManyWithoutFicheiroInput
    pagamentomulta?: pagamentomultaCreateNestedManyWithoutFicheiroInput
    titulopropriedade?: titulopropriedadeCreateNestedManyWithoutFicheiroInput
  }

  export type ficheiroUncheckedCreateWithoutCartaconducaoInput = {
    idFicheiro?: number
    nomeFicheiro: string
    dataEntrada?: string | null
    dataValidacao?: string | null
    estadoValidacao?: $Enums.ficheiro_estadoValidacao | null
    bi?: biUncheckedCreateNestedManyWithoutFicheiroInput
    funcionario?: funcionarioUncheckedCreateNestedManyWithoutFicheiroInput
    pagamentomulta?: pagamentomultaUncheckedCreateNestedManyWithoutFicheiroInput
    titulopropriedade?: titulopropriedadeUncheckedCreateNestedManyWithoutFicheiroInput
  }

  export type ficheiroCreateOrConnectWithoutCartaconducaoInput = {
    where: ficheiroWhereUniqueInput
    create: XOR<ficheiroCreateWithoutCartaconducaoInput, ficheiroUncheckedCreateWithoutCartaconducaoInput>
  }

  export type automobilistaUpsertWithWhereUniqueWithoutCartaconducaoInput = {
    where: automobilistaWhereUniqueInput
    update: XOR<automobilistaUpdateWithoutCartaconducaoInput, automobilistaUncheckedUpdateWithoutCartaconducaoInput>
    create: XOR<automobilistaCreateWithoutCartaconducaoInput, automobilistaUncheckedCreateWithoutCartaconducaoInput>
  }

  export type automobilistaUpdateWithWhereUniqueWithoutCartaconducaoInput = {
    where: automobilistaWhereUniqueInput
    data: XOR<automobilistaUpdateWithoutCartaconducaoInput, automobilistaUncheckedUpdateWithoutCartaconducaoInput>
  }

  export type automobilistaUpdateManyWithWhereWithoutCartaconducaoInput = {
    where: automobilistaScalarWhereInput
    data: XOR<automobilistaUpdateManyMutationInput, automobilistaUncheckedUpdateManyWithoutCartaconducaoInput>
  }

  export type automobilistaScalarWhereInput = {
    AND?: automobilistaScalarWhereInput | automobilistaScalarWhereInput[]
    OR?: automobilistaScalarWhereInput[]
    NOT?: automobilistaScalarWhereInput | automobilistaScalarWhereInput[]
    codAutomobilista?: IntFilter<"automobilista"> | number
    codCartaConducao?: IntFilter<"automobilista"> | number
    codPessoa?: IntFilter<"automobilista"> | number
  }

  export type categoriacartaUpsertWithoutCartaconducaoInput = {
    update: XOR<categoriacartaUpdateWithoutCartaconducaoInput, categoriacartaUncheckedUpdateWithoutCartaconducaoInput>
    create: XOR<categoriacartaCreateWithoutCartaconducaoInput, categoriacartaUncheckedCreateWithoutCartaconducaoInput>
    where?: categoriacartaWhereInput
  }

  export type categoriacartaUpdateToOneWithWhereWithoutCartaconducaoInput = {
    where?: categoriacartaWhereInput
    data: XOR<categoriacartaUpdateWithoutCartaconducaoInput, categoriacartaUncheckedUpdateWithoutCartaconducaoInput>
  }

  export type categoriacartaUpdateWithoutCartaconducaoInput = {
    descCategoriaCarta?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
  }

  export type categoriacartaUncheckedUpdateWithoutCartaconducaoInput = {
    codCategoriaCarta?: IntFieldUpdateOperationsInput | number
    descCategoriaCarta?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
  }

  export type ficheiroUpsertWithoutCartaconducaoInput = {
    update: XOR<ficheiroUpdateWithoutCartaconducaoInput, ficheiroUncheckedUpdateWithoutCartaconducaoInput>
    create: XOR<ficheiroCreateWithoutCartaconducaoInput, ficheiroUncheckedCreateWithoutCartaconducaoInput>
    where?: ficheiroWhereInput
  }

  export type ficheiroUpdateToOneWithWhereWithoutCartaconducaoInput = {
    where?: ficheiroWhereInput
    data: XOR<ficheiroUpdateWithoutCartaconducaoInput, ficheiroUncheckedUpdateWithoutCartaconducaoInput>
  }

  export type ficheiroUpdateWithoutCartaconducaoInput = {
    nomeFicheiro?: StringFieldUpdateOperationsInput | string
    dataEntrada?: NullableStringFieldUpdateOperationsInput | string | null
    dataValidacao?: NullableStringFieldUpdateOperationsInput | string | null
    estadoValidacao?: NullableEnumficheiro_estadoValidacaoFieldUpdateOperationsInput | $Enums.ficheiro_estadoValidacao | null
    bi?: biUpdateManyWithoutFicheiroNestedInput
    funcionario?: funcionarioUpdateManyWithoutFicheiroNestedInput
    pagamentomulta?: pagamentomultaUpdateManyWithoutFicheiroNestedInput
    titulopropriedade?: titulopropriedadeUpdateManyWithoutFicheiroNestedInput
  }

  export type ficheiroUncheckedUpdateWithoutCartaconducaoInput = {
    idFicheiro?: IntFieldUpdateOperationsInput | number
    nomeFicheiro?: StringFieldUpdateOperationsInput | string
    dataEntrada?: NullableStringFieldUpdateOperationsInput | string | null
    dataValidacao?: NullableStringFieldUpdateOperationsInput | string | null
    estadoValidacao?: NullableEnumficheiro_estadoValidacaoFieldUpdateOperationsInput | $Enums.ficheiro_estadoValidacao | null
    bi?: biUncheckedUpdateManyWithoutFicheiroNestedInput
    funcionario?: funcionarioUncheckedUpdateManyWithoutFicheiroNestedInput
    pagamentomulta?: pagamentomultaUncheckedUpdateManyWithoutFicheiroNestedInput
    titulopropriedade?: titulopropriedadeUncheckedUpdateManyWithoutFicheiroNestedInput
  }

  export type cartaconducaoCreateWithoutCategoriacartaInput = {
    dataEmissao: Date | string
    dataValidade: Date | string
    numeroVia: string
    numeroCarta: number
    dataPrimeiraEmissao: Date | string
    localEmissao: number
    automobilista?: automobilistaCreateNestedManyWithoutCartaconducaoInput
    ficheiro: ficheiroCreateNestedOneWithoutCartaconducaoInput
  }

  export type cartaconducaoUncheckedCreateWithoutCategoriacartaInput = {
    codCartaConducao?: number
    dataEmissao: Date | string
    dataValidade: Date | string
    numeroVia: string
    numeroCarta: number
    dataPrimeiraEmissao: Date | string
    localEmissao: number
    codFicheiroCartaConducao: number
    automobilista?: automobilistaUncheckedCreateNestedManyWithoutCartaconducaoInput
  }

  export type cartaconducaoCreateOrConnectWithoutCategoriacartaInput = {
    where: cartaconducaoWhereUniqueInput
    create: XOR<cartaconducaoCreateWithoutCategoriacartaInput, cartaconducaoUncheckedCreateWithoutCategoriacartaInput>
  }

  export type cartaconducaoCreateManyCategoriacartaInputEnvelope = {
    data: cartaconducaoCreateManyCategoriacartaInput | cartaconducaoCreateManyCategoriacartaInput[]
    skipDuplicates?: boolean
  }

  export type cartaconducaoUpsertWithWhereUniqueWithoutCategoriacartaInput = {
    where: cartaconducaoWhereUniqueInput
    update: XOR<cartaconducaoUpdateWithoutCategoriacartaInput, cartaconducaoUncheckedUpdateWithoutCategoriacartaInput>
    create: XOR<cartaconducaoCreateWithoutCategoriacartaInput, cartaconducaoUncheckedCreateWithoutCategoriacartaInput>
  }

  export type cartaconducaoUpdateWithWhereUniqueWithoutCategoriacartaInput = {
    where: cartaconducaoWhereUniqueInput
    data: XOR<cartaconducaoUpdateWithoutCategoriacartaInput, cartaconducaoUncheckedUpdateWithoutCategoriacartaInput>
  }

  export type cartaconducaoUpdateManyWithWhereWithoutCategoriacartaInput = {
    where: cartaconducaoScalarWhereInput
    data: XOR<cartaconducaoUpdateManyMutationInput, cartaconducaoUncheckedUpdateManyWithoutCategoriacartaInput>
  }

  export type cartaconducaoScalarWhereInput = {
    AND?: cartaconducaoScalarWhereInput | cartaconducaoScalarWhereInput[]
    OR?: cartaconducaoScalarWhereInput[]
    NOT?: cartaconducaoScalarWhereInput | cartaconducaoScalarWhereInput[]
    codCartaConducao?: IntFilter<"cartaconducao"> | number
    dataEmissao?: DateTimeFilter<"cartaconducao"> | Date | string
    dataValidade?: DateTimeFilter<"cartaconducao"> | Date | string
    numeroVia?: StringFilter<"cartaconducao"> | string
    codCategoriaCarta?: IntFilter<"cartaconducao"> | number
    numeroCarta?: IntFilter<"cartaconducao"> | number
    dataPrimeiraEmissao?: DateTimeFilter<"cartaconducao"> | Date | string
    localEmissao?: IntFilter<"cartaconducao"> | number
    codFicheiroCartaConducao?: IntFilter<"cartaconducao"> | number
  }

  export type pessoaCreateWithoutContactoInput = {
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    senha: string
    automobilista?: automobilistaCreateNestedManyWithoutPessoaInput
    funcionario?: funcionarioCreateNestedManyWithoutPessoaInput
    endereco?: enderecoCreateNestedOneWithoutPessoaInput
    pais?: paisCreateNestedOneWithoutPessoaInput
    bi: biCreateNestedOneWithoutPessoaInput
    titulopropriedade?: titulopropriedadeCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutContactoInput = {
    codPessoa?: number
    codEndereco?: number | null
    codNacionalidade?: number | null
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    codBi: number
    senha: string
    automobilista?: automobilistaUncheckedCreateNestedManyWithoutPessoaInput
    funcionario?: funcionarioUncheckedCreateNestedManyWithoutPessoaInput
    titulopropriedade?: titulopropriedadeUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutContactoInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutContactoInput, pessoaUncheckedCreateWithoutContactoInput>
  }

  export type pessoaCreateManyContactoInputEnvelope = {
    data: pessoaCreateManyContactoInput | pessoaCreateManyContactoInput[]
    skipDuplicates?: boolean
  }

  export type pessoaUpsertWithWhereUniqueWithoutContactoInput = {
    where: pessoaWhereUniqueInput
    update: XOR<pessoaUpdateWithoutContactoInput, pessoaUncheckedUpdateWithoutContactoInput>
    create: XOR<pessoaCreateWithoutContactoInput, pessoaUncheckedCreateWithoutContactoInput>
  }

  export type pessoaUpdateWithWhereUniqueWithoutContactoInput = {
    where: pessoaWhereUniqueInput
    data: XOR<pessoaUpdateWithoutContactoInput, pessoaUncheckedUpdateWithoutContactoInput>
  }

  export type pessoaUpdateManyWithWhereWithoutContactoInput = {
    where: pessoaScalarWhereInput
    data: XOR<pessoaUpdateManyMutationInput, pessoaUncheckedUpdateManyWithoutContactoInput>
  }

  export type municipioCreateWithoutEnderecoInput = {
    municipio: string
    provincia: provinciaCreateNestedOneWithoutMunicipioInput
  }

  export type municipioUncheckedCreateWithoutEnderecoInput = {
    idMunicipio?: number
    idProvincia: number
    municipio: string
  }

  export type municipioCreateOrConnectWithoutEnderecoInput = {
    where: municipioWhereUniqueInput
    create: XOR<municipioCreateWithoutEnderecoInput, municipioUncheckedCreateWithoutEnderecoInput>
  }

  export type pessoaCreateWithoutEnderecoInput = {
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    senha: string
    automobilista?: automobilistaCreateNestedManyWithoutPessoaInput
    funcionario?: funcionarioCreateNestedManyWithoutPessoaInput
    contacto?: contactoCreateNestedOneWithoutPessoaInput
    pais?: paisCreateNestedOneWithoutPessoaInput
    bi: biCreateNestedOneWithoutPessoaInput
    titulopropriedade?: titulopropriedadeCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutEnderecoInput = {
    codPessoa?: number
    codNacionalidade?: number | null
    codContacto?: number | null
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    codBi: number
    senha: string
    automobilista?: automobilistaUncheckedCreateNestedManyWithoutPessoaInput
    funcionario?: funcionarioUncheckedCreateNestedManyWithoutPessoaInput
    titulopropriedade?: titulopropriedadeUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutEnderecoInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutEnderecoInput, pessoaUncheckedCreateWithoutEnderecoInput>
  }

  export type pessoaCreateManyEnderecoInputEnvelope = {
    data: pessoaCreateManyEnderecoInput | pessoaCreateManyEnderecoInput[]
    skipDuplicates?: boolean
  }

  export type municipioUpsertWithoutEnderecoInput = {
    update: XOR<municipioUpdateWithoutEnderecoInput, municipioUncheckedUpdateWithoutEnderecoInput>
    create: XOR<municipioCreateWithoutEnderecoInput, municipioUncheckedCreateWithoutEnderecoInput>
    where?: municipioWhereInput
  }

  export type municipioUpdateToOneWithWhereWithoutEnderecoInput = {
    where?: municipioWhereInput
    data: XOR<municipioUpdateWithoutEnderecoInput, municipioUncheckedUpdateWithoutEnderecoInput>
  }

  export type municipioUpdateWithoutEnderecoInput = {
    municipio?: StringFieldUpdateOperationsInput | string
    provincia?: provinciaUpdateOneRequiredWithoutMunicipioNestedInput
  }

  export type municipioUncheckedUpdateWithoutEnderecoInput = {
    idMunicipio?: IntFieldUpdateOperationsInput | number
    idProvincia?: IntFieldUpdateOperationsInput | number
    municipio?: StringFieldUpdateOperationsInput | string
  }

  export type pessoaUpsertWithWhereUniqueWithoutEnderecoInput = {
    where: pessoaWhereUniqueInput
    update: XOR<pessoaUpdateWithoutEnderecoInput, pessoaUncheckedUpdateWithoutEnderecoInput>
    create: XOR<pessoaCreateWithoutEnderecoInput, pessoaUncheckedCreateWithoutEnderecoInput>
  }

  export type pessoaUpdateWithWhereUniqueWithoutEnderecoInput = {
    where: pessoaWhereUniqueInput
    data: XOR<pessoaUpdateWithoutEnderecoInput, pessoaUncheckedUpdateWithoutEnderecoInput>
  }

  export type pessoaUpdateManyWithWhereWithoutEnderecoInput = {
    where: pessoaScalarWhereInput
    data: XOR<pessoaUpdateManyMutationInput, pessoaUncheckedUpdateManyWithoutEnderecoInput>
  }

  export type biCreateWithoutFicheiroInput = {
    dataEmicaoBi: Date | string
    dataValidacaoBi: Date | string
    numeroBI: string
    pessoa?: pessoaCreateNestedManyWithoutBiInput
  }

  export type biUncheckedCreateWithoutFicheiroInput = {
    idBi?: number
    dataEmicaoBi: Date | string
    dataValidacaoBi: Date | string
    numeroBI: string
    pessoa?: pessoaUncheckedCreateNestedManyWithoutBiInput
  }

  export type biCreateOrConnectWithoutFicheiroInput = {
    where: biWhereUniqueInput
    create: XOR<biCreateWithoutFicheiroInput, biUncheckedCreateWithoutFicheiroInput>
  }

  export type biCreateManyFicheiroInputEnvelope = {
    data: biCreateManyFicheiroInput | biCreateManyFicheiroInput[]
    skipDuplicates?: boolean
  }

  export type cartaconducaoCreateWithoutFicheiroInput = {
    dataEmissao: Date | string
    dataValidade: Date | string
    numeroVia: string
    numeroCarta: number
    dataPrimeiraEmissao: Date | string
    localEmissao: number
    automobilista?: automobilistaCreateNestedManyWithoutCartaconducaoInput
    categoriacarta: categoriacartaCreateNestedOneWithoutCartaconducaoInput
  }

  export type cartaconducaoUncheckedCreateWithoutFicheiroInput = {
    codCartaConducao?: number
    dataEmissao: Date | string
    dataValidade: Date | string
    numeroVia: string
    codCategoriaCarta: number
    numeroCarta: number
    dataPrimeiraEmissao: Date | string
    localEmissao: number
    automobilista?: automobilistaUncheckedCreateNestedManyWithoutCartaconducaoInput
  }

  export type cartaconducaoCreateOrConnectWithoutFicheiroInput = {
    where: cartaconducaoWhereUniqueInput
    create: XOR<cartaconducaoCreateWithoutFicheiroInput, cartaconducaoUncheckedCreateWithoutFicheiroInput>
  }

  export type cartaconducaoCreateManyFicheiroInputEnvelope = {
    data: cartaconducaoCreateManyFicheiroInput | cartaconducaoCreateManyFicheiroInput[]
    skipDuplicates?: boolean
  }

  export type funcionarioCreateWithoutFicheiroInput = {
    codficheiroFotoPendente?: number | null
    numeroAgente?: string | null
    senha?: number
    pessoa: pessoaCreateNestedOneWithoutFuncionarioInput
  }

  export type funcionarioUncheckedCreateWithoutFicheiroInput = {
    codFuncionario?: number
    codPessoa: number
    codficheiroFotoPendente?: number | null
    numeroAgente?: string | null
    senha?: number
  }

  export type funcionarioCreateOrConnectWithoutFicheiroInput = {
    where: funcionarioWhereUniqueInput
    create: XOR<funcionarioCreateWithoutFicheiroInput, funcionarioUncheckedCreateWithoutFicheiroInput>
  }

  export type funcionarioCreateManyFicheiroInputEnvelope = {
    data: funcionarioCreateManyFicheiroInput | funcionarioCreateManyFicheiroInput[]
    skipDuplicates?: boolean
  }

  export type pagamentomultaCreateWithoutFicheiroInput = {
    dataPagamento: Date | string
    valorPago: string
    descCodigoDeposito: string
    multa: multaCreateNestedOneWithoutPagamentomultaInput
  }

  export type pagamentomultaUncheckedCreateWithoutFicheiroInput = {
    codPagamentoMulta?: number
    codMulta: number
    dataPagamento: Date | string
    valorPago: string
    descCodigoDeposito: string
  }

  export type pagamentomultaCreateOrConnectWithoutFicheiroInput = {
    where: pagamentomultaWhereUniqueInput
    create: XOR<pagamentomultaCreateWithoutFicheiroInput, pagamentomultaUncheckedCreateWithoutFicheiroInput>
  }

  export type pagamentomultaCreateManyFicheiroInputEnvelope = {
    data: pagamentomultaCreateManyFicheiroInput | pagamentomultaCreateManyFicheiroInput[]
    skipDuplicates?: boolean
  }

  export type titulopropriedadeCreateWithoutFicheiroInput = {
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    numeroEmissao: string
    pessoa: pessoaCreateNestedOneWithoutTitulopropriedadeInput
    viatura: viaturaCreateNestedOneWithoutTitulopropriedadeInput
  }

  export type titulopropriedadeUncheckedCreateWithoutFicheiroInput = {
    codTituloPropriedade?: number
    codPessoa: number
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    numeroEmissao: string
    codViatura: number
  }

  export type titulopropriedadeCreateOrConnectWithoutFicheiroInput = {
    where: titulopropriedadeWhereUniqueInput
    create: XOR<titulopropriedadeCreateWithoutFicheiroInput, titulopropriedadeUncheckedCreateWithoutFicheiroInput>
  }

  export type titulopropriedadeCreateManyFicheiroInputEnvelope = {
    data: titulopropriedadeCreateManyFicheiroInput | titulopropriedadeCreateManyFicheiroInput[]
    skipDuplicates?: boolean
  }

  export type biUpsertWithWhereUniqueWithoutFicheiroInput = {
    where: biWhereUniqueInput
    update: XOR<biUpdateWithoutFicheiroInput, biUncheckedUpdateWithoutFicheiroInput>
    create: XOR<biCreateWithoutFicheiroInput, biUncheckedCreateWithoutFicheiroInput>
  }

  export type biUpdateWithWhereUniqueWithoutFicheiroInput = {
    where: biWhereUniqueInput
    data: XOR<biUpdateWithoutFicheiroInput, biUncheckedUpdateWithoutFicheiroInput>
  }

  export type biUpdateManyWithWhereWithoutFicheiroInput = {
    where: biScalarWhereInput
    data: XOR<biUpdateManyMutationInput, biUncheckedUpdateManyWithoutFicheiroInput>
  }

  export type biScalarWhereInput = {
    AND?: biScalarWhereInput | biScalarWhereInput[]
    OR?: biScalarWhereInput[]
    NOT?: biScalarWhereInput | biScalarWhereInput[]
    idBi?: IntFilter<"bi"> | number
    dataEmicaoBi?: DateTimeFilter<"bi"> | Date | string
    dataValidacaoBi?: DateTimeFilter<"bi"> | Date | string
    numeroBI?: StringFilter<"bi"> | string
    codFicheiroBi?: IntFilter<"bi"> | number
  }

  export type cartaconducaoUpsertWithWhereUniqueWithoutFicheiroInput = {
    where: cartaconducaoWhereUniqueInput
    update: XOR<cartaconducaoUpdateWithoutFicheiroInput, cartaconducaoUncheckedUpdateWithoutFicheiroInput>
    create: XOR<cartaconducaoCreateWithoutFicheiroInput, cartaconducaoUncheckedCreateWithoutFicheiroInput>
  }

  export type cartaconducaoUpdateWithWhereUniqueWithoutFicheiroInput = {
    where: cartaconducaoWhereUniqueInput
    data: XOR<cartaconducaoUpdateWithoutFicheiroInput, cartaconducaoUncheckedUpdateWithoutFicheiroInput>
  }

  export type cartaconducaoUpdateManyWithWhereWithoutFicheiroInput = {
    where: cartaconducaoScalarWhereInput
    data: XOR<cartaconducaoUpdateManyMutationInput, cartaconducaoUncheckedUpdateManyWithoutFicheiroInput>
  }

  export type funcionarioUpsertWithWhereUniqueWithoutFicheiroInput = {
    where: funcionarioWhereUniqueInput
    update: XOR<funcionarioUpdateWithoutFicheiroInput, funcionarioUncheckedUpdateWithoutFicheiroInput>
    create: XOR<funcionarioCreateWithoutFicheiroInput, funcionarioUncheckedCreateWithoutFicheiroInput>
  }

  export type funcionarioUpdateWithWhereUniqueWithoutFicheiroInput = {
    where: funcionarioWhereUniqueInput
    data: XOR<funcionarioUpdateWithoutFicheiroInput, funcionarioUncheckedUpdateWithoutFicheiroInput>
  }

  export type funcionarioUpdateManyWithWhereWithoutFicheiroInput = {
    where: funcionarioScalarWhereInput
    data: XOR<funcionarioUpdateManyMutationInput, funcionarioUncheckedUpdateManyWithoutFicheiroInput>
  }

  export type funcionarioScalarWhereInput = {
    AND?: funcionarioScalarWhereInput | funcionarioScalarWhereInput[]
    OR?: funcionarioScalarWhereInput[]
    NOT?: funcionarioScalarWhereInput | funcionarioScalarWhereInput[]
    codFuncionario?: IntFilter<"funcionario"> | number
    codPessoa?: IntFilter<"funcionario"> | number
    codficheiroFotoPerfil?: IntFilter<"funcionario"> | number
    codficheiroFotoPendente?: IntNullableFilter<"funcionario"> | number | null
    numeroAgente?: StringNullableFilter<"funcionario"> | string | null
    senha?: IntFilter<"funcionario"> | number
  }

  export type pagamentomultaUpsertWithWhereUniqueWithoutFicheiroInput = {
    where: pagamentomultaWhereUniqueInput
    update: XOR<pagamentomultaUpdateWithoutFicheiroInput, pagamentomultaUncheckedUpdateWithoutFicheiroInput>
    create: XOR<pagamentomultaCreateWithoutFicheiroInput, pagamentomultaUncheckedCreateWithoutFicheiroInput>
  }

  export type pagamentomultaUpdateWithWhereUniqueWithoutFicheiroInput = {
    where: pagamentomultaWhereUniqueInput
    data: XOR<pagamentomultaUpdateWithoutFicheiroInput, pagamentomultaUncheckedUpdateWithoutFicheiroInput>
  }

  export type pagamentomultaUpdateManyWithWhereWithoutFicheiroInput = {
    where: pagamentomultaScalarWhereInput
    data: XOR<pagamentomultaUpdateManyMutationInput, pagamentomultaUncheckedUpdateManyWithoutFicheiroInput>
  }

  export type pagamentomultaScalarWhereInput = {
    AND?: pagamentomultaScalarWhereInput | pagamentomultaScalarWhereInput[]
    OR?: pagamentomultaScalarWhereInput[]
    NOT?: pagamentomultaScalarWhereInput | pagamentomultaScalarWhereInput[]
    codPagamentoMulta?: IntFilter<"pagamentomulta"> | number
    codMulta?: IntFilter<"pagamentomulta"> | number
    dataPagamento?: DateTimeFilter<"pagamentomulta"> | Date | string
    valorPago?: StringFilter<"pagamentomulta"> | string
    descCodigoDeposito?: StringFilter<"pagamentomulta"> | string
    codFicheiroPagamento?: IntFilter<"pagamentomulta"> | number
  }

  export type titulopropriedadeUpsertWithWhereUniqueWithoutFicheiroInput = {
    where: titulopropriedadeWhereUniqueInput
    update: XOR<titulopropriedadeUpdateWithoutFicheiroInput, titulopropriedadeUncheckedUpdateWithoutFicheiroInput>
    create: XOR<titulopropriedadeCreateWithoutFicheiroInput, titulopropriedadeUncheckedCreateWithoutFicheiroInput>
  }

  export type titulopropriedadeUpdateWithWhereUniqueWithoutFicheiroInput = {
    where: titulopropriedadeWhereUniqueInput
    data: XOR<titulopropriedadeUpdateWithoutFicheiroInput, titulopropriedadeUncheckedUpdateWithoutFicheiroInput>
  }

  export type titulopropriedadeUpdateManyWithWhereWithoutFicheiroInput = {
    where: titulopropriedadeScalarWhereInput
    data: XOR<titulopropriedadeUpdateManyMutationInput, titulopropriedadeUncheckedUpdateManyWithoutFicheiroInput>
  }

  export type titulopropriedadeScalarWhereInput = {
    AND?: titulopropriedadeScalarWhereInput | titulopropriedadeScalarWhereInput[]
    OR?: titulopropriedadeScalarWhereInput[]
    NOT?: titulopropriedadeScalarWhereInput | titulopropriedadeScalarWhereInput[]
    codTituloPropriedade?: IntFilter<"titulopropriedade"> | number
    codPessoa?: IntFilter<"titulopropriedade"> | number
    dataEmissao?: DateTimeFilter<"titulopropriedade"> | Date | string
    dataPrimeiroRegistro?: DateTimeFilter<"titulopropriedade"> | Date | string
    numeroEmissao?: StringFilter<"titulopropriedade"> | string
    codViatura?: IntFilter<"titulopropriedade"> | number
    codFicheiroTituloPropriedade?: IntFilter<"titulopropriedade"> | number
  }

  export type ficheiroCreateWithoutFuncionarioInput = {
    nomeFicheiro: string
    dataEntrada?: string | null
    dataValidacao?: string | null
    estadoValidacao?: $Enums.ficheiro_estadoValidacao | null
    bi?: biCreateNestedManyWithoutFicheiroInput
    cartaconducao?: cartaconducaoCreateNestedManyWithoutFicheiroInput
    pagamentomulta?: pagamentomultaCreateNestedManyWithoutFicheiroInput
    titulopropriedade?: titulopropriedadeCreateNestedManyWithoutFicheiroInput
  }

  export type ficheiroUncheckedCreateWithoutFuncionarioInput = {
    idFicheiro?: number
    nomeFicheiro: string
    dataEntrada?: string | null
    dataValidacao?: string | null
    estadoValidacao?: $Enums.ficheiro_estadoValidacao | null
    bi?: biUncheckedCreateNestedManyWithoutFicheiroInput
    cartaconducao?: cartaconducaoUncheckedCreateNestedManyWithoutFicheiroInput
    pagamentomulta?: pagamentomultaUncheckedCreateNestedManyWithoutFicheiroInput
    titulopropriedade?: titulopropriedadeUncheckedCreateNestedManyWithoutFicheiroInput
  }

  export type ficheiroCreateOrConnectWithoutFuncionarioInput = {
    where: ficheiroWhereUniqueInput
    create: XOR<ficheiroCreateWithoutFuncionarioInput, ficheiroUncheckedCreateWithoutFuncionarioInput>
  }

  export type pessoaCreateWithoutFuncionarioInput = {
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    senha: string
    automobilista?: automobilistaCreateNestedManyWithoutPessoaInput
    contacto?: contactoCreateNestedOneWithoutPessoaInput
    endereco?: enderecoCreateNestedOneWithoutPessoaInput
    pais?: paisCreateNestedOneWithoutPessoaInput
    bi: biCreateNestedOneWithoutPessoaInput
    titulopropriedade?: titulopropriedadeCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutFuncionarioInput = {
    codPessoa?: number
    codEndereco?: number | null
    codNacionalidade?: number | null
    codContacto?: number | null
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    codBi: number
    senha: string
    automobilista?: automobilistaUncheckedCreateNestedManyWithoutPessoaInput
    titulopropriedade?: titulopropriedadeUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutFuncionarioInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutFuncionarioInput, pessoaUncheckedCreateWithoutFuncionarioInput>
  }

  export type ficheiroUpsertWithoutFuncionarioInput = {
    update: XOR<ficheiroUpdateWithoutFuncionarioInput, ficheiroUncheckedUpdateWithoutFuncionarioInput>
    create: XOR<ficheiroCreateWithoutFuncionarioInput, ficheiroUncheckedCreateWithoutFuncionarioInput>
    where?: ficheiroWhereInput
  }

  export type ficheiroUpdateToOneWithWhereWithoutFuncionarioInput = {
    where?: ficheiroWhereInput
    data: XOR<ficheiroUpdateWithoutFuncionarioInput, ficheiroUncheckedUpdateWithoutFuncionarioInput>
  }

  export type ficheiroUpdateWithoutFuncionarioInput = {
    nomeFicheiro?: StringFieldUpdateOperationsInput | string
    dataEntrada?: NullableStringFieldUpdateOperationsInput | string | null
    dataValidacao?: NullableStringFieldUpdateOperationsInput | string | null
    estadoValidacao?: NullableEnumficheiro_estadoValidacaoFieldUpdateOperationsInput | $Enums.ficheiro_estadoValidacao | null
    bi?: biUpdateManyWithoutFicheiroNestedInput
    cartaconducao?: cartaconducaoUpdateManyWithoutFicheiroNestedInput
    pagamentomulta?: pagamentomultaUpdateManyWithoutFicheiroNestedInput
    titulopropriedade?: titulopropriedadeUpdateManyWithoutFicheiroNestedInput
  }

  export type ficheiroUncheckedUpdateWithoutFuncionarioInput = {
    idFicheiro?: IntFieldUpdateOperationsInput | number
    nomeFicheiro?: StringFieldUpdateOperationsInput | string
    dataEntrada?: NullableStringFieldUpdateOperationsInput | string | null
    dataValidacao?: NullableStringFieldUpdateOperationsInput | string | null
    estadoValidacao?: NullableEnumficheiro_estadoValidacaoFieldUpdateOperationsInput | $Enums.ficheiro_estadoValidacao | null
    bi?: biUncheckedUpdateManyWithoutFicheiroNestedInput
    cartaconducao?: cartaconducaoUncheckedUpdateManyWithoutFicheiroNestedInput
    pagamentomulta?: pagamentomultaUncheckedUpdateManyWithoutFicheiroNestedInput
    titulopropriedade?: titulopropriedadeUncheckedUpdateManyWithoutFicheiroNestedInput
  }

  export type pessoaUpsertWithoutFuncionarioInput = {
    update: XOR<pessoaUpdateWithoutFuncionarioInput, pessoaUncheckedUpdateWithoutFuncionarioInput>
    create: XOR<pessoaCreateWithoutFuncionarioInput, pessoaUncheckedCreateWithoutFuncionarioInput>
    where?: pessoaWhereInput
  }

  export type pessoaUpdateToOneWithWhereWithoutFuncionarioInput = {
    where?: pessoaWhereInput
    data: XOR<pessoaUpdateWithoutFuncionarioInput, pessoaUncheckedUpdateWithoutFuncionarioInput>
  }

  export type pessoaUpdateWithoutFuncionarioInput = {
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    automobilista?: automobilistaUpdateManyWithoutPessoaNestedInput
    contacto?: contactoUpdateOneWithoutPessoaNestedInput
    endereco?: enderecoUpdateOneWithoutPessoaNestedInput
    pais?: paisUpdateOneWithoutPessoaNestedInput
    bi?: biUpdateOneRequiredWithoutPessoaNestedInput
    titulopropriedade?: titulopropriedadeUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutFuncionarioInput = {
    codPessoa?: IntFieldUpdateOperationsInput | number
    codEndereco?: NullableIntFieldUpdateOperationsInput | number | null
    codNacionalidade?: NullableIntFieldUpdateOperationsInput | number | null
    codContacto?: NullableIntFieldUpdateOperationsInput | number | null
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    codBi?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    automobilista?: automobilistaUncheckedUpdateManyWithoutPessoaNestedInput
    titulopropriedade?: titulopropriedadeUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type multaCreateWithoutInfracao_infracao_codMultaTomultaInput = {
    valorMulta: string
    estadoMulta: $Enums.multa_estadoMulta
    automobilista?: automobilistaCreateNestedOneWithoutMultaInput
    infracao_multa_codInfracaoToinfracao: infracaoCreateNestedOneWithoutMulta_multa_codInfracaoToinfracaoInput
    viatura?: viaturaCreateNestedOneWithoutMultaInput
    pagamentomulta?: pagamentomultaCreateNestedManyWithoutMultaInput
  }

  export type multaUncheckedCreateWithoutInfracao_infracao_codMultaTomultaInput = {
    codMulta?: number
    codAutomobilista?: number | null
    CodViatura?: number | null
    codInfracao: number
    valorMulta: string
    estadoMulta: $Enums.multa_estadoMulta
    pagamentomulta?: pagamentomultaUncheckedCreateNestedManyWithoutMultaInput
  }

  export type multaCreateOrConnectWithoutInfracao_infracao_codMultaTomultaInput = {
    where: multaWhereUniqueInput
    create: XOR<multaCreateWithoutInfracao_infracao_codMultaTomultaInput, multaUncheckedCreateWithoutInfracao_infracao_codMultaTomultaInput>
  }

  export type tipoinfracaoCreateWithoutInfracaoInput = {
    descTipoInfracao: string
    valorInfracao: string
  }

  export type tipoinfracaoUncheckedCreateWithoutInfracaoInput = {
    codTipoInfracao?: number
    descTipoInfracao: string
    valorInfracao: string
  }

  export type tipoinfracaoCreateOrConnectWithoutInfracaoInput = {
    where: tipoinfracaoWhereUniqueInput
    create: XOR<tipoinfracaoCreateWithoutInfracaoInput, tipoinfracaoUncheckedCreateWithoutInfracaoInput>
  }

  export type multaCreateWithoutInfracao_multa_codInfracaoToinfracaoInput = {
    valorMulta: string
    estadoMulta: $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoCreateNestedManyWithoutMulta_infracao_codMultaTomultaInput
    automobilista?: automobilistaCreateNestedOneWithoutMultaInput
    viatura?: viaturaCreateNestedOneWithoutMultaInput
    pagamentomulta?: pagamentomultaCreateNestedManyWithoutMultaInput
  }

  export type multaUncheckedCreateWithoutInfracao_multa_codInfracaoToinfracaoInput = {
    codMulta?: number
    codAutomobilista?: number | null
    CodViatura?: number | null
    valorMulta: string
    estadoMulta: $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoUncheckedCreateNestedManyWithoutMulta_infracao_codMultaTomultaInput
    pagamentomulta?: pagamentomultaUncheckedCreateNestedManyWithoutMultaInput
  }

  export type multaCreateOrConnectWithoutInfracao_multa_codInfracaoToinfracaoInput = {
    where: multaWhereUniqueInput
    create: XOR<multaCreateWithoutInfracao_multa_codInfracaoToinfracaoInput, multaUncheckedCreateWithoutInfracao_multa_codInfracaoToinfracaoInput>
  }

  export type multaCreateManyInfracao_multa_codInfracaoToinfracaoInputEnvelope = {
    data: multaCreateManyInfracao_multa_codInfracaoToinfracaoInput | multaCreateManyInfracao_multa_codInfracaoToinfracaoInput[]
    skipDuplicates?: boolean
  }

  export type multaUpsertWithoutInfracao_infracao_codMultaTomultaInput = {
    update: XOR<multaUpdateWithoutInfracao_infracao_codMultaTomultaInput, multaUncheckedUpdateWithoutInfracao_infracao_codMultaTomultaInput>
    create: XOR<multaCreateWithoutInfracao_infracao_codMultaTomultaInput, multaUncheckedCreateWithoutInfracao_infracao_codMultaTomultaInput>
    where?: multaWhereInput
  }

  export type multaUpdateToOneWithWhereWithoutInfracao_infracao_codMultaTomultaInput = {
    where?: multaWhereInput
    data: XOR<multaUpdateWithoutInfracao_infracao_codMultaTomultaInput, multaUncheckedUpdateWithoutInfracao_infracao_codMultaTomultaInput>
  }

  export type multaUpdateWithoutInfracao_infracao_codMultaTomultaInput = {
    valorMulta?: StringFieldUpdateOperationsInput | string
    estadoMulta?: Enummulta_estadoMultaFieldUpdateOperationsInput | $Enums.multa_estadoMulta
    automobilista?: automobilistaUpdateOneWithoutMultaNestedInput
    infracao_multa_codInfracaoToinfracao?: infracaoUpdateOneRequiredWithoutMulta_multa_codInfracaoToinfracaoNestedInput
    viatura?: viaturaUpdateOneWithoutMultaNestedInput
    pagamentomulta?: pagamentomultaUpdateManyWithoutMultaNestedInput
  }

  export type multaUncheckedUpdateWithoutInfracao_infracao_codMultaTomultaInput = {
    codMulta?: IntFieldUpdateOperationsInput | number
    codAutomobilista?: NullableIntFieldUpdateOperationsInput | number | null
    CodViatura?: NullableIntFieldUpdateOperationsInput | number | null
    codInfracao?: IntFieldUpdateOperationsInput | number
    valorMulta?: StringFieldUpdateOperationsInput | string
    estadoMulta?: Enummulta_estadoMultaFieldUpdateOperationsInput | $Enums.multa_estadoMulta
    pagamentomulta?: pagamentomultaUncheckedUpdateManyWithoutMultaNestedInput
  }

  export type tipoinfracaoUpsertWithoutInfracaoInput = {
    update: XOR<tipoinfracaoUpdateWithoutInfracaoInput, tipoinfracaoUncheckedUpdateWithoutInfracaoInput>
    create: XOR<tipoinfracaoCreateWithoutInfracaoInput, tipoinfracaoUncheckedCreateWithoutInfracaoInput>
    where?: tipoinfracaoWhereInput
  }

  export type tipoinfracaoUpdateToOneWithWhereWithoutInfracaoInput = {
    where?: tipoinfracaoWhereInput
    data: XOR<tipoinfracaoUpdateWithoutInfracaoInput, tipoinfracaoUncheckedUpdateWithoutInfracaoInput>
  }

  export type tipoinfracaoUpdateWithoutInfracaoInput = {
    descTipoInfracao?: StringFieldUpdateOperationsInput | string
    valorInfracao?: StringFieldUpdateOperationsInput | string
  }

  export type tipoinfracaoUncheckedUpdateWithoutInfracaoInput = {
    codTipoInfracao?: IntFieldUpdateOperationsInput | number
    descTipoInfracao?: StringFieldUpdateOperationsInput | string
    valorInfracao?: StringFieldUpdateOperationsInput | string
  }

  export type multaUpsertWithWhereUniqueWithoutInfracao_multa_codInfracaoToinfracaoInput = {
    where: multaWhereUniqueInput
    update: XOR<multaUpdateWithoutInfracao_multa_codInfracaoToinfracaoInput, multaUncheckedUpdateWithoutInfracao_multa_codInfracaoToinfracaoInput>
    create: XOR<multaCreateWithoutInfracao_multa_codInfracaoToinfracaoInput, multaUncheckedCreateWithoutInfracao_multa_codInfracaoToinfracaoInput>
  }

  export type multaUpdateWithWhereUniqueWithoutInfracao_multa_codInfracaoToinfracaoInput = {
    where: multaWhereUniqueInput
    data: XOR<multaUpdateWithoutInfracao_multa_codInfracaoToinfracaoInput, multaUncheckedUpdateWithoutInfracao_multa_codInfracaoToinfracaoInput>
  }

  export type multaUpdateManyWithWhereWithoutInfracao_multa_codInfracaoToinfracaoInput = {
    where: multaScalarWhereInput
    data: XOR<multaUpdateManyMutationInput, multaUncheckedUpdateManyWithoutInfracao_multa_codInfracaoToinfracaoInput>
  }

  export type marcaCreateWithoutLivreteInput = {
    descMarca: string
  }

  export type marcaUncheckedCreateWithoutLivreteInput = {
    codMarca?: number
    descMarca: string
  }

  export type marcaCreateOrConnectWithoutLivreteInput = {
    where: marcaWhereUniqueInput
    create: XOR<marcaCreateWithoutLivreteInput, marcaUncheckedCreateWithoutLivreteInput>
  }

  export type viaturaCreateWithoutLivreteInput = {
    numeroMatricula: string
    alertaroubo?: alertarouboCreateNestedManyWithoutViaturaInput
    multa?: multaCreateNestedManyWithoutViaturaInput
    titulopropriedade?: titulopropriedadeCreateNestedManyWithoutViaturaInput
  }

  export type viaturaUncheckedCreateWithoutLivreteInput = {
    codViatura?: number
    numeroMatricula: string
    alertaroubo?: alertarouboUncheckedCreateNestedManyWithoutViaturaInput
    multa?: multaUncheckedCreateNestedManyWithoutViaturaInput
    titulopropriedade?: titulopropriedadeUncheckedCreateNestedManyWithoutViaturaInput
  }

  export type viaturaCreateOrConnectWithoutLivreteInput = {
    where: viaturaWhereUniqueInput
    create: XOR<viaturaCreateWithoutLivreteInput, viaturaUncheckedCreateWithoutLivreteInput>
  }

  export type serivicoviaturaCreateWithoutLivreteInput = {
    descServico: string
  }

  export type serivicoviaturaUncheckedCreateWithoutLivreteInput = {
    codServicoViatura?: number
    descServico: string
  }

  export type serivicoviaturaCreateOrConnectWithoutLivreteInput = {
    where: serivicoviaturaWhereUniqueInput
    create: XOR<serivicoviaturaCreateWithoutLivreteInput, serivicoviaturaUncheckedCreateWithoutLivreteInput>
  }

  export type marcaUpsertWithoutLivreteInput = {
    update: XOR<marcaUpdateWithoutLivreteInput, marcaUncheckedUpdateWithoutLivreteInput>
    create: XOR<marcaCreateWithoutLivreteInput, marcaUncheckedCreateWithoutLivreteInput>
    where?: marcaWhereInput
  }

  export type marcaUpdateToOneWithWhereWithoutLivreteInput = {
    where?: marcaWhereInput
    data: XOR<marcaUpdateWithoutLivreteInput, marcaUncheckedUpdateWithoutLivreteInput>
  }

  export type marcaUpdateWithoutLivreteInput = {
    descMarca?: StringFieldUpdateOperationsInput | string
  }

  export type marcaUncheckedUpdateWithoutLivreteInput = {
    codMarca?: IntFieldUpdateOperationsInput | number
    descMarca?: StringFieldUpdateOperationsInput | string
  }

  export type viaturaUpsertWithoutLivreteInput = {
    update: XOR<viaturaUpdateWithoutLivreteInput, viaturaUncheckedUpdateWithoutLivreteInput>
    create: XOR<viaturaCreateWithoutLivreteInput, viaturaUncheckedCreateWithoutLivreteInput>
    where?: viaturaWhereInput
  }

  export type viaturaUpdateToOneWithWhereWithoutLivreteInput = {
    where?: viaturaWhereInput
    data: XOR<viaturaUpdateWithoutLivreteInput, viaturaUncheckedUpdateWithoutLivreteInput>
  }

  export type viaturaUpdateWithoutLivreteInput = {
    numeroMatricula?: StringFieldUpdateOperationsInput | string
    alertaroubo?: alertarouboUpdateManyWithoutViaturaNestedInput
    multa?: multaUpdateManyWithoutViaturaNestedInput
    titulopropriedade?: titulopropriedadeUpdateManyWithoutViaturaNestedInput
  }

  export type viaturaUncheckedUpdateWithoutLivreteInput = {
    codViatura?: IntFieldUpdateOperationsInput | number
    numeroMatricula?: StringFieldUpdateOperationsInput | string
    alertaroubo?: alertarouboUncheckedUpdateManyWithoutViaturaNestedInput
    multa?: multaUncheckedUpdateManyWithoutViaturaNestedInput
    titulopropriedade?: titulopropriedadeUncheckedUpdateManyWithoutViaturaNestedInput
  }

  export type serivicoviaturaUpsertWithoutLivreteInput = {
    update: XOR<serivicoviaturaUpdateWithoutLivreteInput, serivicoviaturaUncheckedUpdateWithoutLivreteInput>
    create: XOR<serivicoviaturaCreateWithoutLivreteInput, serivicoviaturaUncheckedCreateWithoutLivreteInput>
    where?: serivicoviaturaWhereInput
  }

  export type serivicoviaturaUpdateToOneWithWhereWithoutLivreteInput = {
    where?: serivicoviaturaWhereInput
    data: XOR<serivicoviaturaUpdateWithoutLivreteInput, serivicoviaturaUncheckedUpdateWithoutLivreteInput>
  }

  export type serivicoviaturaUpdateWithoutLivreteInput = {
    descServico?: StringFieldUpdateOperationsInput | string
  }

  export type serivicoviaturaUncheckedUpdateWithoutLivreteInput = {
    codServicoViatura?: IntFieldUpdateOperationsInput | number
    descServico?: StringFieldUpdateOperationsInput | string
  }

  export type livreteCreateWithoutMarcaInput = {
    numeroQuadro: string
    corViatura: string
    MedidasPneumaticos: string
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    lotacao: string
    cilindrada: string
    numeroCilindro: string
    conbustivel: string
    peso: string
    tara: string
    tipoCaixa: string
    distanciaEixo: string
    modelo: string
    viatura: viaturaCreateNestedOneWithoutLivreteInput
    serivicoviatura: serivicoviaturaCreateNestedOneWithoutLivreteInput
  }

  export type livreteUncheckedCreateWithoutMarcaInput = {
    codLivrete?: number
    codViatura: number
    numeroQuadro: string
    corViatura: string
    MedidasPneumaticos: string
    codServico: number
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    lotacao: string
    cilindrada: string
    numeroCilindro: string
    conbustivel: string
    peso: string
    tara: string
    tipoCaixa: string
    distanciaEixo: string
    modelo: string
  }

  export type livreteCreateOrConnectWithoutMarcaInput = {
    where: livreteWhereUniqueInput
    create: XOR<livreteCreateWithoutMarcaInput, livreteUncheckedCreateWithoutMarcaInput>
  }

  export type livreteCreateManyMarcaInputEnvelope = {
    data: livreteCreateManyMarcaInput | livreteCreateManyMarcaInput[]
    skipDuplicates?: boolean
  }

  export type livreteUpsertWithWhereUniqueWithoutMarcaInput = {
    where: livreteWhereUniqueInput
    update: XOR<livreteUpdateWithoutMarcaInput, livreteUncheckedUpdateWithoutMarcaInput>
    create: XOR<livreteCreateWithoutMarcaInput, livreteUncheckedCreateWithoutMarcaInput>
  }

  export type livreteUpdateWithWhereUniqueWithoutMarcaInput = {
    where: livreteWhereUniqueInput
    data: XOR<livreteUpdateWithoutMarcaInput, livreteUncheckedUpdateWithoutMarcaInput>
  }

  export type livreteUpdateManyWithWhereWithoutMarcaInput = {
    where: livreteScalarWhereInput
    data: XOR<livreteUpdateManyMutationInput, livreteUncheckedUpdateManyWithoutMarcaInput>
  }

  export type livreteScalarWhereInput = {
    AND?: livreteScalarWhereInput | livreteScalarWhereInput[]
    OR?: livreteScalarWhereInput[]
    NOT?: livreteScalarWhereInput | livreteScalarWhereInput[]
    codLivrete?: IntFilter<"livrete"> | number
    codViatura?: IntFilter<"livrete"> | number
    numeroQuadro?: StringFilter<"livrete"> | string
    corViatura?: StringFilter<"livrete"> | string
    MedidasPneumaticos?: StringFilter<"livrete"> | string
    codServico?: IntFilter<"livrete"> | number
    dataEmissao?: DateTimeFilter<"livrete"> | Date | string
    dataPrimeiroRegistro?: DateTimeFilter<"livrete"> | Date | string
    lotacao?: StringFilter<"livrete"> | string
    cilindrada?: StringFilter<"livrete"> | string
    numeroCilindro?: StringFilter<"livrete"> | string
    conbustivel?: StringFilter<"livrete"> | string
    peso?: StringFilter<"livrete"> | string
    tara?: StringFilter<"livrete"> | string
    tipoCaixa?: StringFilter<"livrete"> | string
    distanciaEixo?: StringFilter<"livrete"> | string
    modelo?: StringFilter<"livrete"> | string
    codMarca?: IntFilter<"livrete"> | number
  }

  export type infracaoCreateWithoutMulta_infracao_codMultaTomultaInput = {
    tipoinfracao: tipoinfracaoCreateNestedOneWithoutInfracaoInput
    multa_multa_codInfracaoToinfracao?: multaCreateNestedManyWithoutInfracao_multa_codInfracaoToinfracaoInput
  }

  export type infracaoUncheckedCreateWithoutMulta_infracao_codMultaTomultaInput = {
    codInfracao?: number
    codTipoInfracao: number
    multa_multa_codInfracaoToinfracao?: multaUncheckedCreateNestedManyWithoutInfracao_multa_codInfracaoToinfracaoInput
  }

  export type infracaoCreateOrConnectWithoutMulta_infracao_codMultaTomultaInput = {
    where: infracaoWhereUniqueInput
    create: XOR<infracaoCreateWithoutMulta_infracao_codMultaTomultaInput, infracaoUncheckedCreateWithoutMulta_infracao_codMultaTomultaInput>
  }

  export type infracaoCreateManyMulta_infracao_codMultaTomultaInputEnvelope = {
    data: infracaoCreateManyMulta_infracao_codMultaTomultaInput | infracaoCreateManyMulta_infracao_codMultaTomultaInput[]
    skipDuplicates?: boolean
  }

  export type automobilistaCreateWithoutMultaInput = {
    alertaroubo?: alertarouboCreateNestedManyWithoutAutomobilistaInput
    cartaconducao: cartaconducaoCreateNestedOneWithoutAutomobilistaInput
    pessoa: pessoaCreateNestedOneWithoutAutomobilistaInput
  }

  export type automobilistaUncheckedCreateWithoutMultaInput = {
    codAutomobilista?: number
    codCartaConducao: number
    codPessoa: number
    alertaroubo?: alertarouboUncheckedCreateNestedManyWithoutAutomobilistaInput
  }

  export type automobilistaCreateOrConnectWithoutMultaInput = {
    where: automobilistaWhereUniqueInput
    create: XOR<automobilistaCreateWithoutMultaInput, automobilistaUncheckedCreateWithoutMultaInput>
  }

  export type infracaoCreateWithoutMulta_multa_codInfracaoToinfracaoInput = {
    multa_infracao_codMultaTomulta: multaCreateNestedOneWithoutInfracao_infracao_codMultaTomultaInput
    tipoinfracao: tipoinfracaoCreateNestedOneWithoutInfracaoInput
  }

  export type infracaoUncheckedCreateWithoutMulta_multa_codInfracaoToinfracaoInput = {
    codInfracao?: number
    codMulta: number
    codTipoInfracao: number
  }

  export type infracaoCreateOrConnectWithoutMulta_multa_codInfracaoToinfracaoInput = {
    where: infracaoWhereUniqueInput
    create: XOR<infracaoCreateWithoutMulta_multa_codInfracaoToinfracaoInput, infracaoUncheckedCreateWithoutMulta_multa_codInfracaoToinfracaoInput>
  }

  export type viaturaCreateWithoutMultaInput = {
    numeroMatricula: string
    alertaroubo?: alertarouboCreateNestedManyWithoutViaturaInput
    livrete?: livreteCreateNestedManyWithoutViaturaInput
    titulopropriedade?: titulopropriedadeCreateNestedManyWithoutViaturaInput
  }

  export type viaturaUncheckedCreateWithoutMultaInput = {
    codViatura?: number
    numeroMatricula: string
    alertaroubo?: alertarouboUncheckedCreateNestedManyWithoutViaturaInput
    livrete?: livreteUncheckedCreateNestedManyWithoutViaturaInput
    titulopropriedade?: titulopropriedadeUncheckedCreateNestedManyWithoutViaturaInput
  }

  export type viaturaCreateOrConnectWithoutMultaInput = {
    where: viaturaWhereUniqueInput
    create: XOR<viaturaCreateWithoutMultaInput, viaturaUncheckedCreateWithoutMultaInput>
  }

  export type pagamentomultaCreateWithoutMultaInput = {
    dataPagamento: Date | string
    valorPago: string
    descCodigoDeposito: string
    ficheiro: ficheiroCreateNestedOneWithoutPagamentomultaInput
  }

  export type pagamentomultaUncheckedCreateWithoutMultaInput = {
    codPagamentoMulta?: number
    dataPagamento: Date | string
    valorPago: string
    descCodigoDeposito: string
    codFicheiroPagamento: number
  }

  export type pagamentomultaCreateOrConnectWithoutMultaInput = {
    where: pagamentomultaWhereUniqueInput
    create: XOR<pagamentomultaCreateWithoutMultaInput, pagamentomultaUncheckedCreateWithoutMultaInput>
  }

  export type pagamentomultaCreateManyMultaInputEnvelope = {
    data: pagamentomultaCreateManyMultaInput | pagamentomultaCreateManyMultaInput[]
    skipDuplicates?: boolean
  }

  export type infracaoUpsertWithWhereUniqueWithoutMulta_infracao_codMultaTomultaInput = {
    where: infracaoWhereUniqueInput
    update: XOR<infracaoUpdateWithoutMulta_infracao_codMultaTomultaInput, infracaoUncheckedUpdateWithoutMulta_infracao_codMultaTomultaInput>
    create: XOR<infracaoCreateWithoutMulta_infracao_codMultaTomultaInput, infracaoUncheckedCreateWithoutMulta_infracao_codMultaTomultaInput>
  }

  export type infracaoUpdateWithWhereUniqueWithoutMulta_infracao_codMultaTomultaInput = {
    where: infracaoWhereUniqueInput
    data: XOR<infracaoUpdateWithoutMulta_infracao_codMultaTomultaInput, infracaoUncheckedUpdateWithoutMulta_infracao_codMultaTomultaInput>
  }

  export type infracaoUpdateManyWithWhereWithoutMulta_infracao_codMultaTomultaInput = {
    where: infracaoScalarWhereInput
    data: XOR<infracaoUpdateManyMutationInput, infracaoUncheckedUpdateManyWithoutMulta_infracao_codMultaTomultaInput>
  }

  export type infracaoScalarWhereInput = {
    AND?: infracaoScalarWhereInput | infracaoScalarWhereInput[]
    OR?: infracaoScalarWhereInput[]
    NOT?: infracaoScalarWhereInput | infracaoScalarWhereInput[]
    codInfracao?: IntFilter<"infracao"> | number
    codMulta?: IntFilter<"infracao"> | number
    codTipoInfracao?: IntFilter<"infracao"> | number
  }

  export type automobilistaUpsertWithoutMultaInput = {
    update: XOR<automobilistaUpdateWithoutMultaInput, automobilistaUncheckedUpdateWithoutMultaInput>
    create: XOR<automobilistaCreateWithoutMultaInput, automobilistaUncheckedCreateWithoutMultaInput>
    where?: automobilistaWhereInput
  }

  export type automobilistaUpdateToOneWithWhereWithoutMultaInput = {
    where?: automobilistaWhereInput
    data: XOR<automobilistaUpdateWithoutMultaInput, automobilistaUncheckedUpdateWithoutMultaInput>
  }

  export type automobilistaUpdateWithoutMultaInput = {
    alertaroubo?: alertarouboUpdateManyWithoutAutomobilistaNestedInput
    cartaconducao?: cartaconducaoUpdateOneRequiredWithoutAutomobilistaNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutAutomobilistaNestedInput
  }

  export type automobilistaUncheckedUpdateWithoutMultaInput = {
    codAutomobilista?: IntFieldUpdateOperationsInput | number
    codCartaConducao?: IntFieldUpdateOperationsInput | number
    codPessoa?: IntFieldUpdateOperationsInput | number
    alertaroubo?: alertarouboUncheckedUpdateManyWithoutAutomobilistaNestedInput
  }

  export type infracaoUpsertWithoutMulta_multa_codInfracaoToinfracaoInput = {
    update: XOR<infracaoUpdateWithoutMulta_multa_codInfracaoToinfracaoInput, infracaoUncheckedUpdateWithoutMulta_multa_codInfracaoToinfracaoInput>
    create: XOR<infracaoCreateWithoutMulta_multa_codInfracaoToinfracaoInput, infracaoUncheckedCreateWithoutMulta_multa_codInfracaoToinfracaoInput>
    where?: infracaoWhereInput
  }

  export type infracaoUpdateToOneWithWhereWithoutMulta_multa_codInfracaoToinfracaoInput = {
    where?: infracaoWhereInput
    data: XOR<infracaoUpdateWithoutMulta_multa_codInfracaoToinfracaoInput, infracaoUncheckedUpdateWithoutMulta_multa_codInfracaoToinfracaoInput>
  }

  export type infracaoUpdateWithoutMulta_multa_codInfracaoToinfracaoInput = {
    multa_infracao_codMultaTomulta?: multaUpdateOneRequiredWithoutInfracao_infracao_codMultaTomultaNestedInput
    tipoinfracao?: tipoinfracaoUpdateOneRequiredWithoutInfracaoNestedInput
  }

  export type infracaoUncheckedUpdateWithoutMulta_multa_codInfracaoToinfracaoInput = {
    codInfracao?: IntFieldUpdateOperationsInput | number
    codMulta?: IntFieldUpdateOperationsInput | number
    codTipoInfracao?: IntFieldUpdateOperationsInput | number
  }

  export type viaturaUpsertWithoutMultaInput = {
    update: XOR<viaturaUpdateWithoutMultaInput, viaturaUncheckedUpdateWithoutMultaInput>
    create: XOR<viaturaCreateWithoutMultaInput, viaturaUncheckedCreateWithoutMultaInput>
    where?: viaturaWhereInput
  }

  export type viaturaUpdateToOneWithWhereWithoutMultaInput = {
    where?: viaturaWhereInput
    data: XOR<viaturaUpdateWithoutMultaInput, viaturaUncheckedUpdateWithoutMultaInput>
  }

  export type viaturaUpdateWithoutMultaInput = {
    numeroMatricula?: StringFieldUpdateOperationsInput | string
    alertaroubo?: alertarouboUpdateManyWithoutViaturaNestedInput
    livrete?: livreteUpdateManyWithoutViaturaNestedInput
    titulopropriedade?: titulopropriedadeUpdateManyWithoutViaturaNestedInput
  }

  export type viaturaUncheckedUpdateWithoutMultaInput = {
    codViatura?: IntFieldUpdateOperationsInput | number
    numeroMatricula?: StringFieldUpdateOperationsInput | string
    alertaroubo?: alertarouboUncheckedUpdateManyWithoutViaturaNestedInput
    livrete?: livreteUncheckedUpdateManyWithoutViaturaNestedInput
    titulopropriedade?: titulopropriedadeUncheckedUpdateManyWithoutViaturaNestedInput
  }

  export type pagamentomultaUpsertWithWhereUniqueWithoutMultaInput = {
    where: pagamentomultaWhereUniqueInput
    update: XOR<pagamentomultaUpdateWithoutMultaInput, pagamentomultaUncheckedUpdateWithoutMultaInput>
    create: XOR<pagamentomultaCreateWithoutMultaInput, pagamentomultaUncheckedCreateWithoutMultaInput>
  }

  export type pagamentomultaUpdateWithWhereUniqueWithoutMultaInput = {
    where: pagamentomultaWhereUniqueInput
    data: XOR<pagamentomultaUpdateWithoutMultaInput, pagamentomultaUncheckedUpdateWithoutMultaInput>
  }

  export type pagamentomultaUpdateManyWithWhereWithoutMultaInput = {
    where: pagamentomultaScalarWhereInput
    data: XOR<pagamentomultaUpdateManyMutationInput, pagamentomultaUncheckedUpdateManyWithoutMultaInput>
  }

  export type enderecoCreateWithoutMunicipioInput = {
    descricaoEndereco: string
    pessoa?: pessoaCreateNestedManyWithoutEnderecoInput
  }

  export type enderecoUncheckedCreateWithoutMunicipioInput = {
    idEndereco?: number
    descricaoEndereco: string
    pessoa?: pessoaUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type enderecoCreateOrConnectWithoutMunicipioInput = {
    where: enderecoWhereUniqueInput
    create: XOR<enderecoCreateWithoutMunicipioInput, enderecoUncheckedCreateWithoutMunicipioInput>
  }

  export type enderecoCreateManyMunicipioInputEnvelope = {
    data: enderecoCreateManyMunicipioInput | enderecoCreateManyMunicipioInput[]
    skipDuplicates?: boolean
  }

  export type provinciaCreateWithoutMunicipioInput = {
    provincia: string
  }

  export type provinciaUncheckedCreateWithoutMunicipioInput = {
    idProvincia?: number
    provincia: string
  }

  export type provinciaCreateOrConnectWithoutMunicipioInput = {
    where: provinciaWhereUniqueInput
    create: XOR<provinciaCreateWithoutMunicipioInput, provinciaUncheckedCreateWithoutMunicipioInput>
  }

  export type enderecoUpsertWithWhereUniqueWithoutMunicipioInput = {
    where: enderecoWhereUniqueInput
    update: XOR<enderecoUpdateWithoutMunicipioInput, enderecoUncheckedUpdateWithoutMunicipioInput>
    create: XOR<enderecoCreateWithoutMunicipioInput, enderecoUncheckedCreateWithoutMunicipioInput>
  }

  export type enderecoUpdateWithWhereUniqueWithoutMunicipioInput = {
    where: enderecoWhereUniqueInput
    data: XOR<enderecoUpdateWithoutMunicipioInput, enderecoUncheckedUpdateWithoutMunicipioInput>
  }

  export type enderecoUpdateManyWithWhereWithoutMunicipioInput = {
    where: enderecoScalarWhereInput
    data: XOR<enderecoUpdateManyMutationInput, enderecoUncheckedUpdateManyWithoutMunicipioInput>
  }

  export type enderecoScalarWhereInput = {
    AND?: enderecoScalarWhereInput | enderecoScalarWhereInput[]
    OR?: enderecoScalarWhereInput[]
    NOT?: enderecoScalarWhereInput | enderecoScalarWhereInput[]
    idEndereco?: IntFilter<"endereco"> | number
    idMunicipio?: IntFilter<"endereco"> | number
    descricaoEndereco?: StringFilter<"endereco"> | string
  }

  export type provinciaUpsertWithoutMunicipioInput = {
    update: XOR<provinciaUpdateWithoutMunicipioInput, provinciaUncheckedUpdateWithoutMunicipioInput>
    create: XOR<provinciaCreateWithoutMunicipioInput, provinciaUncheckedCreateWithoutMunicipioInput>
    where?: provinciaWhereInput
  }

  export type provinciaUpdateToOneWithWhereWithoutMunicipioInput = {
    where?: provinciaWhereInput
    data: XOR<provinciaUpdateWithoutMunicipioInput, provinciaUncheckedUpdateWithoutMunicipioInput>
  }

  export type provinciaUpdateWithoutMunicipioInput = {
    provincia?: StringFieldUpdateOperationsInput | string
  }

  export type provinciaUncheckedUpdateWithoutMunicipioInput = {
    idProvincia?: IntFieldUpdateOperationsInput | number
    provincia?: StringFieldUpdateOperationsInput | string
  }

  export type multaCreateWithoutPagamentomultaInput = {
    valorMulta: string
    estadoMulta: $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoCreateNestedManyWithoutMulta_infracao_codMultaTomultaInput
    automobilista?: automobilistaCreateNestedOneWithoutMultaInput
    infracao_multa_codInfracaoToinfracao: infracaoCreateNestedOneWithoutMulta_multa_codInfracaoToinfracaoInput
    viatura?: viaturaCreateNestedOneWithoutMultaInput
  }

  export type multaUncheckedCreateWithoutPagamentomultaInput = {
    codMulta?: number
    codAutomobilista?: number | null
    CodViatura?: number | null
    codInfracao: number
    valorMulta: string
    estadoMulta: $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoUncheckedCreateNestedManyWithoutMulta_infracao_codMultaTomultaInput
  }

  export type multaCreateOrConnectWithoutPagamentomultaInput = {
    where: multaWhereUniqueInput
    create: XOR<multaCreateWithoutPagamentomultaInput, multaUncheckedCreateWithoutPagamentomultaInput>
  }

  export type ficheiroCreateWithoutPagamentomultaInput = {
    nomeFicheiro: string
    dataEntrada?: string | null
    dataValidacao?: string | null
    estadoValidacao?: $Enums.ficheiro_estadoValidacao | null
    bi?: biCreateNestedManyWithoutFicheiroInput
    cartaconducao?: cartaconducaoCreateNestedManyWithoutFicheiroInput
    funcionario?: funcionarioCreateNestedManyWithoutFicheiroInput
    titulopropriedade?: titulopropriedadeCreateNestedManyWithoutFicheiroInput
  }

  export type ficheiroUncheckedCreateWithoutPagamentomultaInput = {
    idFicheiro?: number
    nomeFicheiro: string
    dataEntrada?: string | null
    dataValidacao?: string | null
    estadoValidacao?: $Enums.ficheiro_estadoValidacao | null
    bi?: biUncheckedCreateNestedManyWithoutFicheiroInput
    cartaconducao?: cartaconducaoUncheckedCreateNestedManyWithoutFicheiroInput
    funcionario?: funcionarioUncheckedCreateNestedManyWithoutFicheiroInput
    titulopropriedade?: titulopropriedadeUncheckedCreateNestedManyWithoutFicheiroInput
  }

  export type ficheiroCreateOrConnectWithoutPagamentomultaInput = {
    where: ficheiroWhereUniqueInput
    create: XOR<ficheiroCreateWithoutPagamentomultaInput, ficheiroUncheckedCreateWithoutPagamentomultaInput>
  }

  export type multaUpsertWithoutPagamentomultaInput = {
    update: XOR<multaUpdateWithoutPagamentomultaInput, multaUncheckedUpdateWithoutPagamentomultaInput>
    create: XOR<multaCreateWithoutPagamentomultaInput, multaUncheckedCreateWithoutPagamentomultaInput>
    where?: multaWhereInput
  }

  export type multaUpdateToOneWithWhereWithoutPagamentomultaInput = {
    where?: multaWhereInput
    data: XOR<multaUpdateWithoutPagamentomultaInput, multaUncheckedUpdateWithoutPagamentomultaInput>
  }

  export type multaUpdateWithoutPagamentomultaInput = {
    valorMulta?: StringFieldUpdateOperationsInput | string
    estadoMulta?: Enummulta_estadoMultaFieldUpdateOperationsInput | $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoUpdateManyWithoutMulta_infracao_codMultaTomultaNestedInput
    automobilista?: automobilistaUpdateOneWithoutMultaNestedInput
    infracao_multa_codInfracaoToinfracao?: infracaoUpdateOneRequiredWithoutMulta_multa_codInfracaoToinfracaoNestedInput
    viatura?: viaturaUpdateOneWithoutMultaNestedInput
  }

  export type multaUncheckedUpdateWithoutPagamentomultaInput = {
    codMulta?: IntFieldUpdateOperationsInput | number
    codAutomobilista?: NullableIntFieldUpdateOperationsInput | number | null
    CodViatura?: NullableIntFieldUpdateOperationsInput | number | null
    codInfracao?: IntFieldUpdateOperationsInput | number
    valorMulta?: StringFieldUpdateOperationsInput | string
    estadoMulta?: Enummulta_estadoMultaFieldUpdateOperationsInput | $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoUncheckedUpdateManyWithoutMulta_infracao_codMultaTomultaNestedInput
  }

  export type ficheiroUpsertWithoutPagamentomultaInput = {
    update: XOR<ficheiroUpdateWithoutPagamentomultaInput, ficheiroUncheckedUpdateWithoutPagamentomultaInput>
    create: XOR<ficheiroCreateWithoutPagamentomultaInput, ficheiroUncheckedCreateWithoutPagamentomultaInput>
    where?: ficheiroWhereInput
  }

  export type ficheiroUpdateToOneWithWhereWithoutPagamentomultaInput = {
    where?: ficheiroWhereInput
    data: XOR<ficheiroUpdateWithoutPagamentomultaInput, ficheiroUncheckedUpdateWithoutPagamentomultaInput>
  }

  export type ficheiroUpdateWithoutPagamentomultaInput = {
    nomeFicheiro?: StringFieldUpdateOperationsInput | string
    dataEntrada?: NullableStringFieldUpdateOperationsInput | string | null
    dataValidacao?: NullableStringFieldUpdateOperationsInput | string | null
    estadoValidacao?: NullableEnumficheiro_estadoValidacaoFieldUpdateOperationsInput | $Enums.ficheiro_estadoValidacao | null
    bi?: biUpdateManyWithoutFicheiroNestedInput
    cartaconducao?: cartaconducaoUpdateManyWithoutFicheiroNestedInput
    funcionario?: funcionarioUpdateManyWithoutFicheiroNestedInput
    titulopropriedade?: titulopropriedadeUpdateManyWithoutFicheiroNestedInput
  }

  export type ficheiroUncheckedUpdateWithoutPagamentomultaInput = {
    idFicheiro?: IntFieldUpdateOperationsInput | number
    nomeFicheiro?: StringFieldUpdateOperationsInput | string
    dataEntrada?: NullableStringFieldUpdateOperationsInput | string | null
    dataValidacao?: NullableStringFieldUpdateOperationsInput | string | null
    estadoValidacao?: NullableEnumficheiro_estadoValidacaoFieldUpdateOperationsInput | $Enums.ficheiro_estadoValidacao | null
    bi?: biUncheckedUpdateManyWithoutFicheiroNestedInput
    cartaconducao?: cartaconducaoUncheckedUpdateManyWithoutFicheiroNestedInput
    funcionario?: funcionarioUncheckedUpdateManyWithoutFicheiroNestedInput
    titulopropriedade?: titulopropriedadeUncheckedUpdateManyWithoutFicheiroNestedInput
  }

  export type pessoaCreateWithoutPaisInput = {
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    senha: string
    automobilista?: automobilistaCreateNestedManyWithoutPessoaInput
    funcionario?: funcionarioCreateNestedManyWithoutPessoaInput
    contacto?: contactoCreateNestedOneWithoutPessoaInput
    endereco?: enderecoCreateNestedOneWithoutPessoaInput
    bi: biCreateNestedOneWithoutPessoaInput
    titulopropriedade?: titulopropriedadeCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutPaisInput = {
    codPessoa?: number
    codEndereco?: number | null
    codContacto?: number | null
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    codBi: number
    senha: string
    automobilista?: automobilistaUncheckedCreateNestedManyWithoutPessoaInput
    funcionario?: funcionarioUncheckedCreateNestedManyWithoutPessoaInput
    titulopropriedade?: titulopropriedadeUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutPaisInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutPaisInput, pessoaUncheckedCreateWithoutPaisInput>
  }

  export type pessoaCreateManyPaisInputEnvelope = {
    data: pessoaCreateManyPaisInput | pessoaCreateManyPaisInput[]
    skipDuplicates?: boolean
  }

  export type pessoaUpsertWithWhereUniqueWithoutPaisInput = {
    where: pessoaWhereUniqueInput
    update: XOR<pessoaUpdateWithoutPaisInput, pessoaUncheckedUpdateWithoutPaisInput>
    create: XOR<pessoaCreateWithoutPaisInput, pessoaUncheckedCreateWithoutPaisInput>
  }

  export type pessoaUpdateWithWhereUniqueWithoutPaisInput = {
    where: pessoaWhereUniqueInput
    data: XOR<pessoaUpdateWithoutPaisInput, pessoaUncheckedUpdateWithoutPaisInput>
  }

  export type pessoaUpdateManyWithWhereWithoutPaisInput = {
    where: pessoaScalarWhereInput
    data: XOR<pessoaUpdateManyMutationInput, pessoaUncheckedUpdateManyWithoutPaisInput>
  }

  export type automobilistaCreateWithoutPessoaInput = {
    alertaroubo?: alertarouboCreateNestedManyWithoutAutomobilistaInput
    cartaconducao: cartaconducaoCreateNestedOneWithoutAutomobilistaInput
    multa?: multaCreateNestedManyWithoutAutomobilistaInput
  }

  export type automobilistaUncheckedCreateWithoutPessoaInput = {
    codAutomobilista?: number
    codCartaConducao: number
    alertaroubo?: alertarouboUncheckedCreateNestedManyWithoutAutomobilistaInput
    multa?: multaUncheckedCreateNestedManyWithoutAutomobilistaInput
  }

  export type automobilistaCreateOrConnectWithoutPessoaInput = {
    where: automobilistaWhereUniqueInput
    create: XOR<automobilistaCreateWithoutPessoaInput, automobilistaUncheckedCreateWithoutPessoaInput>
  }

  export type automobilistaCreateManyPessoaInputEnvelope = {
    data: automobilistaCreateManyPessoaInput | automobilistaCreateManyPessoaInput[]
    skipDuplicates?: boolean
  }

  export type funcionarioCreateWithoutPessoaInput = {
    codficheiroFotoPendente?: number | null
    numeroAgente?: string | null
    senha?: number
    ficheiro: ficheiroCreateNestedOneWithoutFuncionarioInput
  }

  export type funcionarioUncheckedCreateWithoutPessoaInput = {
    codFuncionario?: number
    codficheiroFotoPerfil: number
    codficheiroFotoPendente?: number | null
    numeroAgente?: string | null
    senha?: number
  }

  export type funcionarioCreateOrConnectWithoutPessoaInput = {
    where: funcionarioWhereUniqueInput
    create: XOR<funcionarioCreateWithoutPessoaInput, funcionarioUncheckedCreateWithoutPessoaInput>
  }

  export type funcionarioCreateManyPessoaInputEnvelope = {
    data: funcionarioCreateManyPessoaInput | funcionarioCreateManyPessoaInput[]
    skipDuplicates?: boolean
  }

  export type contactoCreateWithoutPessoaInput = {
    contacto1: string
    contacto2?: string | null
    email1?: string | null
    email2?: string | null
  }

  export type contactoUncheckedCreateWithoutPessoaInput = {
    idContacto?: number
    contacto1: string
    contacto2?: string | null
    email1?: string | null
    email2?: string | null
  }

  export type contactoCreateOrConnectWithoutPessoaInput = {
    where: contactoWhereUniqueInput
    create: XOR<contactoCreateWithoutPessoaInput, contactoUncheckedCreateWithoutPessoaInput>
  }

  export type enderecoCreateWithoutPessoaInput = {
    descricaoEndereco: string
    municipio: municipioCreateNestedOneWithoutEnderecoInput
  }

  export type enderecoUncheckedCreateWithoutPessoaInput = {
    idEndereco?: number
    idMunicipio: number
    descricaoEndereco: string
  }

  export type enderecoCreateOrConnectWithoutPessoaInput = {
    where: enderecoWhereUniqueInput
    create: XOR<enderecoCreateWithoutPessoaInput, enderecoUncheckedCreateWithoutPessoaInput>
  }

  export type paisCreateWithoutPessoaInput = {
    pais: string
  }

  export type paisUncheckedCreateWithoutPessoaInput = {
    idPais?: number
    pais: string
  }

  export type paisCreateOrConnectWithoutPessoaInput = {
    where: paisWhereUniqueInput
    create: XOR<paisCreateWithoutPessoaInput, paisUncheckedCreateWithoutPessoaInput>
  }

  export type biCreateWithoutPessoaInput = {
    dataEmicaoBi: Date | string
    dataValidacaoBi: Date | string
    numeroBI: string
    ficheiro: ficheiroCreateNestedOneWithoutBiInput
  }

  export type biUncheckedCreateWithoutPessoaInput = {
    idBi?: number
    dataEmicaoBi: Date | string
    dataValidacaoBi: Date | string
    numeroBI: string
    codFicheiroBi: number
  }

  export type biCreateOrConnectWithoutPessoaInput = {
    where: biWhereUniqueInput
    create: XOR<biCreateWithoutPessoaInput, biUncheckedCreateWithoutPessoaInput>
  }

  export type titulopropriedadeCreateWithoutPessoaInput = {
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    numeroEmissao: string
    viatura: viaturaCreateNestedOneWithoutTitulopropriedadeInput
    ficheiro: ficheiroCreateNestedOneWithoutTitulopropriedadeInput
  }

  export type titulopropriedadeUncheckedCreateWithoutPessoaInput = {
    codTituloPropriedade?: number
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    numeroEmissao: string
    codViatura: number
    codFicheiroTituloPropriedade: number
  }

  export type titulopropriedadeCreateOrConnectWithoutPessoaInput = {
    where: titulopropriedadeWhereUniqueInput
    create: XOR<titulopropriedadeCreateWithoutPessoaInput, titulopropriedadeUncheckedCreateWithoutPessoaInput>
  }

  export type titulopropriedadeCreateManyPessoaInputEnvelope = {
    data: titulopropriedadeCreateManyPessoaInput | titulopropriedadeCreateManyPessoaInput[]
    skipDuplicates?: boolean
  }

  export type automobilistaUpsertWithWhereUniqueWithoutPessoaInput = {
    where: automobilistaWhereUniqueInput
    update: XOR<automobilistaUpdateWithoutPessoaInput, automobilistaUncheckedUpdateWithoutPessoaInput>
    create: XOR<automobilistaCreateWithoutPessoaInput, automobilistaUncheckedCreateWithoutPessoaInput>
  }

  export type automobilistaUpdateWithWhereUniqueWithoutPessoaInput = {
    where: automobilistaWhereUniqueInput
    data: XOR<automobilistaUpdateWithoutPessoaInput, automobilistaUncheckedUpdateWithoutPessoaInput>
  }

  export type automobilistaUpdateManyWithWhereWithoutPessoaInput = {
    where: automobilistaScalarWhereInput
    data: XOR<automobilistaUpdateManyMutationInput, automobilistaUncheckedUpdateManyWithoutPessoaInput>
  }

  export type funcionarioUpsertWithWhereUniqueWithoutPessoaInput = {
    where: funcionarioWhereUniqueInput
    update: XOR<funcionarioUpdateWithoutPessoaInput, funcionarioUncheckedUpdateWithoutPessoaInput>
    create: XOR<funcionarioCreateWithoutPessoaInput, funcionarioUncheckedCreateWithoutPessoaInput>
  }

  export type funcionarioUpdateWithWhereUniqueWithoutPessoaInput = {
    where: funcionarioWhereUniqueInput
    data: XOR<funcionarioUpdateWithoutPessoaInput, funcionarioUncheckedUpdateWithoutPessoaInput>
  }

  export type funcionarioUpdateManyWithWhereWithoutPessoaInput = {
    where: funcionarioScalarWhereInput
    data: XOR<funcionarioUpdateManyMutationInput, funcionarioUncheckedUpdateManyWithoutPessoaInput>
  }

  export type contactoUpsertWithoutPessoaInput = {
    update: XOR<contactoUpdateWithoutPessoaInput, contactoUncheckedUpdateWithoutPessoaInput>
    create: XOR<contactoCreateWithoutPessoaInput, contactoUncheckedCreateWithoutPessoaInput>
    where?: contactoWhereInput
  }

  export type contactoUpdateToOneWithWhereWithoutPessoaInput = {
    where?: contactoWhereInput
    data: XOR<contactoUpdateWithoutPessoaInput, contactoUncheckedUpdateWithoutPessoaInput>
  }

  export type contactoUpdateWithoutPessoaInput = {
    contacto1?: StringFieldUpdateOperationsInput | string
    contacto2?: NullableStringFieldUpdateOperationsInput | string | null
    email1?: NullableStringFieldUpdateOperationsInput | string | null
    email2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contactoUncheckedUpdateWithoutPessoaInput = {
    idContacto?: IntFieldUpdateOperationsInput | number
    contacto1?: StringFieldUpdateOperationsInput | string
    contacto2?: NullableStringFieldUpdateOperationsInput | string | null
    email1?: NullableStringFieldUpdateOperationsInput | string | null
    email2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type enderecoUpsertWithoutPessoaInput = {
    update: XOR<enderecoUpdateWithoutPessoaInput, enderecoUncheckedUpdateWithoutPessoaInput>
    create: XOR<enderecoCreateWithoutPessoaInput, enderecoUncheckedCreateWithoutPessoaInput>
    where?: enderecoWhereInput
  }

  export type enderecoUpdateToOneWithWhereWithoutPessoaInput = {
    where?: enderecoWhereInput
    data: XOR<enderecoUpdateWithoutPessoaInput, enderecoUncheckedUpdateWithoutPessoaInput>
  }

  export type enderecoUpdateWithoutPessoaInput = {
    descricaoEndereco?: StringFieldUpdateOperationsInput | string
    municipio?: municipioUpdateOneRequiredWithoutEnderecoNestedInput
  }

  export type enderecoUncheckedUpdateWithoutPessoaInput = {
    idEndereco?: IntFieldUpdateOperationsInput | number
    idMunicipio?: IntFieldUpdateOperationsInput | number
    descricaoEndereco?: StringFieldUpdateOperationsInput | string
  }

  export type paisUpsertWithoutPessoaInput = {
    update: XOR<paisUpdateWithoutPessoaInput, paisUncheckedUpdateWithoutPessoaInput>
    create: XOR<paisCreateWithoutPessoaInput, paisUncheckedCreateWithoutPessoaInput>
    where?: paisWhereInput
  }

  export type paisUpdateToOneWithWhereWithoutPessoaInput = {
    where?: paisWhereInput
    data: XOR<paisUpdateWithoutPessoaInput, paisUncheckedUpdateWithoutPessoaInput>
  }

  export type paisUpdateWithoutPessoaInput = {
    pais?: StringFieldUpdateOperationsInput | string
  }

  export type paisUncheckedUpdateWithoutPessoaInput = {
    idPais?: IntFieldUpdateOperationsInput | number
    pais?: StringFieldUpdateOperationsInput | string
  }

  export type biUpsertWithoutPessoaInput = {
    update: XOR<biUpdateWithoutPessoaInput, biUncheckedUpdateWithoutPessoaInput>
    create: XOR<biCreateWithoutPessoaInput, biUncheckedCreateWithoutPessoaInput>
    where?: biWhereInput
  }

  export type biUpdateToOneWithWhereWithoutPessoaInput = {
    where?: biWhereInput
    data: XOR<biUpdateWithoutPessoaInput, biUncheckedUpdateWithoutPessoaInput>
  }

  export type biUpdateWithoutPessoaInput = {
    dataEmicaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidacaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroBI?: StringFieldUpdateOperationsInput | string
    ficheiro?: ficheiroUpdateOneRequiredWithoutBiNestedInput
  }

  export type biUncheckedUpdateWithoutPessoaInput = {
    idBi?: IntFieldUpdateOperationsInput | number
    dataEmicaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidacaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroBI?: StringFieldUpdateOperationsInput | string
    codFicheiroBi?: IntFieldUpdateOperationsInput | number
  }

  export type titulopropriedadeUpsertWithWhereUniqueWithoutPessoaInput = {
    where: titulopropriedadeWhereUniqueInput
    update: XOR<titulopropriedadeUpdateWithoutPessoaInput, titulopropriedadeUncheckedUpdateWithoutPessoaInput>
    create: XOR<titulopropriedadeCreateWithoutPessoaInput, titulopropriedadeUncheckedCreateWithoutPessoaInput>
  }

  export type titulopropriedadeUpdateWithWhereUniqueWithoutPessoaInput = {
    where: titulopropriedadeWhereUniqueInput
    data: XOR<titulopropriedadeUpdateWithoutPessoaInput, titulopropriedadeUncheckedUpdateWithoutPessoaInput>
  }

  export type titulopropriedadeUpdateManyWithWhereWithoutPessoaInput = {
    where: titulopropriedadeScalarWhereInput
    data: XOR<titulopropriedadeUpdateManyMutationInput, titulopropriedadeUncheckedUpdateManyWithoutPessoaInput>
  }

  export type municipioCreateWithoutProvinciaInput = {
    municipio: string
    endereco?: enderecoCreateNestedManyWithoutMunicipioInput
  }

  export type municipioUncheckedCreateWithoutProvinciaInput = {
    idMunicipio?: number
    municipio: string
    endereco?: enderecoUncheckedCreateNestedManyWithoutMunicipioInput
  }

  export type municipioCreateOrConnectWithoutProvinciaInput = {
    where: municipioWhereUniqueInput
    create: XOR<municipioCreateWithoutProvinciaInput, municipioUncheckedCreateWithoutProvinciaInput>
  }

  export type municipioCreateManyProvinciaInputEnvelope = {
    data: municipioCreateManyProvinciaInput | municipioCreateManyProvinciaInput[]
    skipDuplicates?: boolean
  }

  export type municipioUpsertWithWhereUniqueWithoutProvinciaInput = {
    where: municipioWhereUniqueInput
    update: XOR<municipioUpdateWithoutProvinciaInput, municipioUncheckedUpdateWithoutProvinciaInput>
    create: XOR<municipioCreateWithoutProvinciaInput, municipioUncheckedCreateWithoutProvinciaInput>
  }

  export type municipioUpdateWithWhereUniqueWithoutProvinciaInput = {
    where: municipioWhereUniqueInput
    data: XOR<municipioUpdateWithoutProvinciaInput, municipioUncheckedUpdateWithoutProvinciaInput>
  }

  export type municipioUpdateManyWithWhereWithoutProvinciaInput = {
    where: municipioScalarWhereInput
    data: XOR<municipioUpdateManyMutationInput, municipioUncheckedUpdateManyWithoutProvinciaInput>
  }

  export type municipioScalarWhereInput = {
    AND?: municipioScalarWhereInput | municipioScalarWhereInput[]
    OR?: municipioScalarWhereInput[]
    NOT?: municipioScalarWhereInput | municipioScalarWhereInput[]
    idMunicipio?: IntFilter<"municipio"> | number
    idProvincia?: IntFilter<"municipio"> | number
    municipio?: StringFilter<"municipio"> | string
  }

  export type livreteCreateWithoutSerivicoviaturaInput = {
    numeroQuadro: string
    corViatura: string
    MedidasPneumaticos: string
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    lotacao: string
    cilindrada: string
    numeroCilindro: string
    conbustivel: string
    peso: string
    tara: string
    tipoCaixa: string
    distanciaEixo: string
    modelo: string
    marca: marcaCreateNestedOneWithoutLivreteInput
    viatura: viaturaCreateNestedOneWithoutLivreteInput
  }

  export type livreteUncheckedCreateWithoutSerivicoviaturaInput = {
    codLivrete?: number
    codViatura: number
    numeroQuadro: string
    corViatura: string
    MedidasPneumaticos: string
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    lotacao: string
    cilindrada: string
    numeroCilindro: string
    conbustivel: string
    peso: string
    tara: string
    tipoCaixa: string
    distanciaEixo: string
    modelo: string
    codMarca: number
  }

  export type livreteCreateOrConnectWithoutSerivicoviaturaInput = {
    where: livreteWhereUniqueInput
    create: XOR<livreteCreateWithoutSerivicoviaturaInput, livreteUncheckedCreateWithoutSerivicoviaturaInput>
  }

  export type livreteCreateManySerivicoviaturaInputEnvelope = {
    data: livreteCreateManySerivicoviaturaInput | livreteCreateManySerivicoviaturaInput[]
    skipDuplicates?: boolean
  }

  export type livreteUpsertWithWhereUniqueWithoutSerivicoviaturaInput = {
    where: livreteWhereUniqueInput
    update: XOR<livreteUpdateWithoutSerivicoviaturaInput, livreteUncheckedUpdateWithoutSerivicoviaturaInput>
    create: XOR<livreteCreateWithoutSerivicoviaturaInput, livreteUncheckedCreateWithoutSerivicoviaturaInput>
  }

  export type livreteUpdateWithWhereUniqueWithoutSerivicoviaturaInput = {
    where: livreteWhereUniqueInput
    data: XOR<livreteUpdateWithoutSerivicoviaturaInput, livreteUncheckedUpdateWithoutSerivicoviaturaInput>
  }

  export type livreteUpdateManyWithWhereWithoutSerivicoviaturaInput = {
    where: livreteScalarWhereInput
    data: XOR<livreteUpdateManyMutationInput, livreteUncheckedUpdateManyWithoutSerivicoviaturaInput>
  }

  export type infracaoCreateWithoutTipoinfracaoInput = {
    multa_infracao_codMultaTomulta: multaCreateNestedOneWithoutInfracao_infracao_codMultaTomultaInput
    multa_multa_codInfracaoToinfracao?: multaCreateNestedManyWithoutInfracao_multa_codInfracaoToinfracaoInput
  }

  export type infracaoUncheckedCreateWithoutTipoinfracaoInput = {
    codInfracao?: number
    codMulta: number
    multa_multa_codInfracaoToinfracao?: multaUncheckedCreateNestedManyWithoutInfracao_multa_codInfracaoToinfracaoInput
  }

  export type infracaoCreateOrConnectWithoutTipoinfracaoInput = {
    where: infracaoWhereUniqueInput
    create: XOR<infracaoCreateWithoutTipoinfracaoInput, infracaoUncheckedCreateWithoutTipoinfracaoInput>
  }

  export type infracaoCreateManyTipoinfracaoInputEnvelope = {
    data: infracaoCreateManyTipoinfracaoInput | infracaoCreateManyTipoinfracaoInput[]
    skipDuplicates?: boolean
  }

  export type infracaoUpsertWithWhereUniqueWithoutTipoinfracaoInput = {
    where: infracaoWhereUniqueInput
    update: XOR<infracaoUpdateWithoutTipoinfracaoInput, infracaoUncheckedUpdateWithoutTipoinfracaoInput>
    create: XOR<infracaoCreateWithoutTipoinfracaoInput, infracaoUncheckedCreateWithoutTipoinfracaoInput>
  }

  export type infracaoUpdateWithWhereUniqueWithoutTipoinfracaoInput = {
    where: infracaoWhereUniqueInput
    data: XOR<infracaoUpdateWithoutTipoinfracaoInput, infracaoUncheckedUpdateWithoutTipoinfracaoInput>
  }

  export type infracaoUpdateManyWithWhereWithoutTipoinfracaoInput = {
    where: infracaoScalarWhereInput
    data: XOR<infracaoUpdateManyMutationInput, infracaoUncheckedUpdateManyWithoutTipoinfracaoInput>
  }

  export type alertarouboCreateWithoutTiporouboInput = {
    dataRoubo: Date | string
    enderecoRoubo: string
    descRoubo: string
    automobilista: automobilistaCreateNestedOneWithoutAlertarouboInput
    viatura: viaturaCreateNestedOneWithoutAlertarouboInput
  }

  export type alertarouboUncheckedCreateWithoutTiporouboInput = {
    codAlertaRoubo?: number
    codAutomobilista: number
    codViatura: number
    dataRoubo: Date | string
    enderecoRoubo: string
    descRoubo: string
  }

  export type alertarouboCreateOrConnectWithoutTiporouboInput = {
    where: alertarouboWhereUniqueInput
    create: XOR<alertarouboCreateWithoutTiporouboInput, alertarouboUncheckedCreateWithoutTiporouboInput>
  }

  export type alertarouboCreateManyTiporouboInputEnvelope = {
    data: alertarouboCreateManyTiporouboInput | alertarouboCreateManyTiporouboInput[]
    skipDuplicates?: boolean
  }

  export type alertarouboUpsertWithWhereUniqueWithoutTiporouboInput = {
    where: alertarouboWhereUniqueInput
    update: XOR<alertarouboUpdateWithoutTiporouboInput, alertarouboUncheckedUpdateWithoutTiporouboInput>
    create: XOR<alertarouboCreateWithoutTiporouboInput, alertarouboUncheckedCreateWithoutTiporouboInput>
  }

  export type alertarouboUpdateWithWhereUniqueWithoutTiporouboInput = {
    where: alertarouboWhereUniqueInput
    data: XOR<alertarouboUpdateWithoutTiporouboInput, alertarouboUncheckedUpdateWithoutTiporouboInput>
  }

  export type alertarouboUpdateManyWithWhereWithoutTiporouboInput = {
    where: alertarouboScalarWhereInput
    data: XOR<alertarouboUpdateManyMutationInput, alertarouboUncheckedUpdateManyWithoutTiporouboInput>
  }

  export type pessoaCreateWithoutTitulopropriedadeInput = {
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    senha: string
    automobilista?: automobilistaCreateNestedManyWithoutPessoaInput
    funcionario?: funcionarioCreateNestedManyWithoutPessoaInput
    contacto?: contactoCreateNestedOneWithoutPessoaInput
    endereco?: enderecoCreateNestedOneWithoutPessoaInput
    pais?: paisCreateNestedOneWithoutPessoaInput
    bi: biCreateNestedOneWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutTitulopropriedadeInput = {
    codPessoa?: number
    codEndereco?: number | null
    codNacionalidade?: number | null
    codContacto?: number | null
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    codBi: number
    senha: string
    automobilista?: automobilistaUncheckedCreateNestedManyWithoutPessoaInput
    funcionario?: funcionarioUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutTitulopropriedadeInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutTitulopropriedadeInput, pessoaUncheckedCreateWithoutTitulopropriedadeInput>
  }

  export type viaturaCreateWithoutTitulopropriedadeInput = {
    numeroMatricula: string
    alertaroubo?: alertarouboCreateNestedManyWithoutViaturaInput
    livrete?: livreteCreateNestedManyWithoutViaturaInput
    multa?: multaCreateNestedManyWithoutViaturaInput
  }

  export type viaturaUncheckedCreateWithoutTitulopropriedadeInput = {
    codViatura?: number
    numeroMatricula: string
    alertaroubo?: alertarouboUncheckedCreateNestedManyWithoutViaturaInput
    livrete?: livreteUncheckedCreateNestedManyWithoutViaturaInput
    multa?: multaUncheckedCreateNestedManyWithoutViaturaInput
  }

  export type viaturaCreateOrConnectWithoutTitulopropriedadeInput = {
    where: viaturaWhereUniqueInput
    create: XOR<viaturaCreateWithoutTitulopropriedadeInput, viaturaUncheckedCreateWithoutTitulopropriedadeInput>
  }

  export type ficheiroCreateWithoutTitulopropriedadeInput = {
    nomeFicheiro: string
    dataEntrada?: string | null
    dataValidacao?: string | null
    estadoValidacao?: $Enums.ficheiro_estadoValidacao | null
    bi?: biCreateNestedManyWithoutFicheiroInput
    cartaconducao?: cartaconducaoCreateNestedManyWithoutFicheiroInput
    funcionario?: funcionarioCreateNestedManyWithoutFicheiroInput
    pagamentomulta?: pagamentomultaCreateNestedManyWithoutFicheiroInput
  }

  export type ficheiroUncheckedCreateWithoutTitulopropriedadeInput = {
    idFicheiro?: number
    nomeFicheiro: string
    dataEntrada?: string | null
    dataValidacao?: string | null
    estadoValidacao?: $Enums.ficheiro_estadoValidacao | null
    bi?: biUncheckedCreateNestedManyWithoutFicheiroInput
    cartaconducao?: cartaconducaoUncheckedCreateNestedManyWithoutFicheiroInput
    funcionario?: funcionarioUncheckedCreateNestedManyWithoutFicheiroInput
    pagamentomulta?: pagamentomultaUncheckedCreateNestedManyWithoutFicheiroInput
  }

  export type ficheiroCreateOrConnectWithoutTitulopropriedadeInput = {
    where: ficheiroWhereUniqueInput
    create: XOR<ficheiroCreateWithoutTitulopropriedadeInput, ficheiroUncheckedCreateWithoutTitulopropriedadeInput>
  }

  export type pessoaUpsertWithoutTitulopropriedadeInput = {
    update: XOR<pessoaUpdateWithoutTitulopropriedadeInput, pessoaUncheckedUpdateWithoutTitulopropriedadeInput>
    create: XOR<pessoaCreateWithoutTitulopropriedadeInput, pessoaUncheckedCreateWithoutTitulopropriedadeInput>
    where?: pessoaWhereInput
  }

  export type pessoaUpdateToOneWithWhereWithoutTitulopropriedadeInput = {
    where?: pessoaWhereInput
    data: XOR<pessoaUpdateWithoutTitulopropriedadeInput, pessoaUncheckedUpdateWithoutTitulopropriedadeInput>
  }

  export type pessoaUpdateWithoutTitulopropriedadeInput = {
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    automobilista?: automobilistaUpdateManyWithoutPessoaNestedInput
    funcionario?: funcionarioUpdateManyWithoutPessoaNestedInput
    contacto?: contactoUpdateOneWithoutPessoaNestedInput
    endereco?: enderecoUpdateOneWithoutPessoaNestedInput
    pais?: paisUpdateOneWithoutPessoaNestedInput
    bi?: biUpdateOneRequiredWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutTitulopropriedadeInput = {
    codPessoa?: IntFieldUpdateOperationsInput | number
    codEndereco?: NullableIntFieldUpdateOperationsInput | number | null
    codNacionalidade?: NullableIntFieldUpdateOperationsInput | number | null
    codContacto?: NullableIntFieldUpdateOperationsInput | number | null
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    codBi?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    automobilista?: automobilistaUncheckedUpdateManyWithoutPessoaNestedInput
    funcionario?: funcionarioUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type viaturaUpsertWithoutTitulopropriedadeInput = {
    update: XOR<viaturaUpdateWithoutTitulopropriedadeInput, viaturaUncheckedUpdateWithoutTitulopropriedadeInput>
    create: XOR<viaturaCreateWithoutTitulopropriedadeInput, viaturaUncheckedCreateWithoutTitulopropriedadeInput>
    where?: viaturaWhereInput
  }

  export type viaturaUpdateToOneWithWhereWithoutTitulopropriedadeInput = {
    where?: viaturaWhereInput
    data: XOR<viaturaUpdateWithoutTitulopropriedadeInput, viaturaUncheckedUpdateWithoutTitulopropriedadeInput>
  }

  export type viaturaUpdateWithoutTitulopropriedadeInput = {
    numeroMatricula?: StringFieldUpdateOperationsInput | string
    alertaroubo?: alertarouboUpdateManyWithoutViaturaNestedInput
    livrete?: livreteUpdateManyWithoutViaturaNestedInput
    multa?: multaUpdateManyWithoutViaturaNestedInput
  }

  export type viaturaUncheckedUpdateWithoutTitulopropriedadeInput = {
    codViatura?: IntFieldUpdateOperationsInput | number
    numeroMatricula?: StringFieldUpdateOperationsInput | string
    alertaroubo?: alertarouboUncheckedUpdateManyWithoutViaturaNestedInput
    livrete?: livreteUncheckedUpdateManyWithoutViaturaNestedInput
    multa?: multaUncheckedUpdateManyWithoutViaturaNestedInput
  }

  export type ficheiroUpsertWithoutTitulopropriedadeInput = {
    update: XOR<ficheiroUpdateWithoutTitulopropriedadeInput, ficheiroUncheckedUpdateWithoutTitulopropriedadeInput>
    create: XOR<ficheiroCreateWithoutTitulopropriedadeInput, ficheiroUncheckedCreateWithoutTitulopropriedadeInput>
    where?: ficheiroWhereInput
  }

  export type ficheiroUpdateToOneWithWhereWithoutTitulopropriedadeInput = {
    where?: ficheiroWhereInput
    data: XOR<ficheiroUpdateWithoutTitulopropriedadeInput, ficheiroUncheckedUpdateWithoutTitulopropriedadeInput>
  }

  export type ficheiroUpdateWithoutTitulopropriedadeInput = {
    nomeFicheiro?: StringFieldUpdateOperationsInput | string
    dataEntrada?: NullableStringFieldUpdateOperationsInput | string | null
    dataValidacao?: NullableStringFieldUpdateOperationsInput | string | null
    estadoValidacao?: NullableEnumficheiro_estadoValidacaoFieldUpdateOperationsInput | $Enums.ficheiro_estadoValidacao | null
    bi?: biUpdateManyWithoutFicheiroNestedInput
    cartaconducao?: cartaconducaoUpdateManyWithoutFicheiroNestedInput
    funcionario?: funcionarioUpdateManyWithoutFicheiroNestedInput
    pagamentomulta?: pagamentomultaUpdateManyWithoutFicheiroNestedInput
  }

  export type ficheiroUncheckedUpdateWithoutTitulopropriedadeInput = {
    idFicheiro?: IntFieldUpdateOperationsInput | number
    nomeFicheiro?: StringFieldUpdateOperationsInput | string
    dataEntrada?: NullableStringFieldUpdateOperationsInput | string | null
    dataValidacao?: NullableStringFieldUpdateOperationsInput | string | null
    estadoValidacao?: NullableEnumficheiro_estadoValidacaoFieldUpdateOperationsInput | $Enums.ficheiro_estadoValidacao | null
    bi?: biUncheckedUpdateManyWithoutFicheiroNestedInput
    cartaconducao?: cartaconducaoUncheckedUpdateManyWithoutFicheiroNestedInput
    funcionario?: funcionarioUncheckedUpdateManyWithoutFicheiroNestedInput
    pagamentomulta?: pagamentomultaUncheckedUpdateManyWithoutFicheiroNestedInput
  }

  export type alertarouboCreateWithoutViaturaInput = {
    dataRoubo: Date | string
    enderecoRoubo: string
    descRoubo: string
    automobilista: automobilistaCreateNestedOneWithoutAlertarouboInput
    tiporoubo: tiporouboCreateNestedOneWithoutAlertarouboInput
  }

  export type alertarouboUncheckedCreateWithoutViaturaInput = {
    codAlertaRoubo?: number
    codAutomobilista: number
    dataRoubo: Date | string
    enderecoRoubo: string
    codTipoRoubo: number
    descRoubo: string
  }

  export type alertarouboCreateOrConnectWithoutViaturaInput = {
    where: alertarouboWhereUniqueInput
    create: XOR<alertarouboCreateWithoutViaturaInput, alertarouboUncheckedCreateWithoutViaturaInput>
  }

  export type alertarouboCreateManyViaturaInputEnvelope = {
    data: alertarouboCreateManyViaturaInput | alertarouboCreateManyViaturaInput[]
    skipDuplicates?: boolean
  }

  export type livreteCreateWithoutViaturaInput = {
    numeroQuadro: string
    corViatura: string
    MedidasPneumaticos: string
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    lotacao: string
    cilindrada: string
    numeroCilindro: string
    conbustivel: string
    peso: string
    tara: string
    tipoCaixa: string
    distanciaEixo: string
    modelo: string
    marca: marcaCreateNestedOneWithoutLivreteInput
    serivicoviatura: serivicoviaturaCreateNestedOneWithoutLivreteInput
  }

  export type livreteUncheckedCreateWithoutViaturaInput = {
    codLivrete?: number
    numeroQuadro: string
    corViatura: string
    MedidasPneumaticos: string
    codServico: number
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    lotacao: string
    cilindrada: string
    numeroCilindro: string
    conbustivel: string
    peso: string
    tara: string
    tipoCaixa: string
    distanciaEixo: string
    modelo: string
    codMarca: number
  }

  export type livreteCreateOrConnectWithoutViaturaInput = {
    where: livreteWhereUniqueInput
    create: XOR<livreteCreateWithoutViaturaInput, livreteUncheckedCreateWithoutViaturaInput>
  }

  export type livreteCreateManyViaturaInputEnvelope = {
    data: livreteCreateManyViaturaInput | livreteCreateManyViaturaInput[]
    skipDuplicates?: boolean
  }

  export type multaCreateWithoutViaturaInput = {
    valorMulta: string
    estadoMulta: $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoCreateNestedManyWithoutMulta_infracao_codMultaTomultaInput
    automobilista?: automobilistaCreateNestedOneWithoutMultaInput
    infracao_multa_codInfracaoToinfracao: infracaoCreateNestedOneWithoutMulta_multa_codInfracaoToinfracaoInput
    pagamentomulta?: pagamentomultaCreateNestedManyWithoutMultaInput
  }

  export type multaUncheckedCreateWithoutViaturaInput = {
    codMulta?: number
    codAutomobilista?: number | null
    codInfracao: number
    valorMulta: string
    estadoMulta: $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoUncheckedCreateNestedManyWithoutMulta_infracao_codMultaTomultaInput
    pagamentomulta?: pagamentomultaUncheckedCreateNestedManyWithoutMultaInput
  }

  export type multaCreateOrConnectWithoutViaturaInput = {
    where: multaWhereUniqueInput
    create: XOR<multaCreateWithoutViaturaInput, multaUncheckedCreateWithoutViaturaInput>
  }

  export type multaCreateManyViaturaInputEnvelope = {
    data: multaCreateManyViaturaInput | multaCreateManyViaturaInput[]
    skipDuplicates?: boolean
  }

  export type titulopropriedadeCreateWithoutViaturaInput = {
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    numeroEmissao: string
    pessoa: pessoaCreateNestedOneWithoutTitulopropriedadeInput
    ficheiro: ficheiroCreateNestedOneWithoutTitulopropriedadeInput
  }

  export type titulopropriedadeUncheckedCreateWithoutViaturaInput = {
    codTituloPropriedade?: number
    codPessoa: number
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    numeroEmissao: string
    codFicheiroTituloPropriedade: number
  }

  export type titulopropriedadeCreateOrConnectWithoutViaturaInput = {
    where: titulopropriedadeWhereUniqueInput
    create: XOR<titulopropriedadeCreateWithoutViaturaInput, titulopropriedadeUncheckedCreateWithoutViaturaInput>
  }

  export type titulopropriedadeCreateManyViaturaInputEnvelope = {
    data: titulopropriedadeCreateManyViaturaInput | titulopropriedadeCreateManyViaturaInput[]
    skipDuplicates?: boolean
  }

  export type alertarouboUpsertWithWhereUniqueWithoutViaturaInput = {
    where: alertarouboWhereUniqueInput
    update: XOR<alertarouboUpdateWithoutViaturaInput, alertarouboUncheckedUpdateWithoutViaturaInput>
    create: XOR<alertarouboCreateWithoutViaturaInput, alertarouboUncheckedCreateWithoutViaturaInput>
  }

  export type alertarouboUpdateWithWhereUniqueWithoutViaturaInput = {
    where: alertarouboWhereUniqueInput
    data: XOR<alertarouboUpdateWithoutViaturaInput, alertarouboUncheckedUpdateWithoutViaturaInput>
  }

  export type alertarouboUpdateManyWithWhereWithoutViaturaInput = {
    where: alertarouboScalarWhereInput
    data: XOR<alertarouboUpdateManyMutationInput, alertarouboUncheckedUpdateManyWithoutViaturaInput>
  }

  export type livreteUpsertWithWhereUniqueWithoutViaturaInput = {
    where: livreteWhereUniqueInput
    update: XOR<livreteUpdateWithoutViaturaInput, livreteUncheckedUpdateWithoutViaturaInput>
    create: XOR<livreteCreateWithoutViaturaInput, livreteUncheckedCreateWithoutViaturaInput>
  }

  export type livreteUpdateWithWhereUniqueWithoutViaturaInput = {
    where: livreteWhereUniqueInput
    data: XOR<livreteUpdateWithoutViaturaInput, livreteUncheckedUpdateWithoutViaturaInput>
  }

  export type livreteUpdateManyWithWhereWithoutViaturaInput = {
    where: livreteScalarWhereInput
    data: XOR<livreteUpdateManyMutationInput, livreteUncheckedUpdateManyWithoutViaturaInput>
  }

  export type multaUpsertWithWhereUniqueWithoutViaturaInput = {
    where: multaWhereUniqueInput
    update: XOR<multaUpdateWithoutViaturaInput, multaUncheckedUpdateWithoutViaturaInput>
    create: XOR<multaCreateWithoutViaturaInput, multaUncheckedCreateWithoutViaturaInput>
  }

  export type multaUpdateWithWhereUniqueWithoutViaturaInput = {
    where: multaWhereUniqueInput
    data: XOR<multaUpdateWithoutViaturaInput, multaUncheckedUpdateWithoutViaturaInput>
  }

  export type multaUpdateManyWithWhereWithoutViaturaInput = {
    where: multaScalarWhereInput
    data: XOR<multaUpdateManyMutationInput, multaUncheckedUpdateManyWithoutViaturaInput>
  }

  export type titulopropriedadeUpsertWithWhereUniqueWithoutViaturaInput = {
    where: titulopropriedadeWhereUniqueInput
    update: XOR<titulopropriedadeUpdateWithoutViaturaInput, titulopropriedadeUncheckedUpdateWithoutViaturaInput>
    create: XOR<titulopropriedadeCreateWithoutViaturaInput, titulopropriedadeUncheckedCreateWithoutViaturaInput>
  }

  export type titulopropriedadeUpdateWithWhereUniqueWithoutViaturaInput = {
    where: titulopropriedadeWhereUniqueInput
    data: XOR<titulopropriedadeUpdateWithoutViaturaInput, titulopropriedadeUncheckedUpdateWithoutViaturaInput>
  }

  export type titulopropriedadeUpdateManyWithWhereWithoutViaturaInput = {
    where: titulopropriedadeScalarWhereInput
    data: XOR<titulopropriedadeUpdateManyMutationInput, titulopropriedadeUncheckedUpdateManyWithoutViaturaInput>
  }

  export type alertarouboCreateManyAutomobilistaInput = {
    codAlertaRoubo?: number
    codViatura: number
    dataRoubo: Date | string
    enderecoRoubo: string
    codTipoRoubo: number
    descRoubo: string
  }

  export type multaCreateManyAutomobilistaInput = {
    codMulta?: number
    CodViatura?: number | null
    codInfracao: number
    valorMulta: string
    estadoMulta: $Enums.multa_estadoMulta
  }

  export type alertarouboUpdateWithoutAutomobilistaInput = {
    dataRoubo?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoRoubo?: StringFieldUpdateOperationsInput | string
    descRoubo?: StringFieldUpdateOperationsInput | string
    tiporoubo?: tiporouboUpdateOneRequiredWithoutAlertarouboNestedInput
    viatura?: viaturaUpdateOneRequiredWithoutAlertarouboNestedInput
  }

  export type alertarouboUncheckedUpdateWithoutAutomobilistaInput = {
    codAlertaRoubo?: IntFieldUpdateOperationsInput | number
    codViatura?: IntFieldUpdateOperationsInput | number
    dataRoubo?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoRoubo?: StringFieldUpdateOperationsInput | string
    codTipoRoubo?: IntFieldUpdateOperationsInput | number
    descRoubo?: StringFieldUpdateOperationsInput | string
  }

  export type alertarouboUncheckedUpdateManyWithoutAutomobilistaInput = {
    codAlertaRoubo?: IntFieldUpdateOperationsInput | number
    codViatura?: IntFieldUpdateOperationsInput | number
    dataRoubo?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoRoubo?: StringFieldUpdateOperationsInput | string
    codTipoRoubo?: IntFieldUpdateOperationsInput | number
    descRoubo?: StringFieldUpdateOperationsInput | string
  }

  export type multaUpdateWithoutAutomobilistaInput = {
    valorMulta?: StringFieldUpdateOperationsInput | string
    estadoMulta?: Enummulta_estadoMultaFieldUpdateOperationsInput | $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoUpdateManyWithoutMulta_infracao_codMultaTomultaNestedInput
    infracao_multa_codInfracaoToinfracao?: infracaoUpdateOneRequiredWithoutMulta_multa_codInfracaoToinfracaoNestedInput
    viatura?: viaturaUpdateOneWithoutMultaNestedInput
    pagamentomulta?: pagamentomultaUpdateManyWithoutMultaNestedInput
  }

  export type multaUncheckedUpdateWithoutAutomobilistaInput = {
    codMulta?: IntFieldUpdateOperationsInput | number
    CodViatura?: NullableIntFieldUpdateOperationsInput | number | null
    codInfracao?: IntFieldUpdateOperationsInput | number
    valorMulta?: StringFieldUpdateOperationsInput | string
    estadoMulta?: Enummulta_estadoMultaFieldUpdateOperationsInput | $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoUncheckedUpdateManyWithoutMulta_infracao_codMultaTomultaNestedInput
    pagamentomulta?: pagamentomultaUncheckedUpdateManyWithoutMultaNestedInput
  }

  export type multaUncheckedUpdateManyWithoutAutomobilistaInput = {
    codMulta?: IntFieldUpdateOperationsInput | number
    CodViatura?: NullableIntFieldUpdateOperationsInput | number | null
    codInfracao?: IntFieldUpdateOperationsInput | number
    valorMulta?: StringFieldUpdateOperationsInput | string
    estadoMulta?: Enummulta_estadoMultaFieldUpdateOperationsInput | $Enums.multa_estadoMulta
  }

  export type pessoaCreateManyBiInput = {
    codPessoa?: number
    codEndereco?: number | null
    codNacionalidade?: number | null
    codContacto?: number | null
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    senha: string
  }

  export type pessoaUpdateWithoutBiInput = {
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    automobilista?: automobilistaUpdateManyWithoutPessoaNestedInput
    funcionario?: funcionarioUpdateManyWithoutPessoaNestedInput
    contacto?: contactoUpdateOneWithoutPessoaNestedInput
    endereco?: enderecoUpdateOneWithoutPessoaNestedInput
    pais?: paisUpdateOneWithoutPessoaNestedInput
    titulopropriedade?: titulopropriedadeUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutBiInput = {
    codPessoa?: IntFieldUpdateOperationsInput | number
    codEndereco?: NullableIntFieldUpdateOperationsInput | number | null
    codNacionalidade?: NullableIntFieldUpdateOperationsInput | number | null
    codContacto?: NullableIntFieldUpdateOperationsInput | number | null
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    automobilista?: automobilistaUncheckedUpdateManyWithoutPessoaNestedInput
    funcionario?: funcionarioUncheckedUpdateManyWithoutPessoaNestedInput
    titulopropriedade?: titulopropriedadeUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateManyWithoutBiInput = {
    codPessoa?: IntFieldUpdateOperationsInput | number
    codEndereco?: NullableIntFieldUpdateOperationsInput | number | null
    codNacionalidade?: NullableIntFieldUpdateOperationsInput | number | null
    codContacto?: NullableIntFieldUpdateOperationsInput | number | null
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
  }

  export type automobilistaCreateManyCartaconducaoInput = {
    codAutomobilista?: number
    codPessoa: number
  }

  export type automobilistaUpdateWithoutCartaconducaoInput = {
    alertaroubo?: alertarouboUpdateManyWithoutAutomobilistaNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutAutomobilistaNestedInput
    multa?: multaUpdateManyWithoutAutomobilistaNestedInput
  }

  export type automobilistaUncheckedUpdateWithoutCartaconducaoInput = {
    codAutomobilista?: IntFieldUpdateOperationsInput | number
    codPessoa?: IntFieldUpdateOperationsInput | number
    alertaroubo?: alertarouboUncheckedUpdateManyWithoutAutomobilistaNestedInput
    multa?: multaUncheckedUpdateManyWithoutAutomobilistaNestedInput
  }

  export type automobilistaUncheckedUpdateManyWithoutCartaconducaoInput = {
    codAutomobilista?: IntFieldUpdateOperationsInput | number
    codPessoa?: IntFieldUpdateOperationsInput | number
  }

  export type cartaconducaoCreateManyCategoriacartaInput = {
    codCartaConducao?: number
    dataEmissao: Date | string
    dataValidade: Date | string
    numeroVia: string
    numeroCarta: number
    dataPrimeiraEmissao: Date | string
    localEmissao: number
    codFicheiroCartaConducao: number
  }

  export type cartaconducaoUpdateWithoutCategoriacartaInput = {
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroVia?: StringFieldUpdateOperationsInput | string
    numeroCarta?: IntFieldUpdateOperationsInput | number
    dataPrimeiraEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    localEmissao?: IntFieldUpdateOperationsInput | number
    automobilista?: automobilistaUpdateManyWithoutCartaconducaoNestedInput
    ficheiro?: ficheiroUpdateOneRequiredWithoutCartaconducaoNestedInput
  }

  export type cartaconducaoUncheckedUpdateWithoutCategoriacartaInput = {
    codCartaConducao?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroVia?: StringFieldUpdateOperationsInput | string
    numeroCarta?: IntFieldUpdateOperationsInput | number
    dataPrimeiraEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    localEmissao?: IntFieldUpdateOperationsInput | number
    codFicheiroCartaConducao?: IntFieldUpdateOperationsInput | number
    automobilista?: automobilistaUncheckedUpdateManyWithoutCartaconducaoNestedInput
  }

  export type cartaconducaoUncheckedUpdateManyWithoutCategoriacartaInput = {
    codCartaConducao?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroVia?: StringFieldUpdateOperationsInput | string
    numeroCarta?: IntFieldUpdateOperationsInput | number
    dataPrimeiraEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    localEmissao?: IntFieldUpdateOperationsInput | number
    codFicheiroCartaConducao?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaCreateManyContactoInput = {
    codPessoa?: number
    codEndereco?: number | null
    codNacionalidade?: number | null
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    codBi: number
    senha: string
  }

  export type pessoaUpdateWithoutContactoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    automobilista?: automobilistaUpdateManyWithoutPessoaNestedInput
    funcionario?: funcionarioUpdateManyWithoutPessoaNestedInput
    endereco?: enderecoUpdateOneWithoutPessoaNestedInput
    pais?: paisUpdateOneWithoutPessoaNestedInput
    bi?: biUpdateOneRequiredWithoutPessoaNestedInput
    titulopropriedade?: titulopropriedadeUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutContactoInput = {
    codPessoa?: IntFieldUpdateOperationsInput | number
    codEndereco?: NullableIntFieldUpdateOperationsInput | number | null
    codNacionalidade?: NullableIntFieldUpdateOperationsInput | number | null
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    codBi?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    automobilista?: automobilistaUncheckedUpdateManyWithoutPessoaNestedInput
    funcionario?: funcionarioUncheckedUpdateManyWithoutPessoaNestedInput
    titulopropriedade?: titulopropriedadeUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateManyWithoutContactoInput = {
    codPessoa?: IntFieldUpdateOperationsInput | number
    codEndereco?: NullableIntFieldUpdateOperationsInput | number | null
    codNacionalidade?: NullableIntFieldUpdateOperationsInput | number | null
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    codBi?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
  }

  export type pessoaCreateManyEnderecoInput = {
    codPessoa?: number
    codNacionalidade?: number | null
    codContacto?: number | null
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    codBi: number
    senha: string
  }

  export type pessoaUpdateWithoutEnderecoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    automobilista?: automobilistaUpdateManyWithoutPessoaNestedInput
    funcionario?: funcionarioUpdateManyWithoutPessoaNestedInput
    contacto?: contactoUpdateOneWithoutPessoaNestedInput
    pais?: paisUpdateOneWithoutPessoaNestedInput
    bi?: biUpdateOneRequiredWithoutPessoaNestedInput
    titulopropriedade?: titulopropriedadeUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutEnderecoInput = {
    codPessoa?: IntFieldUpdateOperationsInput | number
    codNacionalidade?: NullableIntFieldUpdateOperationsInput | number | null
    codContacto?: NullableIntFieldUpdateOperationsInput | number | null
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    codBi?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    automobilista?: automobilistaUncheckedUpdateManyWithoutPessoaNestedInput
    funcionario?: funcionarioUncheckedUpdateManyWithoutPessoaNestedInput
    titulopropriedade?: titulopropriedadeUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateManyWithoutEnderecoInput = {
    codPessoa?: IntFieldUpdateOperationsInput | number
    codNacionalidade?: NullableIntFieldUpdateOperationsInput | number | null
    codContacto?: NullableIntFieldUpdateOperationsInput | number | null
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    codBi?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
  }

  export type biCreateManyFicheiroInput = {
    idBi?: number
    dataEmicaoBi: Date | string
    dataValidacaoBi: Date | string
    numeroBI: string
  }

  export type cartaconducaoCreateManyFicheiroInput = {
    codCartaConducao?: number
    dataEmissao: Date | string
    dataValidade: Date | string
    numeroVia: string
    codCategoriaCarta: number
    numeroCarta: number
    dataPrimeiraEmissao: Date | string
    localEmissao: number
  }

  export type funcionarioCreateManyFicheiroInput = {
    codFuncionario?: number
    codPessoa: number
    codficheiroFotoPendente?: number | null
    numeroAgente?: string | null
    senha?: number
  }

  export type pagamentomultaCreateManyFicheiroInput = {
    codPagamentoMulta?: number
    codMulta: number
    dataPagamento: Date | string
    valorPago: string
    descCodigoDeposito: string
  }

  export type titulopropriedadeCreateManyFicheiroInput = {
    codTituloPropriedade?: number
    codPessoa: number
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    numeroEmissao: string
    codViatura: number
  }

  export type biUpdateWithoutFicheiroInput = {
    dataEmicaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidacaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroBI?: StringFieldUpdateOperationsInput | string
    pessoa?: pessoaUpdateManyWithoutBiNestedInput
  }

  export type biUncheckedUpdateWithoutFicheiroInput = {
    idBi?: IntFieldUpdateOperationsInput | number
    dataEmicaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidacaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroBI?: StringFieldUpdateOperationsInput | string
    pessoa?: pessoaUncheckedUpdateManyWithoutBiNestedInput
  }

  export type biUncheckedUpdateManyWithoutFicheiroInput = {
    idBi?: IntFieldUpdateOperationsInput | number
    dataEmicaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidacaoBi?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroBI?: StringFieldUpdateOperationsInput | string
  }

  export type cartaconducaoUpdateWithoutFicheiroInput = {
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroVia?: StringFieldUpdateOperationsInput | string
    numeroCarta?: IntFieldUpdateOperationsInput | number
    dataPrimeiraEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    localEmissao?: IntFieldUpdateOperationsInput | number
    automobilista?: automobilistaUpdateManyWithoutCartaconducaoNestedInput
    categoriacarta?: categoriacartaUpdateOneRequiredWithoutCartaconducaoNestedInput
  }

  export type cartaconducaoUncheckedUpdateWithoutFicheiroInput = {
    codCartaConducao?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroVia?: StringFieldUpdateOperationsInput | string
    codCategoriaCarta?: IntFieldUpdateOperationsInput | number
    numeroCarta?: IntFieldUpdateOperationsInput | number
    dataPrimeiraEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    localEmissao?: IntFieldUpdateOperationsInput | number
    automobilista?: automobilistaUncheckedUpdateManyWithoutCartaconducaoNestedInput
  }

  export type cartaconducaoUncheckedUpdateManyWithoutFicheiroInput = {
    codCartaConducao?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataValidade?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroVia?: StringFieldUpdateOperationsInput | string
    codCategoriaCarta?: IntFieldUpdateOperationsInput | number
    numeroCarta?: IntFieldUpdateOperationsInput | number
    dataPrimeiraEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    localEmissao?: IntFieldUpdateOperationsInput | number
  }

  export type funcionarioUpdateWithoutFicheiroInput = {
    codficheiroFotoPendente?: NullableIntFieldUpdateOperationsInput | number | null
    numeroAgente?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: IntFieldUpdateOperationsInput | number
    pessoa?: pessoaUpdateOneRequiredWithoutFuncionarioNestedInput
  }

  export type funcionarioUncheckedUpdateWithoutFicheiroInput = {
    codFuncionario?: IntFieldUpdateOperationsInput | number
    codPessoa?: IntFieldUpdateOperationsInput | number
    codficheiroFotoPendente?: NullableIntFieldUpdateOperationsInput | number | null
    numeroAgente?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: IntFieldUpdateOperationsInput | number
  }

  export type funcionarioUncheckedUpdateManyWithoutFicheiroInput = {
    codFuncionario?: IntFieldUpdateOperationsInput | number
    codPessoa?: IntFieldUpdateOperationsInput | number
    codficheiroFotoPendente?: NullableIntFieldUpdateOperationsInput | number | null
    numeroAgente?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: IntFieldUpdateOperationsInput | number
  }

  export type pagamentomultaUpdateWithoutFicheiroInput = {
    dataPagamento?: DateTimeFieldUpdateOperationsInput | Date | string
    valorPago?: StringFieldUpdateOperationsInput | string
    descCodigoDeposito?: StringFieldUpdateOperationsInput | string
    multa?: multaUpdateOneRequiredWithoutPagamentomultaNestedInput
  }

  export type pagamentomultaUncheckedUpdateWithoutFicheiroInput = {
    codPagamentoMulta?: IntFieldUpdateOperationsInput | number
    codMulta?: IntFieldUpdateOperationsInput | number
    dataPagamento?: DateTimeFieldUpdateOperationsInput | Date | string
    valorPago?: StringFieldUpdateOperationsInput | string
    descCodigoDeposito?: StringFieldUpdateOperationsInput | string
  }

  export type pagamentomultaUncheckedUpdateManyWithoutFicheiroInput = {
    codPagamentoMulta?: IntFieldUpdateOperationsInput | number
    codMulta?: IntFieldUpdateOperationsInput | number
    dataPagamento?: DateTimeFieldUpdateOperationsInput | Date | string
    valorPago?: StringFieldUpdateOperationsInput | string
    descCodigoDeposito?: StringFieldUpdateOperationsInput | string
  }

  export type titulopropriedadeUpdateWithoutFicheiroInput = {
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroEmissao?: StringFieldUpdateOperationsInput | string
    pessoa?: pessoaUpdateOneRequiredWithoutTitulopropriedadeNestedInput
    viatura?: viaturaUpdateOneRequiredWithoutTitulopropriedadeNestedInput
  }

  export type titulopropriedadeUncheckedUpdateWithoutFicheiroInput = {
    codTituloPropriedade?: IntFieldUpdateOperationsInput | number
    codPessoa?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroEmissao?: StringFieldUpdateOperationsInput | string
    codViatura?: IntFieldUpdateOperationsInput | number
  }

  export type titulopropriedadeUncheckedUpdateManyWithoutFicheiroInput = {
    codTituloPropriedade?: IntFieldUpdateOperationsInput | number
    codPessoa?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroEmissao?: StringFieldUpdateOperationsInput | string
    codViatura?: IntFieldUpdateOperationsInput | number
  }

  export type multaCreateManyInfracao_multa_codInfracaoToinfracaoInput = {
    codMulta?: number
    codAutomobilista?: number | null
    CodViatura?: number | null
    valorMulta: string
    estadoMulta: $Enums.multa_estadoMulta
  }

  export type multaUpdateWithoutInfracao_multa_codInfracaoToinfracaoInput = {
    valorMulta?: StringFieldUpdateOperationsInput | string
    estadoMulta?: Enummulta_estadoMultaFieldUpdateOperationsInput | $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoUpdateManyWithoutMulta_infracao_codMultaTomultaNestedInput
    automobilista?: automobilistaUpdateOneWithoutMultaNestedInput
    viatura?: viaturaUpdateOneWithoutMultaNestedInput
    pagamentomulta?: pagamentomultaUpdateManyWithoutMultaNestedInput
  }

  export type multaUncheckedUpdateWithoutInfracao_multa_codInfracaoToinfracaoInput = {
    codMulta?: IntFieldUpdateOperationsInput | number
    codAutomobilista?: NullableIntFieldUpdateOperationsInput | number | null
    CodViatura?: NullableIntFieldUpdateOperationsInput | number | null
    valorMulta?: StringFieldUpdateOperationsInput | string
    estadoMulta?: Enummulta_estadoMultaFieldUpdateOperationsInput | $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoUncheckedUpdateManyWithoutMulta_infracao_codMultaTomultaNestedInput
    pagamentomulta?: pagamentomultaUncheckedUpdateManyWithoutMultaNestedInput
  }

  export type multaUncheckedUpdateManyWithoutInfracao_multa_codInfracaoToinfracaoInput = {
    codMulta?: IntFieldUpdateOperationsInput | number
    codAutomobilista?: NullableIntFieldUpdateOperationsInput | number | null
    CodViatura?: NullableIntFieldUpdateOperationsInput | number | null
    valorMulta?: StringFieldUpdateOperationsInput | string
    estadoMulta?: Enummulta_estadoMultaFieldUpdateOperationsInput | $Enums.multa_estadoMulta
  }

  export type livreteCreateManyMarcaInput = {
    codLivrete?: number
    codViatura: number
    numeroQuadro: string
    corViatura: string
    MedidasPneumaticos: string
    codServico: number
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    lotacao: string
    cilindrada: string
    numeroCilindro: string
    conbustivel: string
    peso: string
    tara: string
    tipoCaixa: string
    distanciaEixo: string
    modelo: string
  }

  export type livreteUpdateWithoutMarcaInput = {
    numeroQuadro?: StringFieldUpdateOperationsInput | string
    corViatura?: StringFieldUpdateOperationsInput | string
    MedidasPneumaticos?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    lotacao?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    numeroCilindro?: StringFieldUpdateOperationsInput | string
    conbustivel?: StringFieldUpdateOperationsInput | string
    peso?: StringFieldUpdateOperationsInput | string
    tara?: StringFieldUpdateOperationsInput | string
    tipoCaixa?: StringFieldUpdateOperationsInput | string
    distanciaEixo?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    viatura?: viaturaUpdateOneRequiredWithoutLivreteNestedInput
    serivicoviatura?: serivicoviaturaUpdateOneRequiredWithoutLivreteNestedInput
  }

  export type livreteUncheckedUpdateWithoutMarcaInput = {
    codLivrete?: IntFieldUpdateOperationsInput | number
    codViatura?: IntFieldUpdateOperationsInput | number
    numeroQuadro?: StringFieldUpdateOperationsInput | string
    corViatura?: StringFieldUpdateOperationsInput | string
    MedidasPneumaticos?: StringFieldUpdateOperationsInput | string
    codServico?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    lotacao?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    numeroCilindro?: StringFieldUpdateOperationsInput | string
    conbustivel?: StringFieldUpdateOperationsInput | string
    peso?: StringFieldUpdateOperationsInput | string
    tara?: StringFieldUpdateOperationsInput | string
    tipoCaixa?: StringFieldUpdateOperationsInput | string
    distanciaEixo?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
  }

  export type livreteUncheckedUpdateManyWithoutMarcaInput = {
    codLivrete?: IntFieldUpdateOperationsInput | number
    codViatura?: IntFieldUpdateOperationsInput | number
    numeroQuadro?: StringFieldUpdateOperationsInput | string
    corViatura?: StringFieldUpdateOperationsInput | string
    MedidasPneumaticos?: StringFieldUpdateOperationsInput | string
    codServico?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    lotacao?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    numeroCilindro?: StringFieldUpdateOperationsInput | string
    conbustivel?: StringFieldUpdateOperationsInput | string
    peso?: StringFieldUpdateOperationsInput | string
    tara?: StringFieldUpdateOperationsInput | string
    tipoCaixa?: StringFieldUpdateOperationsInput | string
    distanciaEixo?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
  }

  export type infracaoCreateManyMulta_infracao_codMultaTomultaInput = {
    codInfracao?: number
    codTipoInfracao: number
  }

  export type pagamentomultaCreateManyMultaInput = {
    codPagamentoMulta?: number
    dataPagamento: Date | string
    valorPago: string
    descCodigoDeposito: string
    codFicheiroPagamento: number
  }

  export type infracaoUpdateWithoutMulta_infracao_codMultaTomultaInput = {
    tipoinfracao?: tipoinfracaoUpdateOneRequiredWithoutInfracaoNestedInput
    multa_multa_codInfracaoToinfracao?: multaUpdateManyWithoutInfracao_multa_codInfracaoToinfracaoNestedInput
  }

  export type infracaoUncheckedUpdateWithoutMulta_infracao_codMultaTomultaInput = {
    codInfracao?: IntFieldUpdateOperationsInput | number
    codTipoInfracao?: IntFieldUpdateOperationsInput | number
    multa_multa_codInfracaoToinfracao?: multaUncheckedUpdateManyWithoutInfracao_multa_codInfracaoToinfracaoNestedInput
  }

  export type infracaoUncheckedUpdateManyWithoutMulta_infracao_codMultaTomultaInput = {
    codInfracao?: IntFieldUpdateOperationsInput | number
    codTipoInfracao?: IntFieldUpdateOperationsInput | number
  }

  export type pagamentomultaUpdateWithoutMultaInput = {
    dataPagamento?: DateTimeFieldUpdateOperationsInput | Date | string
    valorPago?: StringFieldUpdateOperationsInput | string
    descCodigoDeposito?: StringFieldUpdateOperationsInput | string
    ficheiro?: ficheiroUpdateOneRequiredWithoutPagamentomultaNestedInput
  }

  export type pagamentomultaUncheckedUpdateWithoutMultaInput = {
    codPagamentoMulta?: IntFieldUpdateOperationsInput | number
    dataPagamento?: DateTimeFieldUpdateOperationsInput | Date | string
    valorPago?: StringFieldUpdateOperationsInput | string
    descCodigoDeposito?: StringFieldUpdateOperationsInput | string
    codFicheiroPagamento?: IntFieldUpdateOperationsInput | number
  }

  export type pagamentomultaUncheckedUpdateManyWithoutMultaInput = {
    codPagamentoMulta?: IntFieldUpdateOperationsInput | number
    dataPagamento?: DateTimeFieldUpdateOperationsInput | Date | string
    valorPago?: StringFieldUpdateOperationsInput | string
    descCodigoDeposito?: StringFieldUpdateOperationsInput | string
    codFicheiroPagamento?: IntFieldUpdateOperationsInput | number
  }

  export type enderecoCreateManyMunicipioInput = {
    idEndereco?: number
    descricaoEndereco: string
  }

  export type enderecoUpdateWithoutMunicipioInput = {
    descricaoEndereco?: StringFieldUpdateOperationsInput | string
    pessoa?: pessoaUpdateManyWithoutEnderecoNestedInput
  }

  export type enderecoUncheckedUpdateWithoutMunicipioInput = {
    idEndereco?: IntFieldUpdateOperationsInput | number
    descricaoEndereco?: StringFieldUpdateOperationsInput | string
    pessoa?: pessoaUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type enderecoUncheckedUpdateManyWithoutMunicipioInput = {
    idEndereco?: IntFieldUpdateOperationsInput | number
    descricaoEndereco?: StringFieldUpdateOperationsInput | string
  }

  export type pessoaCreateManyPaisInput = {
    codPessoa?: number
    codEndereco?: number | null
    codContacto?: number | null
    nome: string
    genero: $Enums.pessoa_genero
    estadoCivil: $Enums.pessoa_estadoCivil
    dataCadastro?: string | null
    dataNascimento: string
    codBi: number
    senha: string
  }

  export type pessoaUpdateWithoutPaisInput = {
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    automobilista?: automobilistaUpdateManyWithoutPessoaNestedInput
    funcionario?: funcionarioUpdateManyWithoutPessoaNestedInput
    contacto?: contactoUpdateOneWithoutPessoaNestedInput
    endereco?: enderecoUpdateOneWithoutPessoaNestedInput
    bi?: biUpdateOneRequiredWithoutPessoaNestedInput
    titulopropriedade?: titulopropriedadeUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutPaisInput = {
    codPessoa?: IntFieldUpdateOperationsInput | number
    codEndereco?: NullableIntFieldUpdateOperationsInput | number | null
    codContacto?: NullableIntFieldUpdateOperationsInput | number | null
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    codBi?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    automobilista?: automobilistaUncheckedUpdateManyWithoutPessoaNestedInput
    funcionario?: funcionarioUncheckedUpdateManyWithoutPessoaNestedInput
    titulopropriedade?: titulopropriedadeUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateManyWithoutPaisInput = {
    codPessoa?: IntFieldUpdateOperationsInput | number
    codEndereco?: NullableIntFieldUpdateOperationsInput | number | null
    codContacto?: NullableIntFieldUpdateOperationsInput | number | null
    nome?: StringFieldUpdateOperationsInput | string
    genero?: Enumpessoa_generoFieldUpdateOperationsInput | $Enums.pessoa_genero
    estadoCivil?: Enumpessoa_estadoCivilFieldUpdateOperationsInput | $Enums.pessoa_estadoCivil
    dataCadastro?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: StringFieldUpdateOperationsInput | string
    codBi?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
  }

  export type automobilistaCreateManyPessoaInput = {
    codAutomobilista?: number
    codCartaConducao: number
  }

  export type funcionarioCreateManyPessoaInput = {
    codFuncionario?: number
    codficheiroFotoPerfil: number
    codficheiroFotoPendente?: number | null
    numeroAgente?: string | null
    senha?: number
  }

  export type titulopropriedadeCreateManyPessoaInput = {
    codTituloPropriedade?: number
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    numeroEmissao: string
    codViatura: number
    codFicheiroTituloPropriedade: number
  }

  export type automobilistaUpdateWithoutPessoaInput = {
    alertaroubo?: alertarouboUpdateManyWithoutAutomobilistaNestedInput
    cartaconducao?: cartaconducaoUpdateOneRequiredWithoutAutomobilistaNestedInput
    multa?: multaUpdateManyWithoutAutomobilistaNestedInput
  }

  export type automobilistaUncheckedUpdateWithoutPessoaInput = {
    codAutomobilista?: IntFieldUpdateOperationsInput | number
    codCartaConducao?: IntFieldUpdateOperationsInput | number
    alertaroubo?: alertarouboUncheckedUpdateManyWithoutAutomobilistaNestedInput
    multa?: multaUncheckedUpdateManyWithoutAutomobilistaNestedInput
  }

  export type automobilistaUncheckedUpdateManyWithoutPessoaInput = {
    codAutomobilista?: IntFieldUpdateOperationsInput | number
    codCartaConducao?: IntFieldUpdateOperationsInput | number
  }

  export type funcionarioUpdateWithoutPessoaInput = {
    codficheiroFotoPendente?: NullableIntFieldUpdateOperationsInput | number | null
    numeroAgente?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: IntFieldUpdateOperationsInput | number
    ficheiro?: ficheiroUpdateOneRequiredWithoutFuncionarioNestedInput
  }

  export type funcionarioUncheckedUpdateWithoutPessoaInput = {
    codFuncionario?: IntFieldUpdateOperationsInput | number
    codficheiroFotoPerfil?: IntFieldUpdateOperationsInput | number
    codficheiroFotoPendente?: NullableIntFieldUpdateOperationsInput | number | null
    numeroAgente?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: IntFieldUpdateOperationsInput | number
  }

  export type funcionarioUncheckedUpdateManyWithoutPessoaInput = {
    codFuncionario?: IntFieldUpdateOperationsInput | number
    codficheiroFotoPerfil?: IntFieldUpdateOperationsInput | number
    codficheiroFotoPendente?: NullableIntFieldUpdateOperationsInput | number | null
    numeroAgente?: NullableStringFieldUpdateOperationsInput | string | null
    senha?: IntFieldUpdateOperationsInput | number
  }

  export type titulopropriedadeUpdateWithoutPessoaInput = {
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroEmissao?: StringFieldUpdateOperationsInput | string
    viatura?: viaturaUpdateOneRequiredWithoutTitulopropriedadeNestedInput
    ficheiro?: ficheiroUpdateOneRequiredWithoutTitulopropriedadeNestedInput
  }

  export type titulopropriedadeUncheckedUpdateWithoutPessoaInput = {
    codTituloPropriedade?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroEmissao?: StringFieldUpdateOperationsInput | string
    codViatura?: IntFieldUpdateOperationsInput | number
    codFicheiroTituloPropriedade?: IntFieldUpdateOperationsInput | number
  }

  export type titulopropriedadeUncheckedUpdateManyWithoutPessoaInput = {
    codTituloPropriedade?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroEmissao?: StringFieldUpdateOperationsInput | string
    codViatura?: IntFieldUpdateOperationsInput | number
    codFicheiroTituloPropriedade?: IntFieldUpdateOperationsInput | number
  }

  export type municipioCreateManyProvinciaInput = {
    idMunicipio?: number
    municipio: string
  }

  export type municipioUpdateWithoutProvinciaInput = {
    municipio?: StringFieldUpdateOperationsInput | string
    endereco?: enderecoUpdateManyWithoutMunicipioNestedInput
  }

  export type municipioUncheckedUpdateWithoutProvinciaInput = {
    idMunicipio?: IntFieldUpdateOperationsInput | number
    municipio?: StringFieldUpdateOperationsInput | string
    endereco?: enderecoUncheckedUpdateManyWithoutMunicipioNestedInput
  }

  export type municipioUncheckedUpdateManyWithoutProvinciaInput = {
    idMunicipio?: IntFieldUpdateOperationsInput | number
    municipio?: StringFieldUpdateOperationsInput | string
  }

  export type livreteCreateManySerivicoviaturaInput = {
    codLivrete?: number
    codViatura: number
    numeroQuadro: string
    corViatura: string
    MedidasPneumaticos: string
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    lotacao: string
    cilindrada: string
    numeroCilindro: string
    conbustivel: string
    peso: string
    tara: string
    tipoCaixa: string
    distanciaEixo: string
    modelo: string
    codMarca: number
  }

  export type livreteUpdateWithoutSerivicoviaturaInput = {
    numeroQuadro?: StringFieldUpdateOperationsInput | string
    corViatura?: StringFieldUpdateOperationsInput | string
    MedidasPneumaticos?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    lotacao?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    numeroCilindro?: StringFieldUpdateOperationsInput | string
    conbustivel?: StringFieldUpdateOperationsInput | string
    peso?: StringFieldUpdateOperationsInput | string
    tara?: StringFieldUpdateOperationsInput | string
    tipoCaixa?: StringFieldUpdateOperationsInput | string
    distanciaEixo?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    marca?: marcaUpdateOneRequiredWithoutLivreteNestedInput
    viatura?: viaturaUpdateOneRequiredWithoutLivreteNestedInput
  }

  export type livreteUncheckedUpdateWithoutSerivicoviaturaInput = {
    codLivrete?: IntFieldUpdateOperationsInput | number
    codViatura?: IntFieldUpdateOperationsInput | number
    numeroQuadro?: StringFieldUpdateOperationsInput | string
    corViatura?: StringFieldUpdateOperationsInput | string
    MedidasPneumaticos?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    lotacao?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    numeroCilindro?: StringFieldUpdateOperationsInput | string
    conbustivel?: StringFieldUpdateOperationsInput | string
    peso?: StringFieldUpdateOperationsInput | string
    tara?: StringFieldUpdateOperationsInput | string
    tipoCaixa?: StringFieldUpdateOperationsInput | string
    distanciaEixo?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    codMarca?: IntFieldUpdateOperationsInput | number
  }

  export type livreteUncheckedUpdateManyWithoutSerivicoviaturaInput = {
    codLivrete?: IntFieldUpdateOperationsInput | number
    codViatura?: IntFieldUpdateOperationsInput | number
    numeroQuadro?: StringFieldUpdateOperationsInput | string
    corViatura?: StringFieldUpdateOperationsInput | string
    MedidasPneumaticos?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    lotacao?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    numeroCilindro?: StringFieldUpdateOperationsInput | string
    conbustivel?: StringFieldUpdateOperationsInput | string
    peso?: StringFieldUpdateOperationsInput | string
    tara?: StringFieldUpdateOperationsInput | string
    tipoCaixa?: StringFieldUpdateOperationsInput | string
    distanciaEixo?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    codMarca?: IntFieldUpdateOperationsInput | number
  }

  export type infracaoCreateManyTipoinfracaoInput = {
    codInfracao?: number
    codMulta: number
  }

  export type infracaoUpdateWithoutTipoinfracaoInput = {
    multa_infracao_codMultaTomulta?: multaUpdateOneRequiredWithoutInfracao_infracao_codMultaTomultaNestedInput
    multa_multa_codInfracaoToinfracao?: multaUpdateManyWithoutInfracao_multa_codInfracaoToinfracaoNestedInput
  }

  export type infracaoUncheckedUpdateWithoutTipoinfracaoInput = {
    codInfracao?: IntFieldUpdateOperationsInput | number
    codMulta?: IntFieldUpdateOperationsInput | number
    multa_multa_codInfracaoToinfracao?: multaUncheckedUpdateManyWithoutInfracao_multa_codInfracaoToinfracaoNestedInput
  }

  export type infracaoUncheckedUpdateManyWithoutTipoinfracaoInput = {
    codInfracao?: IntFieldUpdateOperationsInput | number
    codMulta?: IntFieldUpdateOperationsInput | number
  }

  export type alertarouboCreateManyTiporouboInput = {
    codAlertaRoubo?: number
    codAutomobilista: number
    codViatura: number
    dataRoubo: Date | string
    enderecoRoubo: string
    descRoubo: string
  }

  export type alertarouboUpdateWithoutTiporouboInput = {
    dataRoubo?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoRoubo?: StringFieldUpdateOperationsInput | string
    descRoubo?: StringFieldUpdateOperationsInput | string
    automobilista?: automobilistaUpdateOneRequiredWithoutAlertarouboNestedInput
    viatura?: viaturaUpdateOneRequiredWithoutAlertarouboNestedInput
  }

  export type alertarouboUncheckedUpdateWithoutTiporouboInput = {
    codAlertaRoubo?: IntFieldUpdateOperationsInput | number
    codAutomobilista?: IntFieldUpdateOperationsInput | number
    codViatura?: IntFieldUpdateOperationsInput | number
    dataRoubo?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoRoubo?: StringFieldUpdateOperationsInput | string
    descRoubo?: StringFieldUpdateOperationsInput | string
  }

  export type alertarouboUncheckedUpdateManyWithoutTiporouboInput = {
    codAlertaRoubo?: IntFieldUpdateOperationsInput | number
    codAutomobilista?: IntFieldUpdateOperationsInput | number
    codViatura?: IntFieldUpdateOperationsInput | number
    dataRoubo?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoRoubo?: StringFieldUpdateOperationsInput | string
    descRoubo?: StringFieldUpdateOperationsInput | string
  }

  export type alertarouboCreateManyViaturaInput = {
    codAlertaRoubo?: number
    codAutomobilista: number
    dataRoubo: Date | string
    enderecoRoubo: string
    codTipoRoubo: number
    descRoubo: string
  }

  export type livreteCreateManyViaturaInput = {
    codLivrete?: number
    numeroQuadro: string
    corViatura: string
    MedidasPneumaticos: string
    codServico: number
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    lotacao: string
    cilindrada: string
    numeroCilindro: string
    conbustivel: string
    peso: string
    tara: string
    tipoCaixa: string
    distanciaEixo: string
    modelo: string
    codMarca: number
  }

  export type multaCreateManyViaturaInput = {
    codMulta?: number
    codAutomobilista?: number | null
    codInfracao: number
    valorMulta: string
    estadoMulta: $Enums.multa_estadoMulta
  }

  export type titulopropriedadeCreateManyViaturaInput = {
    codTituloPropriedade?: number
    codPessoa: number
    dataEmissao: Date | string
    dataPrimeiroRegistro: Date | string
    numeroEmissao: string
    codFicheiroTituloPropriedade: number
  }

  export type alertarouboUpdateWithoutViaturaInput = {
    dataRoubo?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoRoubo?: StringFieldUpdateOperationsInput | string
    descRoubo?: StringFieldUpdateOperationsInput | string
    automobilista?: automobilistaUpdateOneRequiredWithoutAlertarouboNestedInput
    tiporoubo?: tiporouboUpdateOneRequiredWithoutAlertarouboNestedInput
  }

  export type alertarouboUncheckedUpdateWithoutViaturaInput = {
    codAlertaRoubo?: IntFieldUpdateOperationsInput | number
    codAutomobilista?: IntFieldUpdateOperationsInput | number
    dataRoubo?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoRoubo?: StringFieldUpdateOperationsInput | string
    codTipoRoubo?: IntFieldUpdateOperationsInput | number
    descRoubo?: StringFieldUpdateOperationsInput | string
  }

  export type alertarouboUncheckedUpdateManyWithoutViaturaInput = {
    codAlertaRoubo?: IntFieldUpdateOperationsInput | number
    codAutomobilista?: IntFieldUpdateOperationsInput | number
    dataRoubo?: DateTimeFieldUpdateOperationsInput | Date | string
    enderecoRoubo?: StringFieldUpdateOperationsInput | string
    codTipoRoubo?: IntFieldUpdateOperationsInput | number
    descRoubo?: StringFieldUpdateOperationsInput | string
  }

  export type livreteUpdateWithoutViaturaInput = {
    numeroQuadro?: StringFieldUpdateOperationsInput | string
    corViatura?: StringFieldUpdateOperationsInput | string
    MedidasPneumaticos?: StringFieldUpdateOperationsInput | string
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    lotacao?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    numeroCilindro?: StringFieldUpdateOperationsInput | string
    conbustivel?: StringFieldUpdateOperationsInput | string
    peso?: StringFieldUpdateOperationsInput | string
    tara?: StringFieldUpdateOperationsInput | string
    tipoCaixa?: StringFieldUpdateOperationsInput | string
    distanciaEixo?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    marca?: marcaUpdateOneRequiredWithoutLivreteNestedInput
    serivicoviatura?: serivicoviaturaUpdateOneRequiredWithoutLivreteNestedInput
  }

  export type livreteUncheckedUpdateWithoutViaturaInput = {
    codLivrete?: IntFieldUpdateOperationsInput | number
    numeroQuadro?: StringFieldUpdateOperationsInput | string
    corViatura?: StringFieldUpdateOperationsInput | string
    MedidasPneumaticos?: StringFieldUpdateOperationsInput | string
    codServico?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    lotacao?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    numeroCilindro?: StringFieldUpdateOperationsInput | string
    conbustivel?: StringFieldUpdateOperationsInput | string
    peso?: StringFieldUpdateOperationsInput | string
    tara?: StringFieldUpdateOperationsInput | string
    tipoCaixa?: StringFieldUpdateOperationsInput | string
    distanciaEixo?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    codMarca?: IntFieldUpdateOperationsInput | number
  }

  export type livreteUncheckedUpdateManyWithoutViaturaInput = {
    codLivrete?: IntFieldUpdateOperationsInput | number
    numeroQuadro?: StringFieldUpdateOperationsInput | string
    corViatura?: StringFieldUpdateOperationsInput | string
    MedidasPneumaticos?: StringFieldUpdateOperationsInput | string
    codServico?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    lotacao?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    numeroCilindro?: StringFieldUpdateOperationsInput | string
    conbustivel?: StringFieldUpdateOperationsInput | string
    peso?: StringFieldUpdateOperationsInput | string
    tara?: StringFieldUpdateOperationsInput | string
    tipoCaixa?: StringFieldUpdateOperationsInput | string
    distanciaEixo?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    codMarca?: IntFieldUpdateOperationsInput | number
  }

  export type multaUpdateWithoutViaturaInput = {
    valorMulta?: StringFieldUpdateOperationsInput | string
    estadoMulta?: Enummulta_estadoMultaFieldUpdateOperationsInput | $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoUpdateManyWithoutMulta_infracao_codMultaTomultaNestedInput
    automobilista?: automobilistaUpdateOneWithoutMultaNestedInput
    infracao_multa_codInfracaoToinfracao?: infracaoUpdateOneRequiredWithoutMulta_multa_codInfracaoToinfracaoNestedInput
    pagamentomulta?: pagamentomultaUpdateManyWithoutMultaNestedInput
  }

  export type multaUncheckedUpdateWithoutViaturaInput = {
    codMulta?: IntFieldUpdateOperationsInput | number
    codAutomobilista?: NullableIntFieldUpdateOperationsInput | number | null
    codInfracao?: IntFieldUpdateOperationsInput | number
    valorMulta?: StringFieldUpdateOperationsInput | string
    estadoMulta?: Enummulta_estadoMultaFieldUpdateOperationsInput | $Enums.multa_estadoMulta
    infracao_infracao_codMultaTomulta?: infracaoUncheckedUpdateManyWithoutMulta_infracao_codMultaTomultaNestedInput
    pagamentomulta?: pagamentomultaUncheckedUpdateManyWithoutMultaNestedInput
  }

  export type multaUncheckedUpdateManyWithoutViaturaInput = {
    codMulta?: IntFieldUpdateOperationsInput | number
    codAutomobilista?: NullableIntFieldUpdateOperationsInput | number | null
    codInfracao?: IntFieldUpdateOperationsInput | number
    valorMulta?: StringFieldUpdateOperationsInput | string
    estadoMulta?: Enummulta_estadoMultaFieldUpdateOperationsInput | $Enums.multa_estadoMulta
  }

  export type titulopropriedadeUpdateWithoutViaturaInput = {
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroEmissao?: StringFieldUpdateOperationsInput | string
    pessoa?: pessoaUpdateOneRequiredWithoutTitulopropriedadeNestedInput
    ficheiro?: ficheiroUpdateOneRequiredWithoutTitulopropriedadeNestedInput
  }

  export type titulopropriedadeUncheckedUpdateWithoutViaturaInput = {
    codTituloPropriedade?: IntFieldUpdateOperationsInput | number
    codPessoa?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroEmissao?: StringFieldUpdateOperationsInput | string
    codFicheiroTituloPropriedade?: IntFieldUpdateOperationsInput | number
  }

  export type titulopropriedadeUncheckedUpdateManyWithoutViaturaInput = {
    codTituloPropriedade?: IntFieldUpdateOperationsInput | number
    codPessoa?: IntFieldUpdateOperationsInput | number
    dataEmissao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPrimeiroRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    numeroEmissao?: StringFieldUpdateOperationsInput | string
    codFicheiroTituloPropriedade?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AutomobilistaCountOutputTypeDefaultArgs instead
     */
    export type AutomobilistaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AutomobilistaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BiCountOutputTypeDefaultArgs instead
     */
    export type BiCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BiCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CartaconducaoCountOutputTypeDefaultArgs instead
     */
    export type CartaconducaoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CartaconducaoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriacartaCountOutputTypeDefaultArgs instead
     */
    export type CategoriacartaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriacartaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactoCountOutputTypeDefaultArgs instead
     */
    export type ContactoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnderecoCountOutputTypeDefaultArgs instead
     */
    export type EnderecoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnderecoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FicheiroCountOutputTypeDefaultArgs instead
     */
    export type FicheiroCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FicheiroCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InfracaoCountOutputTypeDefaultArgs instead
     */
    export type InfracaoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InfracaoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarcaCountOutputTypeDefaultArgs instead
     */
    export type MarcaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarcaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MultaCountOutputTypeDefaultArgs instead
     */
    export type MultaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MultaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MunicipioCountOutputTypeDefaultArgs instead
     */
    export type MunicipioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MunicipioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaisCountOutputTypeDefaultArgs instead
     */
    export type PaisCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaisCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PessoaCountOutputTypeDefaultArgs instead
     */
    export type PessoaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PessoaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProvinciaCountOutputTypeDefaultArgs instead
     */
    export type ProvinciaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProvinciaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SerivicoviaturaCountOutputTypeDefaultArgs instead
     */
    export type SerivicoviaturaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SerivicoviaturaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TipoinfracaoCountOutputTypeDefaultArgs instead
     */
    export type TipoinfracaoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TipoinfracaoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TiporouboCountOutputTypeDefaultArgs instead
     */
    export type TiporouboCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TiporouboCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ViaturaCountOutputTypeDefaultArgs instead
     */
    export type ViaturaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ViaturaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use alertarouboDefaultArgs instead
     */
    export type alertarouboArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = alertarouboDefaultArgs<ExtArgs>
    /**
     * @deprecated Use automobilistaDefaultArgs instead
     */
    export type automobilistaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = automobilistaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use biDefaultArgs instead
     */
    export type biArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = biDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cartaconducaoDefaultArgs instead
     */
    export type cartaconducaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cartaconducaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use categoriacartaDefaultArgs instead
     */
    export type categoriacartaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = categoriacartaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use contactoDefaultArgs instead
     */
    export type contactoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = contactoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use enderecoDefaultArgs instead
     */
    export type enderecoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = enderecoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ficheiroDefaultArgs instead
     */
    export type ficheiroArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ficheiroDefaultArgs<ExtArgs>
    /**
     * @deprecated Use funcionarioDefaultArgs instead
     */
    export type funcionarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = funcionarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use infracaoDefaultArgs instead
     */
    export type infracaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = infracaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use livreteDefaultArgs instead
     */
    export type livreteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = livreteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use marcaDefaultArgs instead
     */
    export type marcaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = marcaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use multaDefaultArgs instead
     */
    export type multaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = multaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use municipioDefaultArgs instead
     */
    export type municipioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = municipioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pagamentomultaDefaultArgs instead
     */
    export type pagamentomultaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pagamentomultaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use paisDefaultArgs instead
     */
    export type paisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = paisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pessoaDefaultArgs instead
     */
    export type pessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pessoaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use provinciaDefaultArgs instead
     */
    export type provinciaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = provinciaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use serivicoviaturaDefaultArgs instead
     */
    export type serivicoviaturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = serivicoviaturaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tipoinfracaoDefaultArgs instead
     */
    export type tipoinfracaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tipoinfracaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tiporouboDefaultArgs instead
     */
    export type tiporouboArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tiporouboDefaultArgs<ExtArgs>
    /**
     * @deprecated Use titulopropriedadeDefaultArgs instead
     */
    export type titulopropriedadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = titulopropriedadeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use viaturaDefaultArgs instead
     */
    export type viaturaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = viaturaDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}